---
title: "Variance-only based modelling with admr"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Variance-only based modelling with admr}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  markdown: 
    wrap: sentence
---

# Variance based modelling

This vignette provides an introduction to variance-based modeling using the `admr` package in R. We'll cover the essential steps to prepare your data, specify a pharmacokinetic model, fit the model to aggregate data, and evaluate the results. We'll compare the results of using mean and variance only data to the full mean and covariance data. Variance based modeling is particularly useful when complex aggregate data is not available, and only means and variances are reported.

The `admr` package implements the Iterative Reweighting Monte Carlo (IRMC) algorithm, which efficiently fits models to aggregate data by iteratively updating parameter estimates using weighted importance sampling.

## Required Packages

First, we need to load the necessary packages:

<details><summary>Click here</summary>
```{r setup, message = FALSE, warning = FALSE}
library(admr)
library(rxode2)
library(nlmixr2)
library(dplyr)
library(tidyr)
library(mnorm)
library(ggplot2)  # For visualization
library(units)
```
</details>

## Understanding the Data Format

The `admr` package works with two types of data formats:

1. **Raw Data**: Individual-level observations in a wide or long format.
2. **Aggregate Data**: Summary statistics (mean and covariance) computed from raw data.
3. **Aggregate Data with only means and variance**: Mean and variance for each time point (no covariances).

Let's look at the examplomycin dataset, which we'll use throughout this vignette:

```{r, cache=TRUE}
# Load the dataset
data(examplomycin)
head(examplomycin)

# Basic dataset information
cat("Number of subjects:", length(unique(examplomycin$ID)), "\n")
cat("Number of time points:", length(unique(examplomycin$TIME)), "\n")
cat("Time points:", paste(sort(unique(examplomycin$TIME)), collapse = ", "), "\n")
```

## Data Preparation

### Converting Raw Data to Aggregate Format

The first step is to convert our simulated raw data into aggregate format. Then, we will create two versions of the aggregated data: one with mean and covariance, and another with mean and variance only. In real-world scenarios, you will not have access to the raw data, but this step is included here for demonstration purposes. 

<details><summary>Click here</summary>
```{r, cache=TRUE}
# Convert to wide format
examplomycin_wide <- examplomycin %>%
  filter(EVID != 101) %>%  # Remove dosing events
  dplyr::select(ID, TIME, DV) %>%  # Select relevant columns
  pivot_wider(names_from = TIME, values_from = DV) %>%  # Convert to wide format
  dplyr::select(-c(1))  # Remove ID column

# Create aggregated data
examplomycin_aggregated <- examplomycin_wide %>%
  admr::meancov()  # Compute mean and covariance

# View the structure of aggregated data
examplomycin_aggregated

# Transform into mean and variance only format
examplomycin_aggregated_var <- examplomycin_aggregated
examplomycin_aggregated_var$V <- diag(diag(examplomycin_aggregated_var$V))

# View the structure of mean and variance only data
examplomycin_aggregated_var

```
</details>

### Visualizing the Data

Before fitting the model, it's helpful to visualize the data:

```{r, cache=TRUE}
# Boxplot to visualize variability
ggplot(examplomycin, aes(x = TIME, y = DV, group = TIME)) +
  geom_boxplot(aes(group = TIME), width = 0.2) +
  labs(
    title = "Concentration Variability at Each Time Point",
    x = "Time (hours)",
    y = "Concentration (mg/L)"
  ) +
  theme_minimal()
```

## Model Specification

### Defining the Pharmacokinetic Model

We'll use a solved two-compartment model with first-order absorption: 

<details><summary>Click here</summary>
```{r, message = FALSE, warning = FALSE}
# Define RxODE model
rxModel <- function(){
  model({
    cp = linCmt(
      cl,           # Clearance
      v1,           # Volume of central compartment
      v2,           # Volume of peripheral compartment
      q,            # Inter-compartmental clearance
      ka            # Absorption rate constant
    )})
}

rxModel <- rxode2(rxModel)
rxModel <- rxModel$simulationModel
```
</details>

### Creating the Prediction Function

The prediction function is crucial for the `admr` package. It:
- Constructs the event table for dosing and sampling
- Solves the RxODE model
- Returns predicted concentrations in the required format

```{r, cache=TRUE}
rxode2::rxSetSilentErr(1)

predder <- function(time, theta_i, dose = 100) {
    n_individuals <- nrow(theta_i)
    
    if (is.null(n_individuals)) {
      n_individuals <- 1
    }

    # Create event table
    ev <- eventTable(amount.units="mg", time.units="hours")
    ev$add.dosing(dose = dose, nbr.doses = 1, start.time = 0)
    ev$add.sampling(time)
    
    # Solve model
    out <- rxSolve(rxModel, params = theta_i, events = ev, cores = 0)
    
    # Format output
    cp_matrix <- matrix(out$cp, nrow = n_individuals, ncol = length(time), 
                        byrow = TRUE)
    
    return(cp_matrix)
}
```
It can be observed that all steps for variance based modeling are similar to the mean and covariance based modeling. The only difference is in the data that is used for fitting the model.

## Model Fitting

### Setting Up Model Options

The `genopts` function creates an options object that controls the model fitting process. We'll do this twice: once for mean and covariance data, and once for mean and variance only data.

<details><summary>Click here</summary>
```{r, cache=TRUE}
opts_covar <- genopts(
  time = c(.1, .25, .5, 1, 2, 3, 5, 8, 12),  # Observation times
  p = list(
    beta = c(cl = 5, v1 = 10, v2 = 30, q = 10, ka = 1),  # Population parameters
    Omega = matrix(c(0.09, 0, 0, 0, 0,
                    0, 0.09, 0, 0, 0,
                    0, 0, 0.09, 0, 0,
                    0, 0, 0, 0.09, 0,
                    0, 0, 0, 0, 0.09), nrow = 5, ncol = 5),  # Random effects
    Sigma_prop = 0.04  # Proportional error
  ),
  nsim = 10000,  # Number of Monte Carlo samples
  n = 500,      # Number of individuals
  fo_appr = FALSE,  # Disable first-order approximation
  omega_expansion = 1,  # Omega expansion factor
  f = predder,    # Prediction function
  no_cov = FALSE # Use mean and covariance format
)


opts_var <- genopts(
  time = c(.1, .25, .5, 1, 2, 3, 5, 8, 12),  # Observation times
  p = list(
    beta = c(cl = 5, v1 = 10, v2 = 30, q = 10, ka = 1),  # Population parameters
    Omega = matrix(c(0.09, 0, 0, 0, 0,
                    0, 0.09, 0, 0, 0,
                    0, 0, 0.09, 0, 0,
                    0, 0, 0, 0.09, 0,
                    0, 0, 0, 0, 0.09), nrow = 5, ncol = 5),  # Random effects
    Sigma_prop = 0.04  # Proportional error
  ),
  nsim = 10000,  # Number of Monte Carlo samples
  n = 500,      # Number of individuals
  fo_appr = FALSE,  # Disable first-order approximation
  omega_expansion = 1,  # Omega expansion factor
  f = predder,    # Prediction function
  no_cov = TRUE # Use mean and variance only format
)
```
</details>

The only difference between the two options is the `no_cov` argument, which is set to `TRUE` for variance only data and `FALSE` for mean and covariance data.


### Fitting the Model

The `fitIRMC` function fits the model using the IRMC algorithm:

```{r, cache=TRUE}
fit.var <- admr::fitIRMC(
  opts = opts_var,
  obs = examplomycin_aggregated_var,
  chains = 3,  # Number of chains
  maxiter = 200  # Maximum iterations
)

fit.covar <- admr::fitIRMC(
  opts = opts_covar,
  obs = examplomycin_aggregated,
  chains = 3,  # Number of chains
  maxiter = 200  # Maximum iterations
)
```

## Model Diagnostics

### Basic Diagnostics
The `print` method provides a summary of the model fit:
```{r}
print(fit.var)
print(fit.covar)
```

### Convergence Assessment
The `plot` method visualizes the convergence of the model fit:
```{r}
plot(fit.var)
```
First variance only data is plotted. We see that the model converges well within the specified iterations. Now we plot the mean and covariance data fit:

```{r}
plot(fit.covar)
```
This data seems to converge slightly better, especially when looking at chain comparisons. All chains converge to similar values, whereas in the variance only data, the chains show more variability while resulting in the same NLL. This is due to non-identifiability issues of some parameters when only variance data is used.

### True vs Estimated Parameters
Given that true parameter estimates are known, we can compare the estimated parameters to the true values:
```{r}
params.true <- list(
  beta = c(cl = 5, v1 = 10, v2 = 30, q = 10, ka = 1),
  Omega = diag(rep(0.09, 5)),
  Sigma_prop = 0.04
)
cat("True parameter values:\n")
print(params.true)

cat("Estimated parameters (mean and variance only):\n")
print(fit.var$transformed_params)
```
We observe that both methods recover the true parameters reasonably well, but the mean and covariance method provides more accurate estimates due to the additional information from covariances. In this example model, especially inter-compartmental clearance (q) and its random effect are more challenging to estimate accurately with only variance data. However, using larger sample sizes from more studies will help improve the estimates from both data. To further illustrate the differences in dynamics, we can simulate concentration-time profiles using the true parameters and the estimated parameters from both methods.



### Dosing plot with Confidence Intervals for true vs estimated parameters

Let's simulate concentration-time profiles using the true parameters and the estimated parameters from both methods, and then plot the results with confidence intervals. First, we define the models using the true parameters and the estimated parameters from both methods:

<details><summary>Click here</summary>
```{r}
params.true <- list(
  beta = c(cl = 5, v1 = 10, v2 = 30, q = 10, ka = 1),
  Omega = diag(rep(0.09, 5)),
  Sigma_prop = 0.04
)

params.covar <- fit.covar$transformed_params
params.var <- fit.var$transformed_params

rxModel_true <- function(){
  ini({
    cl <- params.true$beta["cl"]  # Clearance
    v1 <- params.true$beta["v1"]  # Volume of central compartment
    v2 <- params.true$beta["v2"] # Volume of peripheral compartment
    q <- params.true$beta["q"]    # Inter-compartmental clearance
    ka <- params.true$beta["ka"]   # Absorption rate constant

    eta_cl ~ params.true$Omega[1,1]
    eta_v1 ~ params.true$Omega[2,2]
    eta_v2 ~ params.true$Omega[3,3]
    eta_q ~ params.true$Omega[4,4]
    eta_ka ~ params.true$Omega[5,5]
  })
  model({
    cl <- cl * exp(eta_cl)
    v1 <- v1 * exp(eta_v1)
    v2 <- v2 * exp(eta_v2)
    q <- q * exp(eta_q)
    ka <- ka * exp(eta_ka)
    cp = linCmt(cl, v1, v2, q, ka)
  })
}
rxModel_covar <- function(){
  ini({
    cl <- params.covar$beta["cl"]  # Clearance
    v1 <- params.covar$beta["v1"]  # Volume of central compartment
    v2 <- params.covar$beta["v2"] # Volume of peripheral compartment
    q <- params.covar$beta["q"]    # Inter-compartmental clearance
    ka <- params.covar$beta["ka"]   # Absorption rate constant

    eta_cl ~ params.covar$Omega[1,1]
    eta_v1 ~ params.covar$Omega[2,2]
    eta_v2 ~ params.covar$Omega[3,3]
    eta_q ~ params.covar$Omega[4,4]
    eta_ka ~ params.covar$Omega[5,5]
  })
  model({
    cl <- cl * exp(eta_cl)
    v1 <- v1 * exp(eta_v1)
    v2 <- v2 * exp(eta_v2)
    q <- q * exp(eta_q)
    ka <- ka * exp(eta_ka)
    cp = linCmt(cl, v1, v2, q, ka)
  })
}
rxModel_var <- function(){
  ini({
    cl <- params.var$beta["cl"]  # Clearance
    v1 <- params.var$beta["v1"]  # Volume of central compartment
    v2 <- params.var$beta["v2"] # Volume of peripheral compartment
    q <- params.var$beta["q"]    # Inter-compartmental clearance
    ka <- params.var$beta["ka"]   # Absorption rate constant

    eta_cl ~ params.var$Omega[1,1]
    eta_v1 ~ params.var$Omega[2,2]
    eta_v2 ~ params.var$Omega[3,3]
    eta_q ~ params.var$Omega[4,4]
    eta_ka ~ params.var$Omega[5,5]
  })
  model({
    cl <- cl * exp(eta_cl)
    v1 <- v1 * exp(eta_v1)
    v2 <- v2 * exp(eta_v2)
    q <- q * exp(eta_q)
    ka <- ka * exp(eta_ka)
    cp = linCmt(cl, v1, v2, q, ka)
  })
}

rxModel_true <- rxode2(rxModel_true())
rxModel_true <- rxModel_true$simulationModel
rxModel_covar <- rxode2(rxModel_covar())
rxModel_covar <- rxModel_covar$simulationModel
rxModel_var <- rxode2(rxModel_var())
rxModel_var <- rxModel_var$simulationModel
```
</details>

Now we can simulate the concentration-time profiles and plot the results:
```{r}
time_points <- seq(0, 12, by = 0.01)  # Dense time points for smooth curves
ev <- eventTable(amount.units="mg", time.units="hours")
ev$add.dosing(dose = 100, nbr.doses = 2, dosing.interval = 6)
ev$add.sampling(time_points)


sim_true <- rxSolve(rxModel_true, events = ev, cores = 0, nSub = 10000)
sim_covar <- rxSolve(rxModel_covar, events = ev, cores = 0, nSub = 10000)
sim_var <- rxSolve(rxModel_var, events = ev, cores = 0, nSub = 10000)

# Combine the confidence intervals with a label for the model
ci_true <- as.data.frame(confint(sim_true, "cp", level=0.95)) %>%
  mutate(Model = "True parameters")

ci_covar <- as.data.frame(confint(sim_covar, "cp", level=0.95)) %>%
  mutate(Model = "Covariance fit")

ci_var <- as.data.frame(confint(sim_var, "cp", level=0.95)) %>%
  mutate(Model = "Variance fit")

# Bind them together
ci_true_covar <- bind_rows(ci_true, ci_covar) %>%
  mutate(
    p1 = as.numeric(as.character(p1)),
    Percentile = factor(Percentile, levels = unique(Percentile[order(p1)]))
  )

ci_true_var <- bind_rows(ci_true, ci_var) %>%
  mutate(
    p1 = as.numeric(as.character(p1)),
    Percentile = factor(Percentile, levels = unique(Percentile[order(p1)]))
  )

# Plot both models
ggplot(ci_true_covar, aes(x = time, group = interaction(Model, Percentile))) +
  geom_ribbon(aes(ymin = p2.5, ymax = p97.5, fill = Model),
              alpha = 0.2, colour = NA) +
  geom_line(aes(y = p50, colour = Model), size = 0.8) +
  labs(
    title = "Central Concentration Simulations",
    x = "Time",
    y = "Central Concentration (mg/L)"
  ) +
  theme_bw(base_size = 14) +
  scale_colour_manual(values = c("True parameters" = "blue",
                                 "Covariance fit" = "red")) +
  scale_fill_manual(values = c("True parameters" = "blue",
                               "Covariance fit" = "red")) +
  coord_cartesian(xlim = c(0, 12), ylim = c(0, 7))

ggplot(ci_true_var, aes(x = time, group = interaction(Model, Percentile))) +
  geom_ribbon(aes(ymin = p2.5, ymax = p97.5, fill = Model),
              alpha = 0.2, colour = NA) +
  geom_line(aes(y = p50, colour = Model), size = 0.8) +
  labs(
    title = "Central Concentration Simulations",
    x = "Time",
    y = "Central Concentration (mg/L)"
  ) +
  theme_bw(base_size = 14) +
  scale_colour_manual(values = c("True parameters" = "blue",
                                 "Variance fit" = "darkgreen")) +
  scale_fill_manual(values = c("True parameters" = "blue",
                                 "Variance fit" = "darkgreen")) +
  coord_cartesian(xlim = c(0, 12), ylim = c(0, 7))



```
Both models capture the central tendency of the true parameters dynamics well. However, the variance only model shows slightly wider population intervals. In this scenario this isn't very problematic, since a wider range still captures the true dynamics. However, in other scenarios, this could lead to over- or under-prediction of certain percentiles. The estimation error is expected due to the reduced information content in variance-only data.



## Best Practices

So to recap, here are some best practices for variance-based (but also covariance-based) modeling with `admr`:

1. **Data Preparation**:
   - Always check your data for missing values and outliers
   - Ensure time points are consistent across subjects
   - Consider the impact of dosing events on your analysis

2. **Model Specification**:
   - Start with a simple model and gradually add complexity
   - Use meaningful initial values for parameters
   - Consider parameter transformations for better estimation

3. **Model Fitting**:
   - Use multiple chains to improve optimization
   - Monitor convergence carefully
   - Check parameter estimates for biological plausibility

4. **Diagnostics**:
   - Always examine convergence plots
   - Validate model predictions against observed data


For more information, see the package documentation and other vignettes.
