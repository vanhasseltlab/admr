---
title: "Get started with admr"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Get started with admr}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  markdown: 
    wrap: sentence
---

# Introduction to Aggregate Data Modeling with `admr`

This vignette demonstrates how to use the `admr` package for aggregate data modeling in pharmacometrics. Aggregate data modeling is particularly useful when individual-level data is not available, but summary statistics (mean and covariance) of the data are known.

## Overview

The `admr` package provides tools for:
- Converting individual-level data to aggregate form
- Fitting models to aggregate data using maximum likelihood estimation
- Simulating data from aggregate models
- Comparing different implementations of aggregate data modeling

## Required Packages

```{r setup, message = FALSE, warning = FALSE}
library(admr)
library(rxode2)
library(nlmixr2)
library(dplyr)
library(tidyr)
library(mnorm)
```

## The Examplomycin Dataset

We'll use the `examplomycin` dataset, which contains simulated concentration-time data for a fictional drug. The dataset includes:
- 500 subjects
- 9 time points per subject
- A two-compartment model with first-order absorption
- Random effects on all parameters
- Proportional residual error

```{r, cache=TRUE}
head(examplomycin)
```

## Converting to Aggregate Data Format

The `admr` package works with data in aggregate form (mean and covariance). We'll convert the individual-level data to this format:

```{r, cache=TRUE}
examplomycin_wide <- examplomycin %>%
  filter(EVID != 101) %>%  # Remove dosing events
  dplyr::select(ID, TIME, DV) %>%  # Select relevant columns
  pivot_wider(names_from = TIME, values_from = DV) %>%  # Convert to wide format
  dplyr::select(-c(1))  # Remove ID column

examplomycin_aggregated <- examplomycin_wide %>%
  admr::meancov()  # Compute mean and covariance

head(examplomycin_aggregated)
```

## Defining the Pharmacokinetic Model

We'll define a two-compartment model with first-order absorption using `RxODE`. The model includes:
- A depot compartment for absorption
- A central compartment for distribution
- A peripheral compartment for tissue distribution
- First-order elimination from the central compartment

```{r, message = FALSE, warning = FALSE}
rxModel <- RxODE({
  # Parameters
  ke = cl / v1             # Elimination rate constant
  k12 = q / v1             # Rate constant for central to peripheral transfer
  k21 = q / v2             # Rate constant for peripheral to central transfer
  
  # Differential equations for drug amount in compartments
  d/dt(depot)    = -ka * depot
  d/dt(central)  = ka * depot - ke * central - k12 * central + k21 * peripheral
  d/dt(peripheral) = k12 * central - k21 * peripheral
  
  # Concentration in the central compartment
  cp = central / v1
})
```

Alternatively, we can use the solved model approach with `linCmt`:

```{r, message = FALSE, warning = FALSE}
rxModel <- RxODE({
  cp = linCmt(    # Solved one- or two-compartment model
    cl,           # Clearance
    v1,           # Volume of the central compartment
    v2,           # Volume of the peripheral compartment
    q,            # Inter-compartmental clearance
    ka            # Absorption rate constant
  )
})
```

## Creating the Prediction Function

The prediction function is crucial for the `admr` package. It:
- Constructs the event table for dosing and sampling
- Solves the RxODE model
- Returns predicted concentrations in the required format

```{r, cache=TRUE}
predder <- function(time, theta_i, dose = 100) {
    n_individuals <- nrow(theta_i)
    
    if (is.null(n_individuals)) {
      n_individuals <- 1
    }

    # Create the event table for dosing and sampling
    ev <- eventTable(amount.units="mg", time.units="hours")
    ev$add.dosing(dose = dose, nbr.doses = 1, start.time = 0)
    ev$add.sampling(time)
    
    # Solve the RxODE model
    out <- rxSolve(rxModel, params = theta_i, events = ev, cores = 0)
    
    # Format output as matrix
    cp_matrix <- matrix(out$cp, nrow = n_individuals, ncol = length(time), 
                        byrow = TRUE)
    
    return(cp_matrix)
}
```

## Setting Up Model Options

The `genopts` function creates an options object that controls the model fitting process:

```{r, cache=TRUE}
opts <- genopts(
  time = c(.1, .25, .5, 1, 2, 3, 5, 8, 12),  # Observation times
  p = list(
    beta = c(cl = 5, v1 = 10, v2 = 30, q = 10, ka = 1),  # Population parameters
    Omega = omegas(.09, 0, 5),  # Random effects covariance matrix
    Sigma_prop = 0.04  # Proportional error variance
  ),
  nsim = 2500,  # Number of Monte Carlo samples
  n = 500,  # Number of individuals
  fo_appr = FALSE,  # Disable first-order approximation
  omega_expansion = 1.2,  # Omega expansion factor
  f = predder  # Prediction function
)
```

## Fitting the Model

The `fitIRMC` function fits the model to the aggregate data using the Iterative Reweighting algorithm:

```{r, cache=TRUE}
fit.admr <- admr::fitIRMC(
  opts,  # Model options
  examplomycin_aggregated,  # Aggregate data
  chains = 3  # Number of parallel chains
)
```

## Examining Results

The `print` method provides a summary of the model fit:

```{r}
print(fit.admr)
```

The `plot` method visualizes the convergence of the model fit:

```{r}
plot(fit.admr)
```

## Conclusion

This vignette demonstrates the basic workflow for aggregate data modeling with `admr`. The package provides a flexible framework for:
- Converting individual-level data to aggregate form
- Defining complex pharmacokinetic models
- Fitting models to aggregate data
- Assessing model convergence and parameter estimates

For more advanced usage, see the package documentation and other vignettes.
