---
title: "Get started with admr"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Get started with admr}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  markdown: 
    wrap: sentence
---

# Introduction to Aggregate Data Modeling with `admr`

This vignette provides a comprehensive introduction to using the `admr` package for aggregate data modeling in pharmacometrics. We'll cover the basic concepts, data preparation, model specification, and advanced features.

## What is Aggregate Data Modeling?

Aggregate data modeling is a powerful approach in pharmacometrics that allows you to work with summary-level data instead of individual-level observations. This is particularly useful when:

- Individual-level data is not available (e.g., from published literature)
- You need to combine data from multiple studies
- You want to perform meta-analyses
- You're working with simulated data and want to reduce computational burden

The `admr` package implements the Iterative Reweighting Monte Carlo (IRMC) algorithm, which efficiently fits models to aggregate data by iteratively updating parameter estimates using weighted importance sampling.

## Required Packages

```{r setup, message = FALSE, warning = FALSE}
library(admr)
library(rxode2)
library(nlmixr2)
library(dplyr)
library(tidyr)
library(mnorm)
library(ggplot2)  # For visualization
```

## Understanding the Data Format

The `admr` package works with two types of data formats:

1. **Raw Data**: Individual-level observations in a wide or long format
2. **Aggregate Data**: Summary statistics (mean and covariance) computed from raw data

Let's look at the examplomycin dataset, which we'll use throughout this vignette:

```{r, cache=TRUE}
# Load the dataset
data(examplomycin)
head(examplomycin)

# Basic dataset information
cat("Number of subjects:", length(unique(examplomycin$ID)), "\n")
cat("Number of time points:", length(unique(examplomycin$TIME)), "\n")
cat("Time points:", paste(sort(unique(examplomycin$TIME)), collapse = ", "), "\n")
```

## Data Preparation

### Converting Raw Data to Aggregate Format

The first step is to convert your raw data into aggregate format. Here's how to do it:

```{r, cache=TRUE}
# Convert to wide format
examplomycin_wide <- examplomycin %>%
  filter(EVID != 101) %>%  # Remove dosing events
  dplyr::select(ID, TIME, DV) %>%  # Select relevant columns
  pivot_wider(names_from = TIME, values_from = DV) %>%  # Convert to wide format
  dplyr::select(-c(1))  # Remove ID column

# Create aggregated data
examplomycin_aggregated <- examplomycin_wide %>%
  admr::meancov()  # Compute mean and covariance

# View the structure of aggregated data
str(examplomycin_aggregated)
```

### Visualizing the Data

Before fitting the model, it's helpful to visualize the data:

```{r, cache=TRUE}
# Create a concentration-time plot
ggplot(examplomycin, aes(x = TIME, y = DV)) +
  geom_point(alpha = 0.5) +
  labs(
    title = "Concentration-Time Profile",
    x = "Time (hours)",
    y = "Concentration (mg/L)"
  ) +
  theme_minimal()



```

## Model Specification

### Defining the Pharmacokinetic Model

We'll use a two-compartment model with first-order absorption. There are two ways to specify this:

1. Using differential equations:
```{r, message = FALSE, warning = FALSE}
rxModel <- RxODE({
  # Parameters
  ke = cl / v1             # Elimination rate constant
  k12 = q / v1             # Rate constant for central to peripheral transfer
  k21 = q / v2             # Rate constant for peripheral to central transfer
  
  # Differential equations
  d/dt(depot)    = -ka * depot
  d/dt(central)  = ka * depot - ke * central - k12 * central + k21 * peripheral
  d/dt(peripheral) = k12 * central - k21 * peripheral
  
  # Concentration in central compartment
  cp = central / v1
})
```

2. Using the solved model approach (simpler):
```{r, message = FALSE, warning = FALSE}
# Define RxODE model
rxModel <- function(){
  model({
    cp = linCmt(
      cl,           # Clearance
      v1,           # Volume of central compartment
      v2,           # Volume of peripheral compartment
      q,            # Inter-compartmental clearance
      ka            # Absorption rate constant
    )})
}

rxModel <- rxode2(rxModel)
rxModel <- rxModel$simulationModel
```

### Creating the Prediction Function

The prediction function is crucial for the `admr` package. It:
- Constructs the event table for dosing and sampling
- Solves the RxODE model
- Returns predicted concentrations in the required format

```{r, cache=TRUE}
predder <- function(time, theta_i, dose = 100) {
    n_individuals <- nrow(theta_i)
    
    if (is.null(n_individuals)) {
      n_individuals <- 1
    }

    # Create event table
    ev <- eventTable(amount.units="mg", time.units="hours")
    ev$add.dosing(dose = dose, nbr.doses = 1, start.time = 0)
    ev$add.sampling(time)
    
    # Solve model
    out <- rxSolve(rxModel, params = theta_i, events = ev, cores = 0)
    
    # Format output
    cp_matrix <- matrix(out$cp, nrow = n_individuals, ncol = length(time), 
                        byrow = TRUE)
    
    return(cp_matrix)
}
```

## Model Fitting

### Setting Up Model Options

The `genopts` function creates an options object that controls the model fitting process:

```{r, cache=TRUE}
opts <- genopts(
  time = c(.1, .25, .5, 1, 2, 3, 5, 8, 12),  # Observation times
  p = list(
    beta = c(cl = 5, v1 = 10, v2 = 30, q = 10, ka = 1),  # Population parameters
    Omega = matrix(c(0.09, 0, 0, 0, 0,
                    0, 0.09, 0, 0, 0,
                    0, 0, 0.09, 0, 0,
                    0, 0, 0, 0.09, 0,
                    0, 0, 0, 0, 0.09), nrow = 5, ncol = 5),  # Random effects
    Sigma_prop = 0.04  # Proportional error
  ),
  nsim = 10000,  # Number of Monte Carlo samples
  n = 500,      # Number of individuals
  fo_appr = FALSE,  # Disable first-order approximation
  omega_expansion = 1,  # Omega expansion factor
  f = predder    # Prediction function
)
```

### Fitting the Model

The `fitIRMC` function fits the model using the IRMC algorithm:

```{r, cache=TRUE}
fit.admrMC <- admr::fitMC(
  opts = opts,
  obs = examplomycin_aggregated,
  maxiter = 2000  # Maximum iterations
)


fit.admr <- admr::fitIRMC(
  opts = opts,
  obs = examplomycin_aggregated,
  chains = 1,  # Number of parallel chains
  maxiter = 200  # Maximum iterations
)
```

## Model Diagnostics

### Basic Diagnostics

The `print` method provides a summary of the model fit:

```{r}
print(fit.admr)
```


### Convergence Assessment

The `plot` method visualizes the convergence of the model fit:

```{r}
plot(fit.admr)
```

### Parameter Estimates

Let's examine the parameter estimates and their uncertainty:

```{r}
# Extract parameter estimates
params <- fit.admr$transformed_params
cat("Final parameter estimates:\n")
print(params)

# Extract covariance matrix
cov_matrix <- fit.admr$covariance_matrix
cat("\nParameter covariance matrix:\n")
print(cov_matrix)
```

## Best Practices

1. **Data Preparation**:
   - Always check your data for missing values and outliers
   - Ensure time points are consistent across subjects
   - Consider the impact of dosing events on your analysis

2. **Model Specification**:
   - Start with a simple model and gradually add complexity
   - Use meaningful initial values for parameters
   - Consider parameter transformations for better estimation

3. **Model Fitting**:
   - Use multiple chains to improve optimization
   - Monitor convergence carefully
   - Check parameter estimates for biological plausibility

4. **Diagnostics**:
   - Always examine convergence plots
   - Validate model predictions against observed data

## Next Steps

After mastering the basics, you might want to explore:

1. **Advanced modelling**:
   - Adjusting Monte Carlo sample size
   - Residual analysis
   - Parameter sensitivity analysis
   - Model comparison

For more information, see the package documentation and other vignettes.
