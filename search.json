[{"path":"https://hiddevandebeek.github.io/admr/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2024 H. van de Beek Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://hiddevandebeek.github.io/admr/articles/admr.html","id":"introduction-to-aggregate-data-modeling-with-admr","dir":"Articles","previous_headings":"","what":"Introduction to Aggregate Data Modeling with admr","title":"Get started with admr","text":"vignette provides comprehensive introduction using admr package aggregate data modeling pharmacometrics. ’ll cover basic concepts, data preparation, model specification, advanced features.","code":""},{"path":"https://hiddevandebeek.github.io/admr/articles/admr.html","id":"what-is-aggregate-data-modeling","dir":"Articles","previous_headings":"Introduction to Aggregate Data Modeling with admr","what":"What is Aggregate Data Modeling?","title":"Get started with admr","text":"Aggregate data modeling powerful approach pharmacometrics allows work summary-level data instead individual-level observations. particularly useful : Individual-level data available (e.g., published literature) need combine data multiple studies want perform meta-analyses ’re working simulated data want reduce computational burden admr package implements Iterative Reweighting Monte Carlo (IRMC) algorithm, efficiently fits models aggregate data iteratively updating parameter estimates using weighted importance sampling.","code":""},{"path":"https://hiddevandebeek.github.io/admr/articles/admr.html","id":"required-packages","dir":"Articles","previous_headings":"Introduction to Aggregate Data Modeling with admr","what":"Required Packages","title":"Get started with admr","text":"","code":"library(admr) library(rxode2) library(nlmixr2) library(dplyr) library(tidyr) library(mnorm) library(ggplot2)  # For visualization"},{"path":"https://hiddevandebeek.github.io/admr/articles/admr.html","id":"understanding-the-data-format","dir":"Articles","previous_headings":"Introduction to Aggregate Data Modeling with admr","what":"Understanding the Data Format","title":"Get started with admr","text":"admr package works two types data formats: Raw Data: Individual-level observations wide long format Aggregate Data: Summary statistics (mean covariance) computed raw data Let’s look examplomycin dataset, ’ll use throughout vignette:","code":"# Load the dataset data(examplomycin) head(examplomycin) ##    ID TIME    DV AMT EVID CMT ## 1 460 0.00 0.000 100  101   1 ## 2 460 0.10 0.752   0    0   2 ## 3 460 0.25 1.932   0    0   2 ## 4 460 0.50 3.694   0    0   2 ## 5 460 1.00 3.479   0    0   2 ## 6 460 2.00 4.003   0    0   2 # Basic dataset information cat(\"Number of subjects:\", length(unique(examplomycin$ID)), \"\\n\") ## Number of subjects: 500 cat(\"Number of time points:\", length(unique(examplomycin$TIME)), \"\\n\") ## Number of time points: 10 cat(\"Time points:\", paste(sort(unique(examplomycin$TIME)), collapse = \", \"), \"\\n\") ## Time points: 0, 0.1, 0.25, 0.5, 1, 2, 3, 5, 8, 12"},{"path":[]},{"path":"https://hiddevandebeek.github.io/admr/articles/admr.html","id":"converting-raw-data-to-aggregate-format","dir":"Articles","previous_headings":"Introduction to Aggregate Data Modeling with admr > Data Preparation","what":"Converting Raw Data to Aggregate Format","title":"Get started with admr","text":"first step convert raw data aggregate format. ’s :","code":"# Convert to wide format examplomycin_wide <- examplomycin %>%   filter(EVID != 101) %>%  # Remove dosing events   dplyr::select(ID, TIME, DV) %>%  # Select relevant columns   pivot_wider(names_from = TIME, values_from = DV) %>%  # Convert to wide format   dplyr::select(-c(1))  # Remove ID column  # Create aggregated data examplomycin_aggregated <- examplomycin_wide %>%   admr::meancov()  # Compute mean and covariance  # View the structure of aggregated data str(examplomycin_aggregated) ## List of 2 ##  $ E: Named num [1:9] 0.966 1.939 2.788 3.025 2.258 ... ##   ..- attr(*, \"names\")= chr [1:9] \"0.1\" \"0.25\" \"0.5\" \"1\" ... ##  $ V: num [1:9, 1:9] 0.2103 0.3078 0.3486 0.2026 0.0224 ... ##   ..- attr(*, \"dimnames\")=List of 2 ##   .. ..$ : chr [1:9] \"0.1\" \"0.25\" \"0.5\" \"1\" ... ##   .. ..$ : chr [1:9] \"0.1\" \"0.25\" \"0.5\" \"1\" ..."},{"path":"https://hiddevandebeek.github.io/admr/articles/admr.html","id":"visualizing-the-data","dir":"Articles","previous_headings":"Introduction to Aggregate Data Modeling with admr > Data Preparation","what":"Visualizing the Data","title":"Get started with admr","text":"fitting model, ’s helpful visualize data:","code":"# Create a concentration-time plot ggplot(examplomycin, aes(x = TIME, y = DV)) +   geom_point(alpha = 0.5) +   geom_smooth(method = \"loess\", se = TRUE) +   labs(     title = \"Concentration-Time Profile\",     x = \"Time (hours)\",     y = \"Concentration (mg/L)\"   ) +   theme_minimal() ## `geom_smooth()` using formula = 'y ~ x'"},{"path":[]},{"path":"https://hiddevandebeek.github.io/admr/articles/admr.html","id":"defining-the-pharmacokinetic-model","dir":"Articles","previous_headings":"Introduction to Aggregate Data Modeling with admr > Model Specification","what":"Defining the Pharmacokinetic Model","title":"Get started with admr","text":"’ll use two-compartment model first-order absorption. two ways specify : Using differential equations: Using solved model approach (simpler):","code":"rxModel <- RxODE({   # Parameters   ke = cl / v1             # Elimination rate constant   k12 = q / v1             # Rate constant for central to peripheral transfer   k21 = q / v2             # Rate constant for peripheral to central transfer      # Differential equations   d/dt(depot)    = -ka * depot   d/dt(central)  = ka * depot - ke * central - k12 * central + k21 * peripheral   d/dt(peripheral) = k12 * central - k21 * peripheral      # Concentration in central compartment   cp = central / v1 }) rxModel <- RxODE({   cp = linCmt(     cl,           # Clearance     v1,           # Volume of central compartment     v2,           # Volume of peripheral compartment     q,            # Inter-compartmental clearance     ka            # Absorption rate constant   ) })"},{"path":"https://hiddevandebeek.github.io/admr/articles/admr.html","id":"creating-the-prediction-function","dir":"Articles","previous_headings":"Introduction to Aggregate Data Modeling with admr > Model Specification","what":"Creating the Prediction Function","title":"Get started with admr","text":"prediction function crucial admr package. : - Constructs event table dosing sampling - Solves RxODE model - Returns predicted concentrations required format","code":"predder <- function(time, theta_i, dose = 100) {     n_individuals <- nrow(theta_i)          if (is.null(n_individuals)) {       n_individuals <- 1     }      # Create event table     ev <- eventTable(amount.units=\"mg\", time.units=\"hours\")     ev$add.dosing(dose = dose, nbr.doses = 1, start.time = 0)     ev$add.sampling(time)          # Solve model     out <- rxSolve(rxModel, params = theta_i, events = ev, cores = 0)          # Format output     cp_matrix <- matrix(out$cp, nrow = n_individuals, ncol = length(time),                          byrow = TRUE)          return(cp_matrix) }"},{"path":[]},{"path":"https://hiddevandebeek.github.io/admr/articles/admr.html","id":"setting-up-model-options","dir":"Articles","previous_headings":"Introduction to Aggregate Data Modeling with admr > Model Fitting","what":"Setting Up Model Options","title":"Get started with admr","text":"genopts function creates options object controls model fitting process:","code":"opts <- genopts(   time = c(.1, .25, .5, 1, 2, 3, 5, 8, 12),  # Observation times   p = list(     beta = c(cl = 5, v1 = 10, v2 = 30, q = 10, ka = 1),  # Population parameters     Omega = matrix(c(0.09, 0, 0, 0, 0,                     0, 0.09, 0, 0, 0,                     0, 0, 0.09, 0, 0,                     0, 0, 0, 0.09, 0,                     0, 0, 0, 0, 0.09), nrow = 5, ncol = 5),  # Random effects     Sigma_prop = 0.04  # Proportional error   ),   nsim = 2500,  # Number of Monte Carlo samples   n = 500,      # Number of individuals   fo_appr = FALSE,  # Disable first-order approximation   omega_expansion = 1.2,  # Omega expansion factor   f = predder    # Prediction function )"},{"path":"https://hiddevandebeek.github.io/admr/articles/admr.html","id":"fitting-the-model","dir":"Articles","previous_headings":"Introduction to Aggregate Data Modeling with admr > Model Fitting","what":"Fitting the Model","title":"Get started with admr","text":"fitIRMC function fits model using IRMC algorithm:","code":"fit.admr <- admr::fitIRMC(   opts = opts,   obs = examplomycin_aggregated,   chains = 3,  # Number of parallel chains   maxiter = 100  # Maximum iterations ) ## Chain 1: ## Iter | NLL and Parameters (11 values) ## -------------------------------------------------------------------------------- ##    1: -1839.577    1.609    2.303    3.401    2.303    0.000   -2.408   -2.408   -2.408   -2.408   -2.408   -3.219 ##  ## ### Wide Search Phase ### ##    2: -1845.238    1.601    2.309    3.404    2.284    0.019   -2.280   -2.167   -2.334   -2.245   -2.439   -3.235 ##    3: -1845.283    1.601    2.308    3.405    2.285    0.019   -2.286   -2.207   -2.341   -2.264   -2.405   -3.235 ##    4: -1845.283    1.601    2.308    3.405    2.285    0.019   -2.286   -2.206   -2.341   -2.264   -2.405   -3.235 ##    5: -1845.283    1.601    2.308    3.405    2.285    0.019   -2.286   -2.205   -2.343   -2.264   -2.405   -3.235 ##    6: -1845.283    1.601    2.308    3.405    2.285    0.019   -2.286   -2.205   -2.343   -2.264   -2.405   -3.235 ##    7: -1845.283    1.601    2.308    3.405    2.285    0.019   -2.286   -2.205   -2.343   -2.264   -2.405   -3.235 ##    8: -1845.282    1.601    2.308    3.405    2.285    0.018   -2.286   -2.205   -2.343   -2.264   -2.406   -3.235 ##    9: -1845.282    1.601    2.308    3.405    2.285    0.018   -2.286   -2.204   -2.343   -2.264   -2.406   -3.235 ##   10: -1845.282    1.601    2.307    3.405    2.285    0.018   -2.286   -2.204   -2.343   -2.265   -2.406   -3.235 ##   11: -1845.282    1.601    2.308    3.405    2.285    0.018   -2.286   -2.204   -2.343   -2.264   -2.406   -3.235 ##   12: -1845.282    1.601    2.308    3.405    2.285    0.018   -2.286   -2.204   -2.343   -2.264   -2.406   -3.235 ## Phase Wide Search Phase converged at iteration 12. ##  ## ### Focussed Search Phase ### ##   13: -1845.280    1.601    2.307    3.405    2.285    0.018   -2.286   -2.201   -2.343   -2.265   -2.410   -3.235 ##   14: -1845.280    1.601    2.307    3.405    2.285    0.018   -2.286   -2.201   -2.343   -2.265   -2.410   -3.235 ##   15: -1845.280    1.601    2.307    3.405    2.285    0.018   -2.286   -2.201   -2.343   -2.265   -2.410   -3.235 ## Phase Focussed Search Phase converged at iteration 15. ##  ## ### Fine-Tuning Phase ### ##   16: -1845.280    1.601    2.307    3.405    2.285    0.018   -2.286   -2.201   -2.343   -2.265   -2.410   -3.235 ##   17: -1845.280    1.601    2.307    3.405    2.285    0.018   -2.286   -2.201   -2.343   -2.265   -2.410   -3.235 ##   18: -1845.280    1.601    2.307    3.405    2.285    0.018   -2.286   -2.201   -2.343   -2.265   -2.410   -3.235 ##   19: -1845.280    1.601    2.307    3.405    2.285    0.018   -2.286   -2.201   -2.343   -2.265   -2.410   -3.235 ## Phase Fine-Tuning Phase converged at iteration 19. ##  ## ### Precision Phase ### ##   20: -1845.280    1.601    2.307    3.405    2.285    0.018   -2.286   -2.201   -2.343   -2.265   -2.410   -3.235 ##   21: -1845.280    1.601    2.307    3.405    2.285    0.018   -2.286   -2.201   -2.343   -2.265   -2.410   -3.235 ##   22: -1845.280    1.601    2.307    3.405    2.285    0.018   -2.286   -2.201   -2.343   -2.265   -2.410   -3.235 ## Phase Precision Phase converged at iteration 22. ##  ## Chain 1 Complete: Final NLL = -1845.283, Time Elapsed = 8.94 seconds ##   ## Phase Wide Search Phase converged at iteration 6. ## Phase Focussed Search Phase converged at iteration 11. ## Phase Fine-Tuning Phase converged at iteration 13. ## Phase Precision Phase converged at iteration 14. ##  ## Chain 2 Complete: Final NLL = -1845.280, Time Elapsed = 5.59 seconds ##   ## Phase Wide Search Phase converged at iteration 12. ## Phase Focussed Search Phase converged at iteration 14. ## Phase Fine-Tuning Phase converged at iteration 18. ## Phase Precision Phase converged at iteration 21. ##  ## Chain 3 Complete: Final NLL = -1845.283, Time Elapsed = 9.51 seconds ##"},{"path":[]},{"path":"https://hiddevandebeek.github.io/admr/articles/admr.html","id":"basic-diagnostics","dir":"Articles","previous_headings":"Introduction to Aggregate Data Modeling with admr > Model Diagnostics","what":"Basic Diagnostics","title":"Get started with admr","text":"print method provides summary model fit:","code":"print(fit.admr) ## -- FitIRMC Summary -- ##  ## -- Objective Function and Information Criteria -- ##  Log-likelihood: -1845.2827 ##             AIC: 3701.57 ##             BIC: 3758.93 ## Condition#(Cov): 144.64 ## Condition#(Cor): 204.50 ##  ## -- Timing Information -- ##      Best Chain: 8.9405 seconds ##      All Chains: 24.0457 seconds ##      Covariance: 27.7027 seconds ##         Elapsed: 51.75 seconds ##  ## -- Population Parameters -- ## # A tibble: 6 × 6 ##   Parameter        Est.      SE  `%RSE` `Back-transformed(95%CI)` `BSV(CV%)` ##   <chr>           <dbl>   <dbl>   <dbl> <chr>                          <dbl> ## 1 cl             1.60    0.0153   0.954 4.96 (4.81, 5.11)               31.9 ## 2 v1             2.31    0.0842   3.65  10.05 (8.52, 11.85)             33.2 ## 3 v2             3.40    0.0394   1.16  30.11 (27.87, 32.53)            31.0 ## 4 q              2.28    0.0213   0.930 9.82 (9.42, 10.24)              32.2 ## 5 ka             0.0186  0.0794 427.    1.02 (0.87, 1.19)               30.0 ## 6 Residual Error 0.0394 NA       NA     0.0394                          NA   ##  ## -- Iteration Diagnostics -- ##  Iter | NLL and Parameters ## -------------------------------------------------------------------------------- ##    1: -1839.577 1.609 2.303 3.401 2.303 0.000 -2.408 -2.408 -2.408 -2.408 -2.408 -3.219 ##    2: -1845.238 1.601 2.309 3.404 2.284 0.019 -2.280 -2.167 -2.334 -2.245 -2.439 -3.235 ##    3: -1845.283 1.601 2.308 3.405 2.285 0.019 -2.286 -2.207 -2.341 -2.264 -2.405 -3.235 ##    4: -1845.283 1.601 2.308 3.405 2.285 0.019 -2.286 -2.206 -2.341 -2.264 -2.405 -3.235 ##    5: -1845.283 1.601 2.308 3.405 2.285 0.019 -2.286 -2.205 -2.343 -2.264 -2.405 -3.235 ##    ... (omitted iterations) ... ##   18: -1845.280 1.601 2.307 3.405 2.285 0.018 -2.286 -2.201 -2.343 -2.265 -2.410 -3.235 ##   19: -1845.280 1.601 2.307 3.405 2.285 0.018 -2.286 -2.201 -2.343 -2.265 -2.410 -3.235 ##   20: -1845.280 1.601 2.307 3.405 2.285 0.018 -2.286 -2.201 -2.343 -2.265 -2.410 -3.235 ##   21: -1845.280 1.601 2.307 3.405 2.285 0.018 -2.286 -2.201 -2.343 -2.265 -2.410 -3.235 ##   22: -1845.280 1.601 2.307 3.405 2.285 0.018 -2.286 -2.201 -2.343 -2.265 -2.410 -3.235"},{"path":"https://hiddevandebeek.github.io/admr/articles/admr.html","id":"convergence-assessment","dir":"Articles","previous_headings":"Introduction to Aggregate Data Modeling with admr > Model Diagnostics","what":"Convergence Assessment","title":"Get started with admr","text":"plot method visualizes convergence model fit:","code":"plot(fit.admr)"},{"path":"https://hiddevandebeek.github.io/admr/articles/admr.html","id":"parameter-estimates","dir":"Articles","previous_headings":"Introduction to Aggregate Data Modeling with admr > Model Diagnostics","what":"Parameter Estimates","title":"Get started with admr","text":"Let’s examine parameter estimates uncertainty:","code":"# Extract parameter estimates params <- fit.admr$final_params cat(\"Final parameter estimates:\\n\") ## Final parameter estimates: print(params) ##  [1]  1.60064075  2.30769783  3.40493589  2.28483529  0.01861234 -2.28621198 ##  [7] -2.20540525 -2.34292518 -2.26366946 -2.40495060 -3.23507323 # Extract covariance matrix cov_matrix <- fit.admr$covariance_matrix cat(\"\\nParameter covariance matrix:\\n\") ##  ## Parameter covariance matrix: print(cov_matrix) ##               [,1]          [,2]          [,3]          [,4]          [,5] ## [1,]  2.333496e-04  0.0003509607 -0.0003250435  5.942544e-05  0.0003432800 ## [2,]  3.509607e-04  0.0070878485 -0.0025906724  3.227487e-04  0.0065754632 ## [3,] -3.250435e-04 -0.0025906724  0.0015522901 -1.638170e-04 -0.0024696581 ## [4,]  5.942544e-05  0.0003227487 -0.0001638170  4.518169e-04  0.0003742059 ## [5,]  3.432800e-04  0.0065754632 -0.0024696581  3.742059e-04  0.0063091299"},{"path":[]},{"path":"https://hiddevandebeek.github.io/admr/articles/admr.html","id":"multiple-chains","dir":"Articles","previous_headings":"Introduction to Aggregate Data Modeling with admr > Advanced Features","what":"Multiple Chains","title":"Get started with admr","text":"fitIRMC function supports multiple chains improve optimization:","code":"# Run with multiple chains result <- fitIRMC(   opts = opts,   obs = examplomycin_aggregated,   chains = 3,  # Number of chains   pertubation = 0.1  # Perturbation factor )"},{"path":"https://hiddevandebeek.github.io/admr/articles/admr.html","id":"phase-based-optimization","dir":"Articles","previous_headings":"Introduction to Aggregate Data Modeling with admr > Advanced Features","what":"Phase-Based Optimization","title":"Get started with admr","text":"can customize optimization phases:","code":"# Custom phase fractions result <- fitIRMC(   opts = opts,   obs = examplomycin_aggregated,   phase_fractions = c(0.3, 0.3, 0.2, 0.2)  # Custom phase distribution )"},{"path":"https://hiddevandebeek.github.io/admr/articles/admr.html","id":"best-practices","dir":"Articles","previous_headings":"Introduction to Aggregate Data Modeling with admr","what":"Best Practices","title":"Get started with admr","text":"Always check data missing values outliers Ensure time points consistent across subjects Consider impact dosing events analysis Start simple model gradually add complexity Use meaningful initial values parameters Consider parameter transformations better estimation Use multiple chains improve optimization Monitor convergence carefully Check parameter estimates biological plausibility Always examine convergence plots Check parameter correlations Validate model predictions observed data","code":""},{"path":"https://hiddevandebeek.github.io/admr/articles/admr.html","id":"next-steps","dir":"Articles","previous_headings":"Introduction to Aggregate Data Modeling with admr","what":"Next Steps","title":"Get started with admr","text":"mastering basics, might want explore: Custom error models Parameter transformations Complex dosing regimens Adjusting Monte Carlo sample size Using first-order approximations Parallel computing options Residual analysis Parameter sensitivity analysis Model comparison information, see package documentation vignettes.","code":""},{"path":"https://hiddevandebeek.github.io/admr/articles/examplomycin.html","id":"creating-the-examplomycin-dataset","dir":"Articles","previous_headings":"","what":"Creating the Examplomycin Dataset","title":"Examplomycin Dataset: A Pharmacokinetic Example","text":"vignette demonstrates create simulated pharmacokinetic dataset fictional drug called examplomycin. dataset designed showcase capabilities admr package aggregate data modeling.","code":""},{"path":"https://hiddevandebeek.github.io/admr/articles/examplomycin.html","id":"overview","dir":"Articles","previous_headings":"Creating the Examplomycin Dataset","what":"Overview","title":"Examplomycin Dataset: A Pharmacokinetic Example","text":"examplomycin dataset simulated pharmacokinetic study following characteristics: - 500 healthy subjects - Single oral dose 100 mg - 9 sampling time points per subject - Two-compartment model first-order absorption - Random effects parameters - Proportional residual error","code":""},{"path":"https://hiddevandebeek.github.io/admr/articles/examplomycin.html","id":"required-packages","dir":"Articles","previous_headings":"Creating the Examplomycin Dataset","what":"Required Packages","title":"Examplomycin Dataset: A Pharmacokinetic Example","text":"","code":"library(rxode2) library(MASS) library(ggplot2) library(nlmixr2) library(data.table) library(dplyr) library(ggplot2) library(usethis)"},{"path":"https://hiddevandebeek.github.io/admr/articles/examplomycin.html","id":"data-generation-function","dir":"Articles","previous_headings":"Creating the Examplomycin Dataset","what":"Data Generation Function","title":"Examplomycin Dataset: A Pharmacokinetic Example","text":"generate_data function creates examplomycin dataset following features: - Two-compartment model first-order absorption - Log-normal random effects parameters - Proportional residual error - Standardized sampling schedule - NLMIXR-compatible data format","code":"generate_data <- function(n, times, seed = 1) {   set.seed(seed)      # Define the pharmacokinetic model   mod <- RxODE({     # Parameters     ke = cl / v1             # Elimination rate constant     k12 = q / v1             # Rate constant for central to peripheral transfer     k21 = q / v2             # Rate constant for peripheral to central transfer          # Differential equations for drug amount in compartments     d/dt(depot)    = -ka * depot     d/dt(central)  = ka * depot - ke * central -        k12 * central +        k21 * peripheral     d/dt(peripheral) = k12 * central -        k21 * peripheral          # Concentration in the central compartment     cp = central / v1   })    # Population parameters   theta <- c(cl = 5, v1 = 10, v2 = 30, q = 10, ka = 1)    # Correlation matrix for random effects   omegaCor <- matrix(c(1,  0,  0,  0,  0,                        0,  1,  0,  0,  0,                        0,  0,  1,  0,  0,                        0,  0,  0,  1,  0,                        0,  0,  0,  0,  1),                       dimnames = list(NULL, c(\"eta.cl\", \"eta.v1\", \"eta.v2\", \"eta.q\",                                             \"eta.ka\")), nrow = 5)    # Standard deviations of random effects   iiv.sd <- c(0.3, 0.3, 0.3, 0.3, 0.3)    # Create covariance matrix   iiv <- iiv.sd %*% t(iiv.sd)   omega <- iiv * omegaCor    # Generate random effects   mv <- mvrnorm(n, rep(0, dim(omega)[1]), omega)    # Create individual parameters   params.all <-     data.table(       \"ID\" = seq(1:n),       \"cl\" = theta['cl'] * exp(mv[, 1]),       \"v1\" = theta['v1'] * exp(mv[, 2]),       \"v2\" = theta['v2'] * exp(mv[, 3]),       \"q\"  = theta['q']  * exp(mv[, 4]),       \"ka\" = theta['ka'] * exp(mv[, 5])     )    # Create event table   ev <- et() %>%     et(amt = 100) %>%  # Single dose     et(0) %>%  # Initial time point     et(times) %>%  # Sampling schedule     et(ID = seq(1, n)) %>%  # Subject IDs     as.data.frame()    # Solve the model   sim <- rxSolve(mod, events = ev, iCov = params.all, cores = 0, addCov = T) %>%     mutate(ID = as.integer(id), TIME = as.numeric(time)) %>%     dplyr::select(-c(id, time)) %>%     mutate(AMT = ifelse(TIME == 0, 100, 0)) %>%     mutate(EVID = ifelse(TIME == 0, 101, 0)) %>%     mutate(CMT = ifelse(TIME == 0, 1, 2))    # Add residual error   sim$rv <- rnorm(nrow(sim), 0, 0.2)   sim$DV <- round(sim$cp * (1 + sim$rv), 3)   sim <- merge(sim, params.all)    # Select final columns   dat <- sim %>%     dplyr::select(\"ID\", \"TIME\", \"DV\", \"AMT\", \"EVID\", \"CMT\")    return(dat) }"},{"path":"https://hiddevandebeek.github.io/admr/articles/examplomycin.html","id":"generating-the-dataset","dir":"Articles","previous_headings":"Creating the Examplomycin Dataset","what":"Generating the Dataset","title":"Examplomycin Dataset: A Pharmacokinetic Example","text":"’ll generate examplomycin dataset : - 500 subjects - 9 time points (0.1, 0.25, 0.5, 1, 2, 3, 5, 8, 12 hours) - Random seed reproducibility","code":"examplomycin <- generate_data(   n = 500,  # Number of subjects   times = c(.1, .25, .5, 1, 2, 3, 5, 8, 12),  # Sampling times   seed = 1  # Random seed ) head(examplomycin) ##    ID TIME    DV AMT EVID CMT ## 1 460 0.00 0.000 100  101   1 ## 2 460 0.10 0.752   0    0   2 ## 3 460 0.25 1.932   0    0   2 ## 4 460 0.50 3.694   0    0   2 ## 5 460 1.00 3.479   0    0   2 ## 6 460 2.00 4.003   0    0   2"},{"path":"https://hiddevandebeek.github.io/admr/articles/examplomycin.html","id":"saving-the-dataset","dir":"Articles","previous_headings":"Creating the Examplomycin Dataset","what":"Saving the Dataset","title":"Examplomycin Dataset: A Pharmacokinetic Example","text":"dataset saved package data object use vignettes examples:","code":""},{"path":"https://hiddevandebeek.github.io/admr/articles/examplomycin.html","id":"visualizing-the-dataset","dir":"Articles","previous_headings":"Creating the Examplomycin Dataset","what":"Visualizing the Dataset","title":"Examplomycin Dataset: A Pharmacokinetic Example","text":"’ll create concentration-time plot visualize simulated data:","code":"# Create concentration-time plot ggplot(examplomycin, aes(x = TIME, y = DV, color = factor(ID))) +   geom_line(alpha = 0.7) +    # Connect points with lines   geom_point(size = 2, alpha = 0.8) +  # Add observation points   scale_color_viridis_d(name = \"Subject ID\") +  # Color by subject   labs(     title = \"Concentration-Time Profile\",     x = \"Time (hours)\",     y = \"Observed Concentration (DV)\"   ) +   theme_minimal() +   theme(legend.position = \"none\")  # Hide legend for clarity"},{"path":"https://hiddevandebeek.github.io/admr/articles/examplomycin.html","id":"dataset-structure","dir":"Articles","previous_headings":"Creating the Examplomycin Dataset","what":"Dataset Structure","title":"Examplomycin Dataset: A Pharmacokinetic Example","text":"examplomycin dataset contains following columns: - ID: Subject identifier - TIME: Observation time (hours) - DV: Observed concentration - AMT: Dose amount (100 mg NA) - EVID: Event type (101 dose, 0 observation) - CMT: Compartment number (1 depot, 2 central) dataset serves realistic example demonstrating aggregate data modeling techniques admr package.","code":""},{"path":"https://hiddevandebeek.github.io/admr/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"H. van de Beek. Maintainer.","code":""},{"path":"https://hiddevandebeek.github.io/admr/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"van de Beek H, Välitalo P, Zwep L, van Hasselt J (2025). admr: Aggregate data modelling R. R package version 0.1.0, https://hiddevandebeek.github.io/admr/, https://hiddevandebeek.github.io/admr.","code":"@Manual{,   title = {admr: Aggregate data modelling in R},   author = {H. {van de Beek} and P.A.J. Välitalo and L.B. Zwep and J.G.C {van Hasselt}},   year = {2025},   note = {R package version 0.1.0, https://hiddevandebeek.github.io/admr/},   url = {https://hiddevandebeek.github.io/admr}, }"},{"path":"https://hiddevandebeek.github.io/admr/index.html","id":"admr-aggregate-data-modeling-in-r","dir":"","previous_headings":"","what":"Aggregate data modelling in R","title":"Aggregate data modelling in R","text":"admr (Aggregate Data Modeling R) open-source R package designed facilitate pharmacometric modeling using summary-level data. enables users work aggregate data, mean observations variance-covariance matrices, fit pharmacokinetic pharmacodynamic (PK/PD) models efficiently. package implements newly developed Expectation-Maximization (EM) algorithm enhance computational performance provides tools advanced modeling applications.","code":""},{"path":"https://hiddevandebeek.github.io/admr/index.html","id":"overview","dir":"","previous_headings":"","what":"Overview","title":"Aggregate data modelling in R","text":"admr package provides comprehensive framework aggregate data modeling pharmacometrics, offering several key advantages: Efficient Parameter Estimation: Uses Iterative Reweighting Monte Carlo (IRMC) algorithm robust fast parameter estimation. Flexible Data Integration: Works individual-level aggregate data, making ideal meta-analyses literature-based modeling. Advanced Modeling Features: Supports complex PK/PD models various error structures parameter transformations. Comprehensive Diagnostics: Built-tools model assessment, convergence checking, parameter stability analysis.","code":""},{"path":"https://hiddevandebeek.github.io/admr/index.html","id":"key-features","dir":"","previous_headings":"","what":"Key Features","title":"Aggregate data modelling in R","text":"Efficient Model Fitting: Uses iterative reweighted Monte Carlo (IRMC) robust parameter estimation, improving speed scalability compared traditional Monte Carlo methods. Flexible Data Formats: Supports raw aggregate data formats, allowing integration summary-level data diverse sources, including published literature simulated models. Comprehensive Diagnostics: Built-tools model assessment, convergence checking, parameter stability analysis. Meta-Analysis Support: Facilitates model-based meta-analyses enabling combination summary data across studies. R Integration: Fully compatible R, leveraging popular pharmacometric modeling libraries like rxode2. Open-Source: Developed accessibility ease use pharmacometric community.","code":""},{"path":"https://hiddevandebeek.github.io/admr/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Aggregate data modelling in R","text":"R package. R required, RStudio recommended. can install development version admr GitHub :","code":"# install.packages(\"devtools\") devtools::install_github(\"hiddevandebeek/admr\")"},{"path":"https://hiddevandebeek.github.io/admr/index.html","id":"quick-start","dir":"","previous_headings":"","what":"Quick Start","title":"Aggregate data modelling in R","text":"complete example use admr fit pharmacokinetic model aggregate data:","code":"# Load required libraries library(admr) library(rxode2) #> Warning: package 'rxode2' was built under R version 4.4.2 #> rxode2 3.0.4 using 7 threads (see ?getRxThreads) #>   no cache: create with `rxCreateCache()` library(nlmixr2) #> Loading required package: nlmixr2data library(dplyr) #>  #> Attaching package: 'dplyr' #> The following objects are masked from 'package:stats': #>  #>     filter, lag #> The following objects are masked from 'package:base': #>  #>     intersect, setdiff, setequal, union library(tidyr) library(mnorm)  # Load and prepare data data(examplomycin) examplomycin_wide <- examplomycin %>%   filter(EVID != 101) %>%   dplyr::select(ID, TIME, DV) %>%   pivot_wider(names_from = TIME, values_from = DV) %>%   dplyr::select(-c(1))  # Create aggregated data examplomycin_aggregated <- examplomycin_wide %>%   admr::meancov()  # Define RxODE model rxModel <- RxODE({   cp = linCmt(     cl,           # Clearance     v1,           # Volume of the central compartment     v2,           # Volume of the peripheral compartment     q,            # Inter-compartmental clearance     ka            # Absorption rate constant   ) })  # Define prediction function predder <- function(time, theta_i, dose = 100) {   n_individuals <- nrow(theta_i)   if (is.null(n_individuals)) n_individuals <- 1      ev <- eventTable(amount.units=\"mg\", time.units=\"hours\")   ev$add.dosing(dose = dose, nbr.doses = 1, start.time = 0)   ev$add.sampling(time)      out <- rxSolve(rxModel, params = theta_i, events = ev, cores = 0)   cp_matrix <- matrix(out$cp, nrow = n_individuals, ncol = length(time),                       byrow = TRUE)   return(cp_matrix) }  # Create options opts <- genopts(   time = c(.1, .25, .5, 1, 2, 3, 5, 8, 12),   p = list(     beta = c(cl = 5, v1 = 10, v2 = 30, q = 10, ka = 1),     Omega = matrix(c(0.09, 0, 0, 0, 0,                     0, 0.09, 0, 0, 0,                     0, 0, 0.09, 0, 0,                     0, 0, 0, 0.09, 0,                     0, 0, 0, 0, 0.09), nrow = 5, ncol = 5),     Sigma_prop = 0.04   ),   nsim = 2500,   n = 500,   fo_appr = FALSE,   omega_expansion = 1.2,   f = predder )  # Fit model to data result <- fitIRMC(opts = opts, obs = examplomycin_aggregated) #> Chain 1: #> Iter | NLL and Parameters (11 values) #> -------------------------------------------------------------------------------- #>    1: -1839.577    1.609    2.303    3.401    2.303    0.000   -2.408   -2.408   -2.408   -2.408   -2.408   -3.219 #>  #> ### Wide Search Phase ### #>    2: -1845.238    1.601    2.309    3.404    2.284    0.020   -2.279   -2.167   -2.333   -2.245   -2.439   -3.235 #>    3: -1845.277    1.600    2.307    3.406    2.285    0.017   -2.287   -2.195   -2.342   -2.267   -2.416   -3.235 #>    4: -1845.277    1.600    2.306    3.406    2.285    0.017   -2.287   -2.195   -2.342   -2.266   -2.416   -3.235 #>    5: -1845.277    1.600    2.306    3.406    2.285    0.017   -2.287   -2.195   -2.342   -2.266   -2.416   -3.235 #> Phase Wide Search Phase converged at iteration 5. #>  #> ### Focussed Search Phase ### #>    6: -1845.280    1.601    2.307    3.405    2.285    0.018   -2.286   -2.200   -2.343   -2.264   -2.411   -3.235 #>    7: -1845.280    1.601    2.307    3.405    2.285    0.018   -2.286   -2.200   -2.343   -2.264   -2.411   -3.235 #>    8: -1845.280    1.601    2.307    3.405    2.285    0.018   -2.286   -2.200   -2.343   -2.264   -2.411   -3.235 #>    9: -1845.280    1.601    2.307    3.405    2.285    0.018   -2.286   -2.200   -2.343   -2.264   -2.411   -3.235 #>   10: -1845.280    1.601    2.307    3.405    2.285    0.018   -2.286   -2.200   -2.343   -2.264   -2.411   -3.235 #>   11: -1845.280    1.601    2.307    3.405    2.285    0.018   -2.286   -2.200   -2.343   -2.264   -2.411   -3.235 #> Phase Focussed Search Phase converged at iteration 11. #>  #> ### Fine-Tuning Phase ### #>   12: -1845.280    1.601    2.307    3.405    2.285    0.018   -2.286   -2.200   -2.343   -2.264   -2.411   -3.235 #> Phase Fine-Tuning Phase converged at iteration 12. #>  #> ### Precision Phase ### #>   13: -1845.280    1.601    2.307    3.405    2.285    0.018   -2.286   -2.201   -2.343   -2.265   -2.410   -3.235 #>   14: -1845.280    1.601    2.307    3.405    2.285    0.018   -2.286   -2.201   -2.343   -2.265   -2.410   -3.235 #> Phase Precision Phase converged at iteration 14. #>  #> Chain 1 Complete: Final NLL = -1845.280, Time Elapsed = 5.93 seconds #>  print(result) #> -- FitIRMC Summary -- #>  #> -- Objective Function and Information Criteria -- #>  Log-likelihood: -1845.2803 #>             AIC: 3701.56 #>             BIC: 3758.92 #> Condition#(Cov): 143.71 #> Condition#(Cor): 202.97 #>  #> -- Timing Information -- #>      Best Chain: 5.9257 seconds #>      All Chains: 5.9279 seconds #>      Covariance: 28.1302 seconds #>         Elapsed: 34.06 seconds #>  #> -- Population Parameters -- #> # A tibble: 6 × 6 #>   Parameter        Est.      SE  `%RSE` `Back-transformed(95%CI)` `BSV(CV%)` #>   <chr>           <dbl>   <dbl>   <dbl> <chr>                          <dbl> #> 1 cl             1.60    0.0153   0.955 4.96 (4.81, 5.11)               31.9 #> 2 v1             2.31    0.0839   3.64  10.05 (8.52, 11.84)             33.3 #> 3 v2             3.41    0.0393   1.16  30.12 (27.88, 32.53)            31.0 #> 4 q              2.28    0.0213   0.931 9.82 (9.42, 10.24)              32.2 #> 5 ka             0.0181  0.0791 437.    1.02 (0.87, 1.19)               30.0 #> 6 Residual Error 0.0394 NA       NA     0.0394                          NA   #>  #> -- Iteration Diagnostics -- #>  Iter | NLL and Parameters #> -------------------------------------------------------------------------------- #>    1: -1839.577 1.609 2.303 3.401 2.303 0.000 -2.408 -2.408 -2.408 -2.408 -2.408 -3.219 #>    2: -1845.238 1.601 2.309 3.404 2.284 0.020 -2.279 -2.167 -2.333 -2.245 -2.439 -3.235 #>    3: -1845.277 1.600 2.307 3.406 2.285 0.017 -2.287 -2.195 -2.342 -2.267 -2.416 -3.235 #>    4: -1845.277 1.600 2.306 3.406 2.285 0.017 -2.287 -2.195 -2.342 -2.266 -2.416 -3.235 #>    5: -1845.277 1.600 2.306 3.406 2.285 0.017 -2.287 -2.195 -2.342 -2.266 -2.416 -3.235 #>    ... (omitted iterations) ... #>   10: -1845.280 1.601 2.307 3.405 2.285 0.018 -2.286 -2.200 -2.343 -2.264 -2.411 -3.235 #>   11: -1845.280 1.601 2.307 3.405 2.285 0.018 -2.286 -2.200 -2.343 -2.264 -2.411 -3.235 #>   12: -1845.280 1.601 2.307 3.405 2.285 0.018 -2.286 -2.200 -2.343 -2.264 -2.411 -3.235 #>   13: -1845.280 1.601 2.307 3.405 2.285 0.018 -2.286 -2.201 -2.343 -2.265 -2.410 -3.235 #>   14: -1845.280 1.601 2.307 3.405 2.285 0.018 -2.286 -2.201 -2.343 -2.265 -2.410 -3.235"},{"path":"https://hiddevandebeek.github.io/admr/index.html","id":"documentation","dir":"","previous_headings":"","what":"Documentation","title":"Aggregate data modelling in R","text":"package documentation available https://hiddevandebeek.github.io/admr/. Key documentation sections include: Getting Started Advanced Topics Function Reference Examples","code":""},{"path":"https://hiddevandebeek.github.io/admr/index.html","id":"use-cases","dir":"","previous_headings":"","what":"Use Cases","title":"Aggregate data modelling in R","text":"admr package particularly useful : Meta-Analysis: Combining data multiple studies individual-level data available Literature-Based Modeling: Fitting models published summary statistics Simulation Studies: Evaluating model performance aggregate data Population PK/PD: Fitting complex models summary-level data","code":""},{"path":"https://hiddevandebeek.github.io/admr/index.html","id":"getting-help","dir":"","previous_headings":"","what":"Getting Help","title":"Aggregate data modelling in R","text":"Check documentation Browse GitHub issues Create new issue reproducible example","code":""},{"path":"https://hiddevandebeek.github.io/admr/index.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Aggregate data modelling in R","text":"use admr research, please cite :","code":"citation(\"admr\")"},{"path":"https://hiddevandebeek.github.io/admr/index.html","id":"license","dir":"","previous_headings":"","what":"License","title":"Aggregate data modelling in R","text":"project licensed GPL-2 License - see LICENSE file details.","code":""},{"path":"https://hiddevandebeek.github.io/admr/reference/admr-package.html","id":null,"dir":"Reference","previous_headings":"","what":"admr: Aggregate data modelling in R — admr-package","title":"admr: Aggregate data modelling in R — admr-package","text":"novel method aggregate data model using non-linear estimation techniques.","code":""},{"path":[]},{"path":"https://hiddevandebeek.github.io/admr/reference/admr-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"admr: Aggregate data modelling in R — admr-package","text":"H. van de Beek P..J. Välitalo","code":""},{"path":"https://hiddevandebeek.github.io/admr/reference/examplomycin.html","id":null,"dir":"Reference","previous_headings":"","what":"Examplomycin Dataset — examplomycin","title":"Examplomycin Dataset — examplomycin","text":"simulated dataset fictional drug examplomycin. dataset contains 500 subjects, 9 timepoints. generated using two-compartment pharmacokinetic model first-order absorption elimination. Random effects residual errors included simulate variability noise.","code":""},{"path":"https://hiddevandebeek.github.io/admr/reference/examplomycin.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Examplomycin Dataset — examplomycin","text":"","code":"examplomycin"},{"path":"https://hiddevandebeek.github.io/admr/reference/examplomycin.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Examplomycin Dataset — examplomycin","text":"data frame 4500 rows 6 variables: ID: Subject ID. TIME: Observation time (hours). DV: Observed drug concentration (mg/L). AMT: Amount drug administered (mg). EVID: Event type indicator (0 observation, 101 dosing). CMT: Compartment number (1 depot, 2 central).","code":""},{"path":"https://hiddevandebeek.github.io/admr/reference/examplomycin.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Examplomycin Dataset — examplomycin","text":"Generated using generate_data function.","code":""},{"path":"https://hiddevandebeek.github.io/admr/reference/examplomycin.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Examplomycin Dataset — examplomycin","text":"","code":"# Load the dataset data(\"examplomycin\")  # View the first few rows head(examplomycin) #>    ID TIME    DV AMT EVID CMT #> 1 460 0.00 0.000 100  101   1 #> 2 460 0.10 0.752   0    0   2 #> 3 460 0.25 1.932   0    0   2 #> 4 460 0.50 3.694   0    0   2 #> 5 460 1.00 3.479   0    0   2 #> 6 460 2.00 4.003   0    0   2"},{"path":"https://hiddevandebeek.github.io/admr/reference/fitIRMC.html","id":null,"dir":"Reference","previous_headings":"","what":"Fit aggregate data using Iterative Reweighting with Monte Carlo updates — fitIRMC","title":"Fit aggregate data using Iterative Reweighting with Monte Carlo updates — fitIRMC","text":"fitIRMC implements Iterative Reweighting (IRMC) algorithm parameter estimation aggregate data models, iterating maximum likelihood updates weighted Monte Carlo updates. function uses nloptr instead optimx optimization includes additional features like multiple chains phase-based optimization.","code":""},{"path":"https://hiddevandebeek.github.io/admr/reference/fitIRMC.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fit aggregate data using Iterative Reweighting with Monte Carlo updates — fitIRMC","text":"","code":"fitIRMC(   opts,   obs,   maxiter = 100,   convcrit_nll = 1e-05,   single_dataframe = TRUE,   phase_fractions = c(0.2, 0.4, 0.2, 0.2),   max_worse_iterations = 10,   chains = 1,   pertubation = 0.1,   seed = 1 )"},{"path":"https://hiddevandebeek.github.io/admr/reference/fitIRMC.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fit aggregate data using Iterative Reweighting with Monte Carlo updates — fitIRMC","text":"opts list model options generated genopts(). Contains settings model, including prediction function, time points, parameter structure, simulation settings. obs Observed data aggregate form (mean covariance) matrix raw data. maxiter Maximum number iterations optimization algorithm. Default 100. convcrit_nll Convergence criterion negative log-likelihood. algorithm stops relative change negative log-likelihood less value. Default 1e-05. single_dataframe Logical indicating whether use single data frame (TRUE) multiple data frames (FALSE). Default TRUE. phase_fractions Vector fractions optimization phase. sum 1. Default c(0.2, 0.4, 0.2, 0.2). max_worse_iterations Maximum number consecutive worse iterations skipping phase. Default 10. chains Number parallel chains run. Default 1. pertubation Perturbation factor initial parameter values chain. Default 0.1. seed Random seed reproducibility. Default 1.","code":""},{"path":"https://hiddevandebeek.github.io/admr/reference/fitIRMC.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fit aggregate data using Iterative Reweighting with Monte Carlo updates — fitIRMC","text":"object class fitIRMC_result containing: p: List parameter estimates iteration nll: Negative log-likelihood values time: Computation time iteration iter: Iteration number chain: Chain number (multiple chains used) phase: Optimization phase number","code":""},{"path":"https://hiddevandebeek.github.io/admr/reference/fitIRMC.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Fit aggregate data using Iterative Reweighting with Monte Carlo updates — fitIRMC","text":"function uses Iterative Reweighting algorithm Monte Carlo sampling optimization. includes several advanced features: Multiple optimization phases different convergence criteria Parallel chains perturbed starting values Phase-based optimization automatic phase skipping Convergence checking based likelihood parameter stationarity optimization process divided phases, convergence criteria settings. algorithm can automatically skip phases optimization progressing. Multiple chains can run parallel improve chances finding global optimum.","code":""},{"path":"https://hiddevandebeek.github.io/admr/reference/fitIRMC.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fit aggregate data using Iterative Reweighting with Monte Carlo updates — fitIRMC","text":"","code":"# Load required libraries library(admr) library(rxode2) #> rxode2 3.0.4 using 1 threads (see ?getRxThreads) #>   no cache: create with `rxCreateCache()` library(nlmixr2) #> Loading required package: nlmixr2data library(dplyr) #>  #> Attaching package: ‘dplyr’ #> The following objects are masked from ‘package:stats’: #>  #>     filter, lag #> The following objects are masked from ‘package:base’: #>  #>     intersect, setdiff, setequal, union library(tidyr) library(mnorm)  # Load and prepare data data(examplomycin) examplomycin_wide <- examplomycin %>%   filter(EVID != 101) %>%   dplyr::select(ID, TIME, DV) %>%   pivot_wider(names_from = TIME, values_from = DV) %>%   dplyr::select(-c(1))  # Create aggregated data examplomycin_aggregated <- examplomycin_wide %>%   admr::meancov()  # Define RxODE model rxModel <- RxODE({   cp = linCmt(     cl,           # Clearance     v1,           # Volume of the central compartment     v2,           # Volume of the peripheral compartment     q,            # Inter-compartmental clearance     ka            # Absorption rate constant   ) }) #>   #>   #> using C compiler: ‘gcc (Ubuntu 13.3.0-6ubuntu2~24.04) 13.3.0’  # Define prediction function predder <- function(time, theta_i, dose = 100) {   n_individuals <- nrow(theta_i)   if (is.null(n_individuals)) n_individuals <- 1      ev <- eventTable(amount.units=\"mg\", time.units=\"hours\")   ev$add.dosing(dose = dose, nbr.doses = 1, start.time = 0)   ev$add.sampling(time)      out <- rxSolve(rxModel, params = theta_i, events = ev, cores = 0)   cp_matrix <- matrix(out$cp, nrow = n_individuals, ncol = length(time),                       byrow = TRUE)   return(cp_matrix) }  # Create options opts <- genopts(   time = c(.1, .25, .5, 1, 2, 3, 5, 8, 12),   p = list(     beta = c(cl = 5, v1 = 10, v2 = 30, q = 10, ka = 1),     Omega = matrix(c(0.09, 0, 0, 0, 0,                      0, 0.09, 0, 0, 0,                      0, 0, 0.09, 0, 0,                      0, 0, 0, 0.09, 0,                      0, 0, 0, 0, 0.09), nrow = 5, ncol = 5),     Sigma_prop = 0.04   ),   nsim = 2500,   n = 500,   fo_appr = FALSE,   omega_expansion = 1.2,   f = predder )  # Run optimization result <- fitIRMC(opts, examplomycin_aggregated) #> Chain 1: #> Iter | NLL and Parameters (11 values) #> -------------------------------------------------------------------------------- #>    1: -1839.577    1.609    2.303    3.401    2.303    0.000   -2.408   -2.408   -2.408   -2.408   -2.408   -3.219 #>  #> ### Wide Search Phase ### #>    2: -1845.238    1.601    2.309    3.404    2.284    0.019   -2.280   -2.167   -2.334   -2.245   -2.439   -3.235 #>    3: -1845.283    1.601    2.308    3.405    2.285    0.019   -2.286   -2.207   -2.341   -2.264   -2.405   -3.235 #>    4: -1845.283    1.601    2.308    3.405    2.285    0.019   -2.286   -2.206   -2.341   -2.264   -2.405   -3.235 #>    5: -1845.283    1.601    2.308    3.405    2.285    0.019   -2.286   -2.205   -2.343   -2.264   -2.405   -3.235 #>    6: -1845.283    1.601    2.308    3.405    2.285    0.019   -2.286   -2.205   -2.343   -2.264   -2.405   -3.235 #>    7: -1845.283    1.601    2.308    3.405    2.285    0.019   -2.286   -2.205   -2.343   -2.264   -2.405   -3.235 #>    8: -1845.282    1.601    2.308    3.405    2.285    0.018   -2.286   -2.205   -2.343   -2.264   -2.406   -3.235 #>    9: -1845.282    1.601    2.308    3.405    2.285    0.018   -2.286   -2.204   -2.343   -2.264   -2.406   -3.235 #>   10: -1845.282    1.601    2.307    3.405    2.285    0.018   -2.286   -2.204   -2.343   -2.265   -2.406   -3.235 #>   11: -1845.282    1.601    2.308    3.405    2.285    0.018   -2.286   -2.204   -2.343   -2.264   -2.406   -3.235 #>   12: -1845.282    1.601    2.308    3.405    2.285    0.018   -2.286   -2.204   -2.343   -2.264   -2.406   -3.235 #> Phase Wide Search Phase converged at iteration 12. #>  #> ### Focussed Search Phase ### #>   13: -1845.280    1.601    2.307    3.405    2.285    0.018   -2.286   -2.201   -2.343   -2.265   -2.410   -3.235 #>   14: -1845.280    1.601    2.307    3.405    2.285    0.018   -2.286   -2.201   -2.343   -2.265   -2.410   -3.235 #>   15: -1845.280    1.601    2.307    3.405    2.285    0.018   -2.286   -2.201   -2.343   -2.265   -2.410   -3.235 #> Phase Focussed Search Phase converged at iteration 15. #>  #> ### Fine-Tuning Phase ### #>   16: -1845.280    1.601    2.307    3.405    2.285    0.018   -2.286   -2.201   -2.343   -2.265   -2.410   -3.235 #>   17: -1845.280    1.601    2.307    3.405    2.285    0.018   -2.286   -2.201   -2.343   -2.265   -2.410   -3.235 #>   18: -1845.280    1.601    2.307    3.405    2.285    0.018   -2.286   -2.201   -2.343   -2.265   -2.410   -3.235 #>   19: -1845.280    1.601    2.307    3.405    2.285    0.018   -2.286   -2.201   -2.343   -2.265   -2.410   -3.235 #> Phase Fine-Tuning Phase converged at iteration 19. #>  #> ### Precision Phase ### #>   20: -1845.280    1.601    2.307    3.405    2.285    0.018   -2.286   -2.201   -2.343   -2.265   -2.410   -3.235 #>   21: -1845.280    1.601    2.307    3.405    2.285    0.018   -2.286   -2.201   -2.343   -2.265   -2.410   -3.235 #>   22: -1845.280    1.601    2.307    3.405    2.285    0.018   -2.286   -2.201   -2.343   -2.265   -2.410   -3.235 #> Phase Precision Phase converged at iteration 22. #>  #> Chain 1 Complete: Final NLL = -1845.283, Time Elapsed = 8.40 seconds #>   print(result) #> -- FitIRMC Summary -- #>  #> -- Objective Function and Information Criteria -- #>  Log-likelihood: -1845.2827 #>             AIC: 3701.57 #>             BIC: 3758.93 #> Condition#(Cov): 144.64 #> Condition#(Cor): 204.50 #>  #> -- Timing Information -- #>      Best Chain: 8.3961 seconds #>      All Chains: 8.3989 seconds #>      Covariance: 28.0758 seconds #>         Elapsed: 36.47 seconds #>  #> -- Population Parameters -- #> # A tibble: 6 × 6 #>   Parameter        Est.      SE  `%RSE` `Back-transformed(95%CI)` `BSV(CV%)` #>   <chr>           <dbl>   <dbl>   <dbl> <chr>                          <dbl> #> 1 cl             1.60    0.0153   0.954 4.96 (4.81, 5.11)               31.9 #> 2 v1             2.31    0.0842   3.65  10.05 (8.52, 11.85)             33.2 #> 3 v2             3.40    0.0394   1.16  30.11 (27.87, 32.53)            31.0 #> 4 q              2.28    0.0213   0.930 9.82 (9.42, 10.24)              32.2 #> 5 ka             0.0186  0.0794 427.    1.02 (0.87, 1.19)               30.0 #> 6 Residual Error 0.0394 NA       NA     0.0394                          NA   #>  #> -- Iteration Diagnostics -- #>  Iter | NLL and Parameters #> -------------------------------------------------------------------------------- #>    1: -1839.577 1.609 2.303 3.401 2.303 0.000 -2.408 -2.408 -2.408 -2.408 -2.408 -3.219 #>    2: -1845.238 1.601 2.309 3.404 2.284 0.019 -2.280 -2.167 -2.334 -2.245 -2.439 -3.235 #>    3: -1845.283 1.601 2.308 3.405 2.285 0.019 -2.286 -2.207 -2.341 -2.264 -2.405 -3.235 #>    4: -1845.283 1.601 2.308 3.405 2.285 0.019 -2.286 -2.206 -2.341 -2.264 -2.405 -3.235 #>    5: -1845.283 1.601 2.308 3.405 2.285 0.019 -2.286 -2.205 -2.343 -2.264 -2.405 -3.235 #>    ... (omitted iterations) ... #>   18: -1845.280 1.601 2.307 3.405 2.285 0.018 -2.286 -2.201 -2.343 -2.265 -2.410 -3.235 #>   19: -1845.280 1.601 2.307 3.405 2.285 0.018 -2.286 -2.201 -2.343 -2.265 -2.410 -3.235 #>   20: -1845.280 1.601 2.307 3.405 2.285 0.018 -2.286 -2.201 -2.343 -2.265 -2.410 -3.235 #>   21: -1845.280 1.601 2.307 3.405 2.285 0.018 -2.286 -2.201 -2.343 -2.265 -2.410 -3.235 #>   22: -1845.280 1.601 2.307 3.405 2.285 0.018 -2.286 -2.201 -2.343 -2.265 -2.410 -3.235 #>"},{"path":"https://hiddevandebeek.github.io/admr/reference/gen_pop_EV.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute expected population-level mean and covariance — gen_pop_EV","title":"Compute expected population-level mean and covariance — gen_pop_EV","text":"gen_pop_EV computes expected population-level mean covariance model predictions using either first-order approximation (FO) Monte Carlo (MC) methods. function core component aggregate data modeling framework, used generate expected values model fitting optimization.","code":""},{"path":"https://hiddevandebeek.github.io/admr/reference/gen_pop_EV.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute expected population-level mean and covariance — gen_pop_EV","text":"","code":"gen_pop_EV(opts)"},{"path":"https://hiddevandebeek.github.io/admr/reference/gen_pop_EV.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute expected population-level mean and covariance — gen_pop_EV","text":"opts list model options generated genopts(). Contains settings model, including: Prediction function (f) Time points prediction Population parameters (beta) -subject variability (Omega) Method selection (fo_appr) Number Monte Carlo samples (nsim) Omega expansion factor","code":""},{"path":"https://hiddevandebeek.github.io/admr/reference/gen_pop_EV.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute expected population-level mean and covariance — gen_pop_EV","text":"list containing: E: Expected mean model predictions time point V: Expected covariance matrix predictions across time points","code":""},{"path":"https://hiddevandebeek.github.io/admr/reference/gen_pop_EV.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compute expected population-level mean and covariance — gen_pop_EV","text":"function implements two methods computing population expectations: First-Order (FO) Approximation (opts$fo_appr TRUE): Uses linearization around random effects (η) Steps: . Generate random effects samples b. Compute importance sampling weights based η distribution c. individual: Compute FOCE approximation mean covariance Apply importance sampling weights d. Combine weighted results across individuals Advantages: Computationally efficient complex models Good accuracy nearly linear systems Used : Number Monte Carlo samples small (nsim < 10) Model approximately linear random effects Monte Carlo (MC) Approximation (opts$fo_appr FALSE): Uses direct simulation estimate expectations Steps: . Generate random effects samples b. Compute full model predictions sample c. Calculate empirical mean covariance d. Apply importance sampling omega expansion used Advantages: linearization assumptions accurate highly nonlinear models Used : Sufficient Monte Carlo samples available High accuracy required Model highly nonlinear choice methods depends : Model complexity nonlinearity Required accuracy Computational resources Number available Monte Carlo samples","code":""},{"path":"https://hiddevandebeek.github.io/admr/reference/gen_pop_EV.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute expected population-level mean and covariance — gen_pop_EV","text":"","code":"# Define the two-compartment model using RxODE rxModel <- RxODE({   # Central compartment   d/dt(centr) = -cl * centr - q * centr + q * periph + ka * depot   # Peripheral compartment   d/dt(periph) = q * centr - q * periph   # Depot compartment   d/dt(depot) = -ka * depot   # Concentration in central compartment   cp = centr / v1 }) #>   #>   #> using C compiler: ‘gcc (Ubuntu 13.3.0-6ubuntu2~24.04) 13.3.0’  # Define prediction function for a two-compartment model predder <- function(time, theta_i, dose = 100) {   n_individuals <- nrow(theta_i)   if (is.null(n_individuals)) n_individuals <- 1    # Create event table for dosing and sampling   ev <- eventTable(amount.units=\"mg\", time.units=\"hours\")   ev$add.dosing(dose = dose, nbr.doses = 1, start.time = 0)   ev$add.sampling(time)    # Solve ODE system   out <- rxSolve(rxModel, params = theta_i, events = ev, cores = 0)    # Return matrix of predictions   matrix(out$cp, nrow = n_individuals, ncol = length(time), byrow = TRUE) }  # Create options for a two-compartment model opts <- genopts(   f = predder,   time = c(.1, .25, .5, 1, 2, 3, 5, 8, 12),   p = list(     # Population parameters (fixed effects)     beta = c(cl = 5,    # Clearance (L/h)             v1 = 10,    # Central volume (L)             v2 = 30,    # Peripheral volume (L)             q = 10,     # Inter-compartmental clearance (L/h)             ka = 1),    # Absorption rate (1/h)      # Between-subject variability (30% CV on all parameters)     Omega = matrix(c(0.09, 0, 0, 0, 0,                     0, 0.09, 0, 0, 0,                     0, 0, 0.09, 0, 0,                     0, 0, 0, 0.09, 0,                     0, 0, 0, 0, 0.09), nrow = 5, ncol = 5),      # Residual error (20% CV)     Sigma_prop = 0.04   ),   nsim = 2500,  # Number of Monte Carlo samples   n = 500,      # Number of individuals   fo_appr = FALSE  # Use Monte Carlo approximation )  # Generate population expectations ev <- gen_pop_EV(opts)"},{"path":"https://hiddevandebeek.github.io/admr/reference/gendataset.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate a simulated dataset — gendataset","title":"Generate a simulated dataset — gendataset","text":"gendataset generates simulated dataset based model structure random effects specified options. function can generate data either raw format nlmixr format, optional residual error.","code":""},{"path":"https://hiddevandebeek.github.io/admr/reference/gendataset.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate a simulated dataset — gendataset","text":"","code":"gendataset(opts, seed = 1, reserr = TRUE, nlmixrform = FALSE)"},{"path":"https://hiddevandebeek.github.io/admr/reference/gendataset.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate a simulated dataset — gendataset","text":"opts list model options generated genopts(). Contains settings model, including prediction function, time points, parameter structure, simulation settings. seed Random seed reproducibility. Default 1. reserr Logical indicating whether add residual error simulated data. Default TRUE. nlmixrform Logical indicating whether return data nlmixr format. TRUE, returns data frame columns: dv, time, id, amt, evid, cmt. FALSE, returns matrix simulated observations. Default FALSE.","code":""},{"path":"https://hiddevandebeek.github.io/admr/reference/gendataset.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate a simulated dataset — gendataset","text":"nlmixrform FALSE, returns matrix simulated observations dimensions nsim x length(time). nlmixrform TRUE, returns data frame nlmixr format columns: dv: Dependent variable (e.g., concentration measurements) time: Observation time points id: Subject identifier amt: Dose amount (NA observations, typically mg) evid: Event identifier (101 dosing, 0 observation) cmt: Compartment number (1 depot/dosing, 2 central/observation)","code":""},{"path":"https://hiddevandebeek.github.io/admr/reference/gendataset.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generate a simulated dataset — gendataset","text":"function generates simulated data following steps: Generating random effects (η) multivariate normal distribution Computing individual parameters (θᵢ) using log-normal transformations Simulating concentration-time profiles using prediction function Adding residual error components requested: - Proportional error: y = f(t,θ)(1 + ε), ε ~ N(0,σ²_prop) - Additive error: y = f(t,θ) + ε, ε ~ N(0,σ²_add) Formatting output either raw matrix nlmixr-compatible format residual error model can include: Proportional error (specified Sigma_prop) Additive error (specified Sigma_add) Combined error model (Sigma_prop Sigma_add) function supports reproducible simulations seed parameter compatible population PK modeling simulation workflows.","code":""},{"path":"https://hiddevandebeek.github.io/admr/reference/gendataset.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate a simulated dataset — gendataset","text":"","code":"# Define the two-compartment model using RxODE rxModel <- RxODE({   # Central compartment   d/dt(centr) = -cl * centr - q * centr + q * periph + ka * depot   # Peripheral compartment   d/dt(periph) = q * centr - q * periph   # Depot compartment   d/dt(depot) = -ka * depot   # Concentration in central compartment   cp = centr / v1 }) #>   #>    # Define prediction function for a two-compartment model predder <- function(time, theta_i, dose = 100) {   n_individuals <- nrow(theta_i)   if (is.null(n_individuals)) n_individuals <- 1      # Create event table for dosing and sampling   ev <- eventTable(amount.units=\"mg\", time.units=\"hours\")   ev$add.dosing(dose = dose, nbr.doses = 1, start.time = 0)   ev$add.sampling(time)      # Solve ODE system   out <- rxSolve(rxModel, params = theta_i, events = ev, cores = 0)      # Return matrix of predictions   matrix(out$cp, nrow = n_individuals, ncol = length(time), byrow = TRUE) }  # Create options for a two-compartment model opts <- genopts(   f = predder,   time = c(.1, .25, .5, 1, 2, 3, 5, 8, 12),   p = list(     # Population parameters (fixed effects)     beta = c(cl = 5,    # Clearance (L/h)             v1 = 10,    # Central volume (L)             v2 = 30,    # Peripheral volume (L)             q = 10,     # Inter-compartmental clearance (L/h)             ka = 1),    # Absorption rate (1/h)          # Between-subject variability (30% CV on all parameters)     Omega = matrix(c(0.09, 0, 0, 0, 0,                     0, 0.09, 0, 0, 0,                     0, 0, 0.09, 0, 0,                     0, 0, 0, 0.09, 0,                     0, 0, 0, 0, 0.09), nrow = 5, ncol = 5),          # Residual error (20% CV)     Sigma_prop = 0.04   ),   nsim = 2500,  # Number of Monte Carlo samples   n = 500,      # Number of individuals   fo_appr = FALSE  # Use Monte Carlo approximation )  # Generate a dataset with 100 individuals dataset <- gendataset(opts, n = 100) expect_named(dataset, c(\"time\", \"value\", \"id\")) #> Error in expect_named(dataset, c(\"time\", \"value\", \"id\")): could not find function \"expect_named\""},{"path":"https://hiddevandebeek.github.io/admr/reference/genfitfunc.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate a fitting function for optimization — genfitfunc","title":"Generate a fitting function for optimization — genfitfunc","text":"genfitfunc generates fitting function optimization computes negative log-likelihood model given observed data current parameter estimates. function handles raw data aggregate data (mean covariance) formats.","code":""},{"path":"https://hiddevandebeek.github.io/admr/reference/genfitfunc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate a fitting function for optimization — genfitfunc","text":"","code":"genfitfunc(opts, obs)"},{"path":"https://hiddevandebeek.github.io/admr/reference/genfitfunc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate a fitting function for optimization — genfitfunc","text":"opts list model options generated genopts(). Contains settings model, including: f: Prediction function model time: Vector observation times p: List parameter values structure nsim: Number Monte Carlo samples n: Number individuals pt: Parameter values transformed scale ptrans: Parameter transformation function obs Observed data one two formats: 1. Aggregate form: List elements: - E: Vector means time point - V: Covariance matrix observations 2. Raw data matrix: - Rows: Individual observations (nsim) - Columns: Time points","code":""},{"path":"https://hiddevandebeek.github.io/admr/reference/genfitfunc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate a fitting function for optimization — genfitfunc","text":"function signature function(p, givedetails = FALSE, opts_overrides) : p: Parameter values (transformed untransformed) givedetails: TRUE, returns additional attributes: - EV: Expected values (mean covariance) - obs: Observed data - nllfun: Negative log-likelihood function - opts: Model options used opts_overrides: Optional list override model options Returns: Negative log-likelihood value","code":""},{"path":"https://hiddevandebeek.github.io/admr/reference/genfitfunc.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generate a fitting function for optimization — genfitfunc","text":"Algorithm Steps: Data Preparation: Validates input data format Converts raw data aggregate form needed Uses expected data observations provided Parameter Processing: Handles transformed untransformed parameters Updates model options current parameters Likelihood Computation: Generates expected values using gen_pop_EV Computes covariance matrix inverse Calculates negative log-likelihood Error Handling: Checks matrix inversion problems Validates data dimensions Ensures proper parameter transformations Mathematical Details: Negative Log-Likelihood: $$-2\\log L = n\\log|V| + (y - \\mu)^T V^{-1} (y - \\mu)$$ : - n: Number individuals - V: Model-predicted covariance matrix - y: Observed means - μ: Model-predicted means Parameter Transformations: - Log transform positive parameters - Logit transform bounded parameters - Identity unrestricted parameters","code":""},{"path":"https://hiddevandebeek.github.io/admr/reference/genfitfunc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate a fitting function for optimization — genfitfunc","text":"","code":"# Define the two-compartment model using RxODE rxModel <- RxODE({   # Central compartment   d/dt(centr) = -cl * centr - q * centr + q * periph + ka * depot   # Peripheral compartment   d/dt(periph) = q * centr - q * periph   # Depot compartment   d/dt(depot) = -ka * depot   # Concentration in central compartment   cp = centr / v1 }) #>   #>    # Define prediction function for a two-compartment model predder <- function(time, theta_i, dose = 100) {   n_individuals <- nrow(theta_i)   if (is.null(n_individuals)) n_individuals <- 1      # Create event table for dosing and sampling   ev <- eventTable(amount.units=\"mg\", time.units=\"hours\")   ev$add.dosing(dose = dose, nbr.doses = 1, start.time = 0)   ev$add.sampling(time)      # Solve ODE system   out <- rxSolve(rxModel, params = theta_i, events = ev, cores = 0)      # Return matrix of predictions   matrix(out$cp, nrow = n_individuals, ncol = length(time), byrow = TRUE) }  # Create options for a two-compartment model opts <- genopts(   f = predder,   time = c(.1, .25, .5, 1, 2, 3, 5, 8, 12),   p = list(     # Population parameters (fixed effects)     beta = c(cl = 5,    # Clearance (L/h)             v1 = 10,    # Central volume (L)             v2 = 30,    # Peripheral volume (L)             q = 10,     # Inter-compartmental clearance (L/h)             ka = 1),    # Absorption rate (1/h)          # Between-subject variability (30% CV on all parameters)     Omega = matrix(c(0.09, 0, 0, 0, 0,                     0, 0.09, 0, 0, 0,                     0, 0, 0.09, 0, 0,                     0, 0, 0, 0.09, 0,                     0, 0, 0, 0, 0.09), nrow = 5, ncol = 5),          # Residual error (20% CV)     Sigma_prop = 0.04   ),   nsim = 2500,  # Number of Monte Carlo samples   n = 500,      # Number of individuals   fo_appr = FALSE  # Use Monte Carlo approximation )  # Generate objective function for optimization objfun <- genfitfunc(opts) #> Error in genfitfunc(opts): argument \"obs\" is missing, with no default  # Test the objective function with initial parameters init_params <- opts$p$beta nll <- objfun(init_params) #> Error in objfun(init_params): could not find function \"objfun\" expect_type(nll, \"double\") #> Error in expect_type(nll, \"double\"): could not find function \"expect_type\""},{"path":"https://hiddevandebeek.github.io/admr/reference/genopts.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate options for aggregate data modeling — genopts","title":"Generate options for aggregate data modeling — genopts","text":"genopts initializes generates core options settings aggregate data modeling optimization. creates comprehensive options object contains necessary information model fitting, including random effects, simulation settings, likelihood approximations. function main entry point setting aggregate data modeling package.","code":""},{"path":"https://hiddevandebeek.github.io/admr/reference/genopts.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate options for aggregate data modeling — genopts","text":"","code":"genopts(   f,   time,   p,   h,   nsim = 1,   n = 30,   adist = NULL,   interact = TRUE,   fo_appr = (nsim < 10),   biseq = NA,   omega_expansion = 1,   single_betas = NA,   p_thetai = function(p, origbeta, bi) {      dmnorm(bi, mean = log(p$beta/origbeta),     sigma = p$Omega, log = TRUE)$den  },   g = function(beta, bi = rep(0, length(beta)), ai) { beta * exp(bi)  } )"},{"path":"https://hiddevandebeek.github.io/admr/reference/genopts.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate options for aggregate data modeling — genopts","text":"f prediction function simulates model output given parameters time points. function signature function(time, theta_i, ...) : time: Vector time points theta_i: Matrix individual parameters Returns: Matrix predictions time Vector time points evaluate model predictions. p List containing initial parameter values structure: beta: Vector population parameters (fixed effects) Omega: Covariance matrix random effects (-subject variability) Sigma_prop: Proportional error variance (optional) Sigma_add: Additive error variance (optional) h error function computes variance predictions. provided, default function used adds proportional additive error components. nsim Number Monte Carlo samples per iteration. Default 1. n Number individuals dataset. Used OFV, AIC, BIC calculation. Default 30. adist Distribution random effects. Default NULL (normal distribution). interact Logical indicating whether use FOCEI interaction. Default TRUE. fo_appr Logical indicating whether use first-order approximation. Default TRUE nsim < 10, FALSE otherwise. biseq Sequence random effects. Default NA (generated internally). omega_expansion Factor expand covariance matrix estimation. Default 1. single_betas Matrix beta parameters multiple models. Default NA. p_thetai Function compute log-density random effects. Default multivariate normal density. g Function transform population parameters individual parameters. Default exponential transformation.","code":""},{"path":"https://hiddevandebeek.github.io/admr/reference/genopts.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate options for aggregate data modeling — genopts","text":"list containing: f: prediction function time: Time points evaluation p: Parameter structure initial values h: error function nsim: Number Monte Carlo samples n: Number individuals adist: Distribution random effects interact: FOCEI interaction flag fo_appr: First-order approximation flag biseq: Random effects sequence omega_expansion: Covariance expansion factor single_betas: Beta parameters multiple models p_thetai: Random effects density function g: Parameter transformation function pt: Transformed initial parameters ptrans: Function back-transform parameters pderiv: Function compute parameter derivatives d_g_d_beta: Derivative g respect beta d_g_d_bi: Derivative g respect random effects d_bi_d_omega: Derivative random effects respect Omega d_omega_d_Omega: Derivative transformed Omega respect untransformed","code":""},{"path":"https://hiddevandebeek.github.io/admr/reference/genopts.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generate options for aggregate data modeling — genopts","text":"function performs several key operations: Parameter Transformation: - Converts parameters optimization scale - Computes derivatives optimization - Handles fixed parameters Random Effects Generation: - Uses Sobol sequences quasi-random sampling - Applies normal quantile transformation - Supports custom distributions Error Function Setup: - Handles proportional error: y = f(t,θ)(1 + ε) - Handles additive error: y = f(t,θ) + ε - Combines error types Key features: Automatic derivative computation parameter transformations Support multiple models parameter structures Flexible error model specification Efficient random effects generation","code":""},{"path":"https://hiddevandebeek.github.io/admr/reference/genopts.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate options for aggregate data modeling — genopts","text":"","code":"# Define prediction function for a two-compartment model predder <- function(time, theta_i, dose = 100) {   n_individuals <- nrow(theta_i)   if (is.null(n_individuals)) n_individuals <- 1      # Create event table for dosing and sampling   ev <- eventTable(amount.units=\"mg\", time.units=\"hours\")   ev$add.dosing(dose = dose, nbr.doses = 1, start.time = 0)   ev$add.sampling(time)      # Solve ODE system   out <- rxSolve(rxModel, params = theta_i, events = ev, cores = 0)      # Return matrix of predictions   matrix(out$cp, nrow = n_individuals, ncol = length(time), byrow = TRUE) }  # Create options for a two-compartment model opts <- genopts(   f = predder,   time = c(.1, .25, .5, 1, 2, 3, 5, 8, 12),   p = list(     # Population parameters (fixed effects)     beta = c(cl = 5,    # Clearance (L/h)             v1 = 10,    # Central volume (L)             v2 = 30,    # Peripheral volume (L)             q = 10,     # Inter-compartmental clearance (L/h)             ka = 1),    # Absorption rate (1/h)          # Between-subject variability (30% CV on all parameters)     Omega = matrix(c(0.09, 0, 0, 0, 0,                     0, 0.09, 0, 0, 0,                     0, 0, 0.09, 0, 0,                     0, 0, 0, 0.09, 0,                     0, 0, 0, 0, 0.09), nrow = 5, ncol = 5),          # Residual error (20% CV)     Sigma_prop = 0.04   ),   nsim = 2500,  # Number of Monte Carlo samples   n = 500,      # Number of individuals   fo_appr = FALSE,  # Use Monte Carlo approximation   omega_expansion = 1.2  # Expand covariance during estimation )"},{"path":"https://hiddevandebeek.github.io/admr/reference/meancov.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute mean and covariance of a matrix — meancov","title":"Compute mean and covariance of a matrix — meancov","text":"meancov computes mean covariance matrix, optionally weights. function used convert raw data aggregate form (mean covariance) use aggregate data modeling.","code":""},{"path":"https://hiddevandebeek.github.io/admr/reference/meancov.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute mean and covariance of a matrix — meancov","text":"","code":"meancov(m, wt)"},{"path":"https://hiddevandebeek.github.io/admr/reference/meancov.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute mean and covariance of a matrix — meancov","text":"m numeric matrix data frame containing observations. row represents individual, column represents time point. pharmacometric data, columns typically represent concentration measurements different time points. wt Optional vector weights observation. provided, observations weighted equally. Weights can used account different sample sizes reliability different data sources.","code":""},{"path":"https://hiddevandebeek.github.io/admr/reference/meancov.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute mean and covariance of a matrix — meancov","text":"list containing: E: Vector means time point (population typical values) V: Covariance matrix representing variability individuals","code":""},{"path":"https://hiddevandebeek.github.io/admr/reference/meancov.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compute mean and covariance of a matrix — meancov","text":"function computes: mean column (time point) using colMeans unweighted data weighted means weighted data covariance matrix using cov.wt maximum likelihood estimation, provides unbiased estimates population covariance maximum likelihood estimation method used : provides unbiased estimates covariance matrix appropriate aggregate data modeling want estimate population parameters handles balanced unbalanced designs optional weights Key features: Handles missing data automatically underlying cov.wt function Provides numerically stable computations Can used raw PK data simulated data Supports weighted calculations meta-analysis combined analysis","code":""},{"path":"https://hiddevandebeek.github.io/admr/reference/meancov.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute mean and covariance of a matrix — meancov","text":"","code":"# Create a matrix of concentration measurements # 10 subjects measured at 10 time points m <- matrix(rnorm(100), nrow = 10, ncol = 10)  # Compute unweighted mean and covariance # Useful for single-study analysis result <- meancov(m)  # Compute weighted mean and covariance # Useful for meta-analysis or when combining studies weights <- runif(10)  # weights could represent study sizes result_weighted <- meancov(m, weights)"},{"path":"https://hiddevandebeek.github.io/admr/reference/omegas.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a covariance matrix with specified diagonal and off-diagonal values — omegas","title":"Create a covariance matrix with specified diagonal and off-diagonal values — omegas","text":"omegas creates covariance matrix specified diagonal -diagonal values. function useful creating initial fixed covariance matrices random effects pharmacometric models.","code":""},{"path":"https://hiddevandebeek.github.io/admr/reference/omegas.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a covariance matrix with specified diagonal and off-diagonal values — omegas","text":"","code":"omegas(diag, offdiag, n_om)"},{"path":"https://hiddevandebeek.github.io/admr/reference/omegas.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a covariance matrix with specified diagonal and off-diagonal values — omegas","text":"diag Value diagonal elements matrix. represents variance random effect. log-normal distributions, typically squared coefficient variation (CV²) log scale. offdiag Value -diagonal elements matrix. represents covariance random effects. value 0 indicates independence random effects. n_om Size matrix (number random effects). match number random effects model (e.g., 2 CL V one-compartment model).","code":""},{"path":"https://hiddevandebeek.github.io/admr/reference/omegas.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a covariance matrix with specified diagonal and off-diagonal values — omegas","text":"symmetric matrix size n_om x n_om : Diagonal elements equal diag (variances) -diagonal elements equal offdiag (covariances)","code":""},{"path":"https://hiddevandebeek.github.io/admr/reference/omegas.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create a covariance matrix with specified diagonal and off-diagonal values — omegas","text":"function creates symmetric covariance matrix random effects : Diagonal elements (ω²) represent -subject variability -diagonal elements (ω_ij) represent correlations parameters resulting matrix must positive definite valid computations Common use cases include: Initial estimates model fitting: - Setting diagonal elements expected variability (e.g., 0.09 30% CV) - Starting zero correlations (offdiag = 0) Simulation studies: - Specifying known parameter variability - Testing impact parameter correlations Sensitivity analysis: - Evaluating model behavior different variability assumptions - Assessing impact parameter correlations Mathematical details: log-normal distributions: CV ≈ sqrt(exp(ω²) - 1) Correlation ρ_ij = ω_ij / sqrt(ω_ii * ω_jj) Matrix must positive definite: eigenvalues > 0","code":""},{"path":"https://hiddevandebeek.github.io/admr/reference/omegas.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a covariance matrix with specified diagonal and off-diagonal values — omegas","text":"","code":"# Create a diagonal matrix for a one-compartment model # 30% CV on CL and V (ω² = 0.09 for each) omega1 <- omegas(0.09, 0, 2)  # Create a matrix with correlations for a two-compartment model # 30% CV on all parameters (CL, V1, Q, V2) # Correlation of 0.3 between parameters omega2 <- omegas(0.09, 0.03, 4)  # Create a matrix for testing parameter correlations # High variability (50% CV, ω² = 0.25) and strong correlations (0.1) omega3 <- omegas(0.25, 0.1, 3)"},{"path":"https://hiddevandebeek.github.io/admr/reference/p_to_optim.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert parameters to optimizable form — p_to_optim","title":"Convert parameters to optimizable form — p_to_optim","text":"p_to_optim converts parameter list form suitable optimization transforming parameters computing derivatives. function handles transformation fixed random effect parameters.","code":""},{"path":"https://hiddevandebeek.github.io/admr/reference/p_to_optim.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert parameters to optimizable form — p_to_optim","text":"","code":"p_to_optim(p)"},{"path":"https://hiddevandebeek.github.io/admr/reference/p_to_optim.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert parameters to optimizable form — p_to_optim","text":"p list containing parameter structure: beta: Vector population parameters (fixed effects) e.g., clearance (CL), volume (V), absorption rate (ka) Omega: Covariance matrix random effects (-subject variability) diagonal elements variances, -diagonal covariances Sigma_prop: Proportional error variance (optional) represents CV² residual error Sigma_add: Additive error variance (optional) represents constant error magnitude","code":""},{"path":"https://hiddevandebeek.github.io/admr/reference/p_to_optim.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert parameters to optimizable form — p_to_optim","text":"list containing: values: Vector transformed parameter values optimization scale backtransformfunc: Function convert optimized values back original scale d_psi_d_psitrans_long: Function computing long-form parameter derivatives d_psi_d_psitrans_short: Function computing short-form parameter derivatives d_bi_d_omega: Derivatives random effects respect Omega elements d_omega_d_Omega: Derivatives transformed Omega respect untransformed","code":""},{"path":"https://hiddevandebeek.github.io/admr/reference/p_to_optim.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Convert parameters to optimizable form — p_to_optim","text":"Parameter Transformations: Population Parameters (beta): - Log transformation positive parameters - Identity transformation unrestricted parameters - Logit transformation parameters bounded 0 1 Variance Components (Omega diagonal): - Log transformation ensure positivity - Typically represents -subject variability Correlation Components (Omega -diagonal): - Inverse hyperbolic tangent (atanh) transformation - Ensures correlations remain -1 1 Residual Error (Sigma): - Log transformation variance parameters - Handles proportional additive error structures Derivative Computations: First-order derivatives optimization algorithms Chain rule applied composed transformations Separate handling variance correlation parameters Support dense sparse matrices Special Features: Handles fixed parameters (specified character strings) Preserves parameter names throughout transformations Automatic conversion exponential error proportional Validates parameter values transformations","code":""},{"path":"https://hiddevandebeek.github.io/admr/reference/p_to_optim.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert parameters to optimizable form — p_to_optim","text":"","code":"# Define a two-compartment model parameters p <- list(   # Population parameters (fixed effects)   beta = c(cl = 5,    # Clearance (L/h)           v1 = 10,    # Central volume (L)           v2 = 30,    # Peripheral volume (L)           q = 10,     # Inter-compartmental clearance (L/h)           ka = 1),    # Absorption rate (1/h)      # Between-subject variability (30% CV on all parameters)   Omega = matrix(c(0.09, 0, 0, 0, 0,                   0, 0.09, 0, 0, 0,                   0, 0, 0.09, 0, 0,                   0, 0, 0, 0.09, 0,                   0, 0, 0, 0, 0.09), nrow = 5, ncol = 5),      # Residual error (20% CV)   Sigma_prop = 0.04 )  # Convert to optimization scale p_optim <- p_to_optim(p)  # Back-transform to original scale p_orig <- p_optim$backtransformfunc(p_optim$values)"},{"path":"https://hiddevandebeek.github.io/admr/reference/plot.fitIRMC_result.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot diagnostics of fitIRMC results — plot.fitIRMC_result","title":"Plot diagnostics of fitIRMC results — plot.fitIRMC_result","text":"Plot diagnostics fitIRMC results","code":""},{"path":"https://hiddevandebeek.github.io/admr/reference/plot.fitIRMC_result.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot diagnostics of fitIRMC results — plot.fitIRMC_result","text":"","code":"# S3 method for class 'fitIRMC_result' plot(x, ...)"},{"path":"https://hiddevandebeek.github.io/admr/reference/plot.fitIRMC_result.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot diagnostics of fitIRMC results — plot.fitIRMC_result","text":"x fitted model object returned fitIRMC ... Additional arguments (used)","code":""},{"path":"https://hiddevandebeek.github.io/admr/reference/print.fitIRMC_result.html","id":null,"dir":"Reference","previous_headings":"","what":"Print fitIRMC results — print.fitIRMC_result","title":"Print fitIRMC results — print.fitIRMC_result","text":"Print fitIRMC results","code":""},{"path":"https://hiddevandebeek.github.io/admr/reference/print.fitIRMC_result.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print fitIRMC results — print.fitIRMC_result","text":"","code":"# S3 method for class 'fitIRMC_result' print(x, ...)"},{"path":"https://hiddevandebeek.github.io/admr/reference/print.fitIRMC_result.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print fitIRMC results — print.fitIRMC_result","text":"x fitted model object returned fitIRMC ... Additional arguments (used)","code":""},{"path":"https://hiddevandebeek.github.io/admr/reference/timedIRMC.html","id":null,"dir":"Reference","previous_headings":"","what":"Fit aggregate data using Iterative Reweighting with Monte Carlo updates — timedIRMC","title":"Fit aggregate data using Iterative Reweighting with Monte Carlo updates — timedIRMC","text":"timedIRMC implements Iterative Reweighting (IRMC) algorithm parameter estimation aggregate data models, iterating maximum likelihood updates weighted Monte Carlo updates. function used compare performance different implementations aggregate data modeling.","code":""},{"path":"https://hiddevandebeek.github.io/admr/reference/timedIRMC.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fit aggregate data using Iterative Reweighting with Monte Carlo updates — timedIRMC","text":"","code":"timedIRMC(init, opts, obs, maxiter = 100, convcrit_nll = 5e-04, nomap = TRUE)"},{"path":"https://hiddevandebeek.github.io/admr/reference/timedIRMC.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fit aggregate data using Iterative Reweighting with Monte Carlo updates — timedIRMC","text":"init Initial parameter values optimization. transformed parameters generated opts$pt. opts list model options generated genopts(). Contains settings model, including prediction function, time points, parameter structure, simulation settings. obs Observed data aggregate form (mean covariance) matrix raw data. maxiter Maximum number iterations optimization algorithm. Default 100. convcrit_nll Convergence criterion negative log-likelihood. algorithm stops relative change negative log-likelihood less value. Default 5e-04. nomap Logical indicating whether use multiple models (FALSE) single model (TRUE). Default TRUE.","code":""},{"path":"https://hiddevandebeek.github.io/admr/reference/timedIRMC.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fit aggregate data using Iterative Reweighting with Monte Carlo updates — timedIRMC","text":"data frame containing: p: List parameter estimates iteration nll: Negative log-likelihood values time: Computation time iteration iter: Iteration number","code":""},{"path":"https://hiddevandebeek.github.io/admr/reference/timedIRMC.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Fit aggregate data using Iterative Reweighting with Monte Carlo updates — timedIRMC","text":"function uses Iterative Reweighting algorithm Monte Carlo sampling optimization. iteration, generates Monte Carlo samples updates parameter estimates using weighted importance sampling. algorithm continues convergence maximum number iterations reached.","code":""},{"path":"https://hiddevandebeek.github.io/admr/reference/timedIRMC.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fit aggregate data using Iterative Reweighting with Monte Carlo updates — timedIRMC","text":"","code":"# Load required libraries library(admr) library(rxode2) library(nlmixr2) library(dplyr) library(tidyr) library(mnorm)  # Load and prepare data data(examplomycin) examplomycin_wide <- examplomycin %>%   filter(EVID != 101) %>%   dplyr::select(ID, TIME, DV) %>%   pivot_wider(names_from = TIME, values_from = DV) %>%   dplyr::select(-c(1))  # Create aggregated data examplomycin_aggregated <- examplomycin_wide %>%   admr::meancov()  # Define RxODE model rxModel <- RxODE({   cp = linCmt(     cl,           # Clearance     v1,           # Volume of the central compartment     v2,           # Volume of the peripheral compartment     q,            # Inter-compartmental clearance     ka            # Absorption rate constant   ) }) #>   #>    # Define prediction function predder <- function(time, theta_i, dose = 100) {   n_individuals <- nrow(theta_i)   if (is.null(n_individuals)) n_individuals <- 1      ev <- eventTable(amount.units=\"mg\", time.units=\"hours\")   ev$add.dosing(dose = dose, nbr.doses = 1, start.time = 0)   ev$add.sampling(time)      out <- rxSolve(rxModel, params = theta_i, events = ev, cores = 0)   cp_matrix <- matrix(out$cp, nrow = n_individuals, ncol = length(time),                       byrow = TRUE)   return(cp_matrix) }  # Create options opts <- genopts(   time = c(.1, .25, .5, 1, 2, 3, 5, 8, 12),   p = list(     beta = c(cl = 5, v1 = 10, v2 = 30, q = 10, ka = 1),     Omega = matrix(c(0.09, 0, 0, 0, 0,                      0, 0.09, 0, 0, 0,                      0, 0, 0.09, 0, 0,                      0, 0, 0, 0.09, 0,                      0, 0, 0, 0, 0.09), nrow = 5, ncol = 5),     Sigma_prop = 0.04   ),   nsim = 2500,   n = 500,   fo_appr = FALSE,   omega_expansion = 1.2,   f = predder )  # Run optimization result <- timedIRMC(opts$pt, opts, examplomycin_aggregated) #> iteration 1, nll=-1839.57745407338 #> iteration 2, nll=-1845.23829291061 #> iteration 3, nll=-1845.28268771688 #> iteration 4, nll=-1845.28266696017 #> should break now due to no difference between OFV and appr OFV print(result) #> # A tibble: 4 × 5 #>   p             nll appr_nll time                 iter #>   <list>      <dbl>    <dbl> <dttm>              <dbl> #> 1 <dbl [11]> -1840.   -1840. 2025-04-03 13:33:49     1 #> 2 <dbl [11]> -1845.   -1845. 2025-04-03 13:33:50     2 #> 3 <dbl [11]> -1845.   -1845. 2025-04-03 13:33:51     3 #> 4 <dbl [11]> -1845.   -1845. 2025-04-03 13:33:51     4"},{"path":"https://hiddevandebeek.github.io/admr/reference/timedbobyqa.html","id":null,"dir":"Reference","previous_headings":"","what":"Fit aggregate data using the bobyqa algorithm with Monte Carlo updates — timedbobyqa","title":"Fit aggregate data using the bobyqa algorithm with Monte Carlo updates — timedbobyqa","text":"timedbobyqa implements bobyqa algorithm parameter estimation aggregate data models, iterating maximum likelihood updates Monte Carlo updates. iteration creates new Monte Carlo samples updates parameter values. function used compare performance different implementations aggregate data modeling.","code":""},{"path":"https://hiddevandebeek.github.io/admr/reference/timedbobyqa.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fit aggregate data using the bobyqa algorithm with Monte Carlo updates — timedbobyqa","text":"","code":"timedbobyqa(init, opts, obs, nomap = TRUE)"},{"path":"https://hiddevandebeek.github.io/admr/reference/timedbobyqa.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fit aggregate data using the bobyqa algorithm with Monte Carlo updates — timedbobyqa","text":"init Initial parameter values optimization. transformed parameters generated opts$pt. opts list model options generated genopts(). Contains settings model, including prediction function, time points, parameter structure, simulation settings. obs Observed data aggregate form (mean covariance) matrix raw data. nomap Logical indicating whether use multiple models (FALSE) single model (TRUE). Default TRUE.","code":""},{"path":"https://hiddevandebeek.github.io/admr/reference/timedbobyqa.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fit aggregate data using the bobyqa algorithm with Monte Carlo updates — timedbobyqa","text":"data frame containing: p: List parameter estimates iteration nll: Negative log-likelihood values time: Computation time iteration iter: Iteration number","code":""},{"path":"https://hiddevandebeek.github.io/admr/reference/timedbobyqa.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Fit aggregate data using the bobyqa algorithm with Monte Carlo updates — timedbobyqa","text":"function uses bobyqa algorithm optimx package optimization. performs Monte Carlo sampling iteration update parameter estimates. algorithm continues convergence maximum number iterations reached.","code":""},{"path":"https://hiddevandebeek.github.io/admr/reference/timedbobyqa.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fit aggregate data using the bobyqa algorithm with Monte Carlo updates — timedbobyqa","text":"","code":"# Load required libraries library(admr) library(rxode2) library(nlmixr2) library(dplyr) library(tidyr) library(mnorm)  # Load and prepare data data(examplomycin) examplomycin_wide <- examplomycin %>%   filter(EVID != 101) %>%   dplyr::select(ID, TIME, DV) %>%   pivot_wider(names_from = TIME, values_from = DV) %>%   dplyr::select(-c(1))  # Create aggregated data examplomycin_aggregated <- examplomycin_wide %>%   admr::meancov()  # Define RxODE model rxModel <- RxODE({   cp = linCmt(     cl,           # Clearance     v1,           # Volume of the central compartment     v2,           # Volume of the peripheral compartment     q,            # Inter-compartmental clearance     ka            # Absorption rate constant   ) }) #>   #>    # Define prediction function predder <- function(time, theta_i, dose = 100) {   n_individuals <- nrow(theta_i)   if (is.null(n_individuals)) n_individuals <- 1      ev <- eventTable(amount.units=\"mg\", time.units=\"hours\")   ev$add.dosing(dose = dose, nbr.doses = 1, start.time = 0)   ev$add.sampling(time)      out <- rxSolve(rxModel, params = theta_i, events = ev, cores = 0)   cp_matrix <- matrix(out$cp, nrow = n_individuals, ncol = length(time),                       byrow = TRUE)   return(cp_matrix) }  # Create options opts <- genopts(   time = c(.1, .25, .5, 1, 2, 3, 5, 8, 12),   p = list(     beta = c(cl = 5, v1 = 10, v2 = 30, q = 10, ka = 1),     Omega = matrix(c(0.09, 0, 0, 0, 0,                      0, 0.09, 0, 0, 0,                      0, 0, 0.09, 0, 0,                      0, 0, 0, 0.09, 0,                      0, 0, 0, 0, 0.09), nrow = 5, ncol = 5),     Sigma_prop = 0.04   ),   nsim = 2500,   n = 500,   fo_appr = FALSE,   omega_expansion = 1.2,   f = predder )  # Run optimization result <- timedbobyqa(opts$pt, opts, examplomycin_aggregated) #> Iteration: 50 - NLL: -1842.696  #> Iteration: 100 - NLL: -1844.712  #> Iteration: 150 - NLL: -1845.05  #> Iteration: 200 - NLL: -1845.218  #> Iteration: 250 - NLL: -1845.241  #> Iteration: 300 - NLL: -1845.254  #> Iteration: 350 - NLL: -1845.273  #> Iteration: 400 - NLL: -1845.281  #> Iteration: 450 - NLL: -1845.284  #> Iteration: 500 - NLL: -1845.288  #> Iteration: 550 - NLL: -1845.29  print(result) #> # A tibble: 565 × 4 #>    p             nll time                 iter #>    <list>      <dbl> <dttm>              <dbl> #>  1 <dbl [11]> -1840. 2025-04-03 13:33:52     1 #>  2 <dbl [11]> -1840. 2025-04-03 13:33:52     2 #>  3 <dbl [11]> -1840. 2025-04-03 13:33:52     3 #>  4 <dbl [11]> 14057. 2025-04-03 13:33:52     4 #>  5 <dbl [11]>  5029. 2025-04-03 13:33:53     5 #>  6 <dbl [11]>   227. 2025-04-03 13:33:53     6 #>  7 <dbl [11]>  -417. 2025-04-03 13:33:53     7 #>  8 <dbl [11]>  -413. 2025-04-03 13:33:53     8 #>  9 <dbl [11]> -1779. 2025-04-03 13:33:53     9 #> 10 <dbl [11]> -1800. 2025-04-03 13:33:53    10 #> # ℹ 555 more rows"},{"path":"https://hiddevandebeek.github.io/admr/news/index.html","id":"admr-010","dir":"Changelog","previous_headings":"","what":"admr 0.1.0","title":"admr 0.1.0","text":"Initial CRAN submission.","code":""}]
