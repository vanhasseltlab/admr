[{"path":"https://vanhasseltlab.github.io/admr/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2024 H. van de Beek Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://vanhasseltlab.github.io/admr/articles/admr.html","id":"introduction-to-aggregate-data-modeling-with-admr","dir":"Articles","previous_headings":"","what":"Introduction to Aggregate Data Modeling with admr","title":"Get started with admr","text":"vignette provides comprehensive introduction using admr package aggregate data modeling population pharmacokinetics. ’ll cover basic concepts, data preparation, model specification, make link advanced features.","code":""},{"path":"https://vanhasseltlab.github.io/admr/articles/admr.html","id":"what-is-aggregate-data-modeling","dir":"Articles","previous_headings":"Introduction to Aggregate Data Modeling with admr","what":"What is Aggregate Data Modeling?","title":"Get started with admr","text":"Aggregate data modeling new approach pharmacometrics allows work summary-level data instead individual-level observations. particularly useful : Individual-level data available (e.g., published literature) need combine data multiple studies want perform meta-analyses ’re working simulated data want reduce computational burden admr package implements Iterative Reweighting Monte Carlo (IRMC) algorithm, efficiently fits models aggregate data iteratively updating parameter estimates using weighted importance sampling. efficient traditional Monte Carlo methods.","code":""},{"path":"https://vanhasseltlab.github.io/admr/articles/admr.html","id":"required-packages","dir":"Articles","previous_headings":"Introduction to Aggregate Data Modeling with admr","what":"Required Packages","title":"Get started with admr","text":"first step load necessary packages:","code":"library(admr) library(rxode2) library(nlmixr2) library(dplyr) library(tidyr) library(mnorm) library(ggplot2)  # For visualization library(randtoolbox) library(units)"},{"path":"https://vanhasseltlab.github.io/admr/articles/admr.html","id":"understanding-the-data-format","dir":"Articles","previous_headings":"Introduction to Aggregate Data Modeling with admr","what":"Understanding the Data Format","title":"Get started with admr","text":"admr package works two types data formats: Raw Data: Individual-level observations wide long format. Aggregate Data: Summary statistics (mean covariance) computed raw data. Aggregate Data means variance: Mean variance time point (covariances). vignette Variance-based modelling provides details third option. Let’s look examplomycin dataset, ’ll use throughout vignette:","code":"# Load the dataset data(examplomycin) head(examplomycin) ##    ID TIME    DV AMT EVID CMT ## 1 460 0.00 0.000 100  101   1 ## 2 460 0.10 0.752   0    0   2 ## 3 460 0.25 1.932   0    0   2 ## 4 460 0.50 3.694   0    0   2 ## 5 460 1.00 3.479   0    0   2 ## 6 460 2.00 4.003   0    0   2 # Basic dataset information cat(\"Number of subjects:\", length(unique(examplomycin$ID)), \"\\n\") ## Number of subjects: 500 cat(\"Number of time points:\", length(unique(examplomycin$TIME)), \"\\n\") ## Number of time points: 10 cat(\"Time points:\", paste(sort(unique(examplomycin$TIME)), collapse = \", \"), \"\\n\") ## Time points: 0, 0.1, 0.25, 0.5, 1, 2, 3, 5, 8, 12"},{"path":[]},{"path":"https://vanhasseltlab.github.io/admr/articles/admr.html","id":"converting-raw-data-to-aggregate-format","dir":"Articles","previous_headings":"Introduction to Aggregate Data Modeling with admr > Data Preparation","what":"Converting Raw Data to Aggregate Format","title":"Get started with admr","text":"first step convert simulated raw data aggregate format. real-world scenarios, might extract summary statistics published studies, depending available information. example, ’ll compute mean covariance examplomycin dataset. ’s : aggregated data now contains mean concentrations covariance matrix time point. raw data, can use meancov function compute statistics. However, extracting data literature, may need manually input means covariances based reported values. standard deviations available, can construct diagonal covariance matrix.","code":"# Convert to wide format examplomycin_wide <- examplomycin %>%   filter(EVID != 101) %>%  # Remove dosing events   dplyr::select(ID, TIME, DV) %>%  # Select relevant columns   pivot_wider(names_from = TIME, values_from = DV) %>%  # Convert to wide format   dplyr::select(-c(1))  # Remove ID column  # Create aggregated data examplomycin_aggregated <- examplomycin_wide %>%   admr::meancov()  # Compute mean and covariance  # View the structure of aggregated data str(examplomycin_aggregated) ## List of 2 ##  $ E: Named num [1:9] 0.966 1.939 2.788 3.025 2.258 ... ##   ..- attr(*, \"names\")= chr [1:9] \"0.1\" \"0.25\" \"0.5\" \"1\" ... ##  $ V: num [1:9, 1:9] 0.2103 0.3078 0.3486 0.2026 0.0224 ... ##   ..- attr(*, \"dimnames\")=List of 2 ##   .. ..$ : chr [1:9] \"0.1\" \"0.25\" \"0.5\" \"1\" ... ##   .. ..$ : chr [1:9] \"0.1\" \"0.25\" \"0.5\" \"1\" ..."},{"path":"https://vanhasseltlab.github.io/admr/articles/admr.html","id":"visualizing-the-data","dir":"Articles","previous_headings":"Introduction to Aggregate Data Modeling with admr > Data Preparation","what":"Visualizing the Data","title":"Get started with admr","text":"fitting model, ’s helpful visualize aggregate data:  plot doesn’t show covariance time points, gives idea variability concentrations time point.","code":"# Boxplot to visualize variability ggplot(examplomycin, aes(x = TIME, y = DV, group = TIME)) +   geom_boxplot(aes(group = TIME), width = 0.2) +   labs(     title = \"Concentration Variability at Each Time Point\",     x = \"Time (hours)\",     y = \"Concentration (mg/L)\"   ) +   theme_minimal()"},{"path":[]},{"path":"https://vanhasseltlab.github.io/admr/articles/admr.html","id":"defining-the-pharmacokinetic-model","dir":"Articles","previous_headings":"Introduction to Aggregate Data Modeling with admr > Model Specification","what":"Defining the Pharmacokinetic Model","title":"Get started with admr","text":"’ll use two-compartment model first-order absorption. two ways specify : Using differential equations: Using solved model approach (simpler): models identical terms pharmacokinetic behavior. second approach solved model, faster execution. stage package development, important parameters order specified genopts function later.","code":"rxModel <- function(){   model({   # Parameters   ke = cl / v1             # Elimination rate constant   k12 = q / v1             # Rate constant for central to peripheral transfer   k21 = q / v2             # Rate constant for peripheral to central transfer      # Differential equations   d/dt(depot)    = -ka * depot   d/dt(central)  = ka * depot - ke * central - k12 * central + k21 * peripheral   d/dt(peripheral) = k12 * central - k21 * peripheral      # Concentration in central compartment   cp = central / v1   }) }  rxModel <- rxode2(rxModel) rxModel <- rxModel$simulationModel # Define RxODE model rxModel <- function(){   model({     cp = linCmt(       cl,           # Clearance       v1,           # Volume of central compartment       v2,           # Volume of peripheral compartment       q,            # Inter-compartmental clearance       ka            # Absorption rate constant     )}) }  rxModel <- rxode2(rxModel) rxModel <- rxModel$simulationModel"},{"path":"https://vanhasseltlab.github.io/admr/articles/admr.html","id":"creating-the-prediction-function","dir":"Articles","previous_headings":"Introduction to Aggregate Data Modeling with admr > Model Specification","what":"Creating the Prediction Function","title":"Get started with admr","text":"prediction function crucial admr package. : - Constructs event table dosing sampling - Solves rxode2 model - Returns predicted concentrations required format function admr use generate predictions based model parameters. user can specify dose amount, number doses dosing interval eventTable function. Furthermore, rxSolve function can parallelized setting cores argument value greater 1, can significantly speed computations large datasets complex models.","code":"rxode2::rxSetSilentErr(1) # does not print iteration messages in vignette ## [1] TRUE predder <- function(time, theta_i, dose = 100) {     n_individuals <- nrow(theta_i)          if (is.null(n_individuals)) {       n_individuals <- 1     }      # Create event table     ev <- eventTable(amount.units=\"mg\", time.units=\"hours\")     ev$add.dosing(dose = dose, nbr.doses = 1, start.time = 0)     ev$add.sampling(time)          # Solve model     out <- rxSolve(rxModel, params = theta_i, events = ev, cores = 0)          # Format output     cp_matrix <- matrix(out$cp, nrow = n_individuals, ncol = length(time),                          byrow = TRUE)          return(cp_matrix) }"},{"path":[]},{"path":"https://vanhasseltlab.github.io/admr/articles/admr.html","id":"setting-up-model-options","dir":"Articles","previous_headings":"Introduction to Aggregate Data Modeling with admr > Model Fitting","what":"Setting Up Model Options","title":"Get started with admr","text":"genopts function creates options object controls model fitting process: opts object: time: Specifies observation times p: Contains initial estimates population parameters (beta), -subject variability (Omega), residual error (Sigma_prop) nsim: Number Monte Carlo samples use fitting process n: Number individuals simulate fo_appr: Whether use first-order approximation omega_expansion: factor expand covariance matrix estimation, can help convergence f: prediction function defined earlier","code":"opts <- genopts(   time = c(.1, .25, .5, 1, 2, 3, 5, 8, 12),  # Observation times   p = list(     beta = c(cl = 4, v1 = 12, v2 = 25, q = 12, ka = 1.2),  # Population parameters     Omega = matrix(c(0.09, 0, 0, 0, 0,                      0, 0.09, 0, 0, 0,                      0, 0, 0.09, 0, 0,                      0, 0, 0, 0.09, 0,                      0, 0, 0, 0, 0.09), nrow = 5, ncol = 5),  # Random effects     Sigma_prop = 0.04  # Proportional error   ),   nsim = 10000,  # Number of Monte Carlo samples   n = 500,      # Number of individuals   fo_appr = F,  # Disable first-order approximation used in lower nsim   omega_expansion = 1,  # Omega expansion factor   f = predder    # Prediction function we defined earlier )"},{"path":"https://vanhasseltlab.github.io/admr/articles/admr.html","id":"fitting-the-model","dir":"Articles","previous_headings":"Introduction to Aggregate Data Modeling with admr > Model Fitting","what":"Fitting the Model","title":"Get started with admr","text":"fitMC function fits model using traditional MC algorithm: fitIRMC function fits model using IRMC algorithm, efficient aggregate data:","code":"fit.admrMC <- fitMC(   opts = opts,   obs = examplomycin_aggregated,   chains = 1,  # Number of chains   maxiter = 2000,  # Maximum iterations   use_grad = T ) ## Iteration: 5 - NLL: 16801.59  ## Iteration: 10 - NLL: -1840.397  ## Iteration: 15 - NLL: -1844.982  ## Iteration: 20 - NLL: -1845.272  ## Iteration: 25 - NLL: -1845.317  ## Iteration: 30 - NLL: -1845.341  ## Iteration: 35 - NLL: -1845.355  ## Iteration: 40 - NLL: -1845.357  ##  ## Chain 1 Complete: Final NLL = -1845.357, Time Elapsed = 62.50 seconds fit.admr <- admr::fitIRMC(   opts = opts,   obs = examplomycin_aggregated,   chains = 1,  # Number of chains   maxiter = 200,  # Maximum iterations   use_grad = T ) ## Chain 1: ## Iter | NLL and Parameters (11 values) ## -------------------------------------------------------------------------------- ##    1: -1587.397    1.386    2.485    3.219    2.485    0.182   -2.408   -2.408   -2.408   -2.408   -2.408   -3.219 ##  ## ### Wide Search Phase ### ##    2: -1844.307    1.605    2.273    3.425    2.276   -0.014   -2.201   -2.213   -2.203   -2.271   -2.416   -3.236 ##    3: -1845.352    1.601    2.311    3.403    2.285    0.021   -2.285   -2.206   -2.346   -2.247   -2.399   -3.235 ##    4: -1845.353    1.601    2.312    3.403    2.284    0.021   -2.284   -2.206   -2.346   -2.247   -2.399   -3.235 ##    5: -1845.353    1.601    2.312    3.403    2.284    0.021   -2.284   -2.206   -2.345   -2.247   -2.399   -3.235 ##    6: -1845.353    1.601    2.312    3.403    2.284    0.021   -2.284   -2.206   -2.345   -2.247   -2.399   -3.235 ##    7: -1845.353    1.601    2.312    3.403    2.284    0.021   -2.284   -2.206   -2.345   -2.246   -2.399   -3.235 ##    8: -1845.353    1.601    2.312    3.403    2.284    0.021   -2.283   -2.206   -2.345   -2.246   -2.399   -3.235 ##    9: -1845.353    1.601    2.312    3.403    2.284    0.022   -2.283   -2.206   -2.344   -2.246   -2.399   -3.235 ##   10: -1845.353    1.601    2.312    3.403    2.284    0.022   -2.283   -2.206   -2.344   -2.246   -2.399   -3.235 ##   11: -1845.353    1.601    2.317    3.401    2.285    0.026   -2.283   -2.209   -2.337   -2.236   -2.396   -3.235 ##   12: -1845.353    1.601    2.317    3.401    2.285    0.026   -2.282   -2.209   -2.337   -2.236   -2.396   -3.235 ## Phase Wide Search Phase converged at iteration 12. ##  ## ### Focussed Search Phase ### ##   13: -1845.353    1.601    2.317    3.401    2.285    0.026   -2.282   -2.209   -2.337   -2.236   -2.396   -3.235 ##   14: -1845.353    1.601    2.317    3.401    2.285    0.026   -2.282   -2.210   -2.338   -2.236   -2.396   -3.235 ##   15: -1845.353    1.601    2.317    3.401    2.285    0.026   -2.282   -2.210   -2.338   -2.236   -2.396   -3.235 ##   16: -1845.353    1.601    2.317    3.401    2.285    0.026   -2.282   -2.210   -2.338   -2.236   -2.396   -3.235 ## Phase Focussed Search Phase converged at iteration 16. ##  ## ### Fine-Tuning Phase ### ##   17: -1845.353    1.601    2.317    3.401    2.285    0.026   -2.282   -2.210   -2.338   -2.236   -2.396   -3.235 ##   18: -1845.353    1.601    2.317    3.401    2.285    0.026   -2.282   -2.210   -2.338   -2.236   -2.395   -3.235 ##   19: -1845.353    1.601    2.317    3.401    2.285    0.026   -2.282   -2.210   -2.338   -2.236   -2.395   -3.235 ##   20: -1845.353    1.601    2.317    3.401    2.285    0.026   -2.282   -2.210   -2.338   -2.236   -2.395   -3.235 ##   21: -1845.353    1.601    2.317    3.401    2.285    0.026   -2.282   -2.210   -2.338   -2.236   -2.395   -3.235 ##   22: -1845.353    1.601    2.317    3.401    2.285    0.026   -2.282   -2.210   -2.338   -2.236   -2.395   -3.235 ##   23: -1845.353    1.601    2.317    3.401    2.285    0.026   -2.282   -2.210   -2.338   -2.236   -2.395   -3.235 ##   24: -1845.353    1.601    2.317    3.401    2.285    0.026   -2.282   -2.210   -2.338   -2.236   -2.395   -3.235 ##   25: -1845.353    1.601    2.317    3.401    2.285    0.026   -2.282   -2.211   -2.338   -2.236   -2.395   -3.235 ##   26: -1845.353    1.601    2.317    3.401    2.285    0.026   -2.282   -2.211   -2.338   -2.236   -2.395   -3.235 ##   27: -1845.353    1.601    2.317    3.401    2.285    0.026   -2.282   -2.211   -2.338   -2.236   -2.395   -3.235 ## Phase Fine-Tuning Phase converged at iteration 27. ##  ## ### Precision Phase ### ##   28: -1845.353    1.601    2.317    3.401    2.285    0.026   -2.282   -2.211   -2.338   -2.236   -2.395   -3.235 ## Phase Precision Phase converged at iteration 28. ##  ## Chain 1 Complete: Final NLL = -1845.353, Time Elapsed = 16.92 seconds ##"},{"path":[]},{"path":"https://vanhasseltlab.github.io/admr/articles/admr.html","id":"basic-diagnostics","dir":"Articles","previous_headings":"Introduction to Aggregate Data Modeling with admr > Model Diagnostics","what":"Basic Diagnostics","title":"Get started with admr","text":"print method provides summary model fit:","code":"print(fit.admr) ## -- FitIRMC Summary -- ##  ## -- Objective Function and Information Criteria -- ##  Log-likelihood: -1845.3535 ##             AIC: 3701.71 ##             BIC: 3759.07 ## Condition#(Cov): 150.83 ## Condition#(Cor): 214.64 ##  ## -- Timing Information -- ##      Best Chain: 16.9177 seconds ##      All Chains: 16.9201 seconds ##      Covariance: 20.5840 seconds ##         Elapsed: 37.50 seconds ##  ## -- Population Parameters -- ## # A tibble: 6 × 6 ##   Parameter        Est.      SE  `%RSE` `Back-transformed(95%CI)` `BSV(CV%)` ##   <chr>           <dbl>   <dbl>   <dbl> <chr>                          <dbl> ## 1 cl             1.60    0.0152   0.950 4.96 (4.81, 5.11)               31.9 ## 2 v1             2.32    0.0861   3.71  10.15 (8.57, 12.01)             33.1 ## 3 v2             3.40    0.0399   1.17  30.00 (27.74, 32.45)            31.1 ## 4 q              2.29    0.0212   0.928 9.83 (9.43, 10.24)              32.7 ## 5 ka             0.0263  0.0813 309.    1.03 (0.88, 1.20)               30.2 ## 6 Residual Error 0.0394 NA       NA     0.0394                          NA   ##  ## -- Iteration Diagnostics -- ##  Iter | NLL and Parameters ## -------------------------------------------------------------------------------- ##    1: -1587.397 1.386 2.485 3.219 2.485 0.182 -2.408 -2.408 -2.408 -2.408 -2.408 -3.219 ##    2: -1844.307 1.605 2.273 3.425 2.276 -0.014 -2.201 -2.213 -2.203 -2.271 -2.416 -3.236 ##    3: -1845.352 1.601 2.311 3.403 2.285 0.021 -2.285 -2.206 -2.346 -2.247 -2.399 -3.235 ##    4: -1845.353 1.601 2.312 3.403 2.284 0.021 -2.284 -2.206 -2.346 -2.247 -2.399 -3.235 ##    5: -1845.353 1.601 2.312 3.403 2.284 0.021 -2.284 -2.206 -2.345 -2.247 -2.399 -3.235 ##    ... (omitted iterations) ... ##   24: -1845.353 1.601 2.317 3.401 2.285 0.026 -2.282 -2.210 -2.338 -2.236 -2.395 -3.235 ##   25: -1845.353 1.601 2.317 3.401 2.285 0.026 -2.282 -2.211 -2.338 -2.236 -2.395 -3.235 ##   26: -1845.353 1.601 2.317 3.401 2.285 0.026 -2.282 -2.211 -2.338 -2.236 -2.395 -3.235 ##   27: -1845.353 1.601 2.317 3.401 2.285 0.026 -2.282 -2.211 -2.338 -2.236 -2.395 -3.235 ##   28: -1845.353 1.601 2.317 3.401 2.285 0.026 -2.282 -2.211 -2.338 -2.236 -2.395 -3.235"},{"path":"https://vanhasseltlab.github.io/admr/articles/admr.html","id":"convergence-assessment","dir":"Articles","previous_headings":"Introduction to Aggregate Data Modeling with admr > Model Diagnostics","what":"Convergence Assessment","title":"Get started with admr","text":"plot method visualizes convergence model fit:  Observed vs Predicted plot shows well model predictions align observed aggregate data. show good fit data, means variability well captured. However, let’s examine parameter estimates detailed assessment. predicted means variance-covariance show good resemblance observed data, indicating model capturing underlying pharmacokinetic behavior effectively.","code":"plot(fit.admr)"},{"path":"https://vanhasseltlab.github.io/admr/articles/admr.html","id":"parameter-estimates","dir":"Articles","previous_headings":"Introduction to Aggregate Data Modeling with admr > Model Diagnostics","what":"Parameter Estimates","title":"Get started with admr","text":"Let’s examine parameter estimates: dataset, estimated parameters close true values used simulation, indicating successful model fit using summary statistics. However, small discrepancies can occur due stochastic nature Monte Carlo sampling limited number samples. Therefore, ’ll assess overall dynamics model dosing simulation.","code":"# Extract parameter estimates params <- fit.admr$transformed_params cat(\"Final parameter estimates:\\n\") ## Final parameter estimates: print(params) ## $beta ##        cl        v1        v2         q        ka  ##  4.958566 10.145764 30.003901  9.827655  1.026681  ##  ## $Omega ##           [,1]      [,2]      [,3]      [,4]       [,5] ## [1,] 0.1020431 0.0000000 0.0000000 0.0000000 0.00000000 ## [2,] 0.0000000 0.1096415 0.0000000 0.0000000 0.00000000 ## [3,] 0.0000000 0.0000000 0.0965136 0.0000000 0.00000000 ## [4,] 0.0000000 0.0000000 0.0000000 0.1068517 0.00000000 ## [5,] 0.0000000 0.0000000 0.0000000 0.0000000 0.09118536 ##  ## $Sigma_prop ## [1] 0.03935747 params.true <- list(   beta = c(cl = 5, v1 = 10, v2 = 30, q = 10, ka = 1),   Omega = diag(rep(0.09, 5)),   Sigma_prop = 0.04 )  cat(\"True parameter values:\\n\") ## True parameter values: print(params.true) ## $beta ## cl v1 v2  q ka  ##  5 10 30 10  1  ##  ## $Omega ##      [,1] [,2] [,3] [,4] [,5] ## [1,] 0.09 0.00 0.00 0.00 0.00 ## [2,] 0.00 0.09 0.00 0.00 0.00 ## [3,] 0.00 0.00 0.09 0.00 0.00 ## [4,] 0.00 0.00 0.00 0.09 0.00 ## [5,] 0.00 0.00 0.00 0.00 0.09 ##  ## $Sigma_prop ## [1] 0.04"},{"path":"https://vanhasseltlab.github.io/admr/articles/admr.html","id":"dosing-plot-with-confidence-intervals-for-true-vs-estimated-parameters","dir":"Articles","previous_headings":"Introduction to Aggregate Data Modeling with admr > Model Diagnostics","what":"Dosing plot with Confidence Intervals for true vs estimated parameters","title":"Get started with admr","text":"First, let’s specify two models: one true parameters another estimated parameters fit.admr object. Now, let’s simulate models dosing regimen plot results confidence intervals:  can see model estimated parameters closely follows dynamics model true parameters, indicating admr package can effectively recover population parameters aggregate data. small differences 95% population associated confidence intervals, showing slight overestimation random effects. However, overall dynamics well captured.","code":"params.true <- list(   beta = c(cl = 5, v1 = 10, v2 = 30, q = 10, ka = 1),   Omega = diag(rep(0.09, 5)),   Sigma_prop = 0.04 ) params <- fit.admr$transformed_params  rxModel_true <- function(){   ini({     cl <- params.true$beta[\"cl\"]  # Clearance     v1 <- params.true$beta[\"v1\"]  # Volume of central compartment     v2 <- params.true$beta[\"v2\"] # Volume of peripheral compartment     q <- params.true$beta[\"q\"]    # Inter-compartmental clearance     ka <- params.true$beta[\"ka\"]   # Absorption rate constant      eta_cl ~ params.true$Omega[1,1]     eta_v1 ~ params.true$Omega[2,2]     eta_v2 ~ params.true$Omega[3,3]     eta_q ~ params.true$Omega[4,4]     eta_ka ~ params.true$Omega[5,5]   })   model({     cl <- cl * exp(eta_cl)     v1 <- v1 * exp(eta_v1)     v2 <- v2 * exp(eta_v2)     q <- q * exp(eta_q)     ka <- ka * exp(eta_ka)     cp = linCmt(cl, v1, v2, q, ka)   }) }  rxModel_covar <- function(){   ini({     cl <- params$beta[\"cl\"]  # Clearance     v1 <- params$beta[\"v1\"]  # Volume of central compartment     v2 <- params$beta[\"v2\"] # Volume of peripheral compartment     q <- params$beta[\"q\"]    # Inter-compartmental clearance     ka <- params$beta[\"ka\"]   # Absorption rate constant      eta_cl ~ params$Omega[1,1]     eta_v1 ~ params$Omega[2,2]     eta_v2 ~ params$Omega[3,3]     eta_q ~ params$Omega[4,4]     eta_ka ~ params$Omega[5,5]   })   model({     cl <- cl * exp(eta_cl)     v1 <- v1 * exp(eta_v1)     v2 <- v2 * exp(eta_v2)     q <- q * exp(eta_q)     ka <- ka * exp(eta_ka)     cp = linCmt(cl, v1, v2, q, ka)   }) }  rxModel_true <- rxode2(rxModel_true()) rxModel_true <- rxModel_true$simulationModel ## using C compiler: ‘gcc (Ubuntu 13.3.0-6ubuntu2~24.04) 13.3.0’ rxModel_covar <- rxode2(rxModel_covar()) rxModel_covar <- rxModel_covar$simulationModel time_points <- seq(0, 12, by = 0.1)  # Dense time points for smooth curves ev <- eventTable(amount.units=\"mg\", time.units=\"hours\") ev$add.dosing(dose = 100, nbr.doses = 2, dosing.interval = 6) ev$add.sampling(time_points)  sim_true <- rxSolve(rxModel_true, events = ev, cores = 0, nSub = 10000) sim_covar <- rxSolve(rxModel_covar, events = ev, cores = 0, nSub = 10000)  # Combine the confidence intervals with a label for the model ci_true <- as.data.frame(confint(sim_true, \"cp\", level=0.95)) %>%   mutate(Model = \"True parameters\") ## summarizing data...done ci_covar <- as.data.frame(confint(sim_covar, \"cp\", level=0.95)) %>%   mutate(Model = \"Estimated model\") ## summarizing data...done # Bind them together ci_all <- bind_rows(ci_true, ci_covar) %>%   mutate(     p1 = as.numeric(as.character(p1)),     Percentile = factor(Percentile, levels = unique(Percentile[order(p1)]))   )  # Plot both models ggplot(ci_all, aes(x = time, group = interaction(Model, Percentile))) +   geom_ribbon(aes(ymin = p2.5, ymax = p97.5, fill = Model),               alpha = 0.2, colour = NA) +   geom_line(aes(y = p50, colour = Model), size = 0.8) +   labs(     title = \"Central Concentration Simulations\",     x = \"Time\",     y = \"Central Concentration (mg/L)\"   ) +   theme_bw(base_size = 14) +   scale_colour_manual(values = c(\"True parameters\" = \"blue\",                                  \"Estimated model\" = \"red\")) +   scale_fill_manual(values = c(\"True parameters\" = \"blue\",                                \"Estimated model\" = \"red\")) ## Warning: Using `size` aesthetic for lines was deprecated in ggplot2 3.4.0. ## ℹ Please use `linewidth` instead. ## This warning is displayed once every 8 hours. ## Call `lifecycle::last_lifecycle_warnings()` to see where this warning was ## generated."},{"path":"https://vanhasseltlab.github.io/admr/articles/admr.html","id":"best-practices","dir":"Articles","previous_headings":"Introduction to Aggregate Data Modeling with admr","what":"Best Practices","title":"Get started with admr","text":"Always check data missing values outliers Ensure time points consistent across subjects Consider impact dosing events analysis Start simple model gradually add complexity Use meaningful initial values parameters Consider parameter transformations better estimation Use multiple chains improve optimization Monitor convergence carefully Check parameter estimates biological plausibility Always examine convergence plots Validate model predictions observed data","code":""},{"path":"https://vanhasseltlab.github.io/admr/articles/admr.html","id":"next-steps","dir":"Articles","previous_headings":"Introduction to Aggregate Data Modeling with admr","what":"Next Steps","title":"Get started with admr","text":"mastering basics, might want explore: Adjusting Monte Carlo sample size Residual analysis Parameter initial sensitivity analysis Model comparison information, see package documentation vignettes.","code":""},{"path":"https://vanhasseltlab.github.io/admr/articles/examplomycin.html","id":"creating-the-examplomycin-dataset","dir":"Articles","previous_headings":"","what":"Creating the Examplomycin Dataset","title":"Examplomycin dataset: a pharmacokinetic example","text":"vignette demonstrates create simulated pharmacokinetic dataset fictional drug called examplomycin. dataset designed showcase capabilities admr package aggregate data modeling.","code":""},{"path":"https://vanhasseltlab.github.io/admr/articles/examplomycin.html","id":"overview","dir":"Articles","previous_headings":"Creating the Examplomycin Dataset","what":"Overview","title":"Examplomycin dataset: a pharmacokinetic example","text":"examplomycin dataset simulated pharmacokinetic study following characteristics: - 500 healthy subjects - Single oral dose 100 mg - 9 sampling time points per subject - Two-compartment model first-order absorption - Random effects parameters - Proportional residual error","code":""},{"path":"https://vanhasseltlab.github.io/admr/articles/examplomycin.html","id":"required-packages","dir":"Articles","previous_headings":"Creating the Examplomycin Dataset","what":"Required Packages","title":"Examplomycin dataset: a pharmacokinetic example","text":"necessary R packages data generation manipulation loaded :","code":"library(rxode2) library(MASS) library(ggplot2) library(nlmixr2) library(data.table) library(dplyr) library(ggplot2) library(usethis) library(units)"},{"path":"https://vanhasseltlab.github.io/admr/articles/examplomycin.html","id":"data-generation-function","dir":"Articles","previous_headings":"Creating the Examplomycin Dataset","what":"Data Generation Function","title":"Examplomycin dataset: a pharmacokinetic example","text":"generate_data function creates examplomycin dataset following features: Two-compartment model first-order absorption Log-normal random effects parameters Proportional residual error Standardized sampling schedule nlmixr2-compatible data format","code":"generate_data <- function(n, times, seed = 1) {   set.seed(seed)      # Define the pharmacokinetic model   mod <- function(){     model({     # Parameters     ke = cl / v1             # Elimination rate constant     k12 = q / v1             # Rate constant for central to peripheral transfer     k21 = q / v2             # Rate constant for peripheral to central transfer          # Differential equations for drug amount in compartments     d/dt(depot)    = -ka * depot     d/dt(central)  = ka * depot - ke * central -        k12 * central +        k21 * peripheral     d/dt(peripheral) = k12 * central -        k21 * peripheral          # Concentration in the central compartment     cp = central / v1     })    }      mod <- rxode2(mod)   mod <- mod$simulationModel    # Population parameters   theta <- c(cl = 5, v1 = 10, v2 = 30, q = 10, ka = 1)    # Correlation matrix for random effects   omegaCor <- matrix(c(1,  0,  0,  0,  0,                        0,  1,  0,  0,  0,                        0,  0,  1,  0,  0,                        0,  0,  0,  1,  0,                        0,  0,  0,  0,  1),                       dimnames = list(NULL, c(\"eta.cl\", \"eta.v1\", \"eta.v2\", \"eta.q\",                                             \"eta.ka\")), nrow = 5)    # Standard deviations of random effects   iiv.sd <- c(0.3, 0.3, 0.3, 0.3, 0.3)    # Create covariance matrix   iiv <- iiv.sd %*% t(iiv.sd)   omega <- iiv * omegaCor    # Generate random effects   mv <- mvrnorm(n, rep(0, dim(omega)[1]), omega)    # Create individual parameters   params.all <-     data.table(       \"ID\" = seq(1:n),       \"cl\" = theta['cl'] * exp(mv[, 1]),       \"v1\" = theta['v1'] * exp(mv[, 2]),       \"v2\" = theta['v2'] * exp(mv[, 3]),       \"q\"  = theta['q']  * exp(mv[, 4]),       \"ka\" = theta['ka'] * exp(mv[, 5])     )    # Create event table   ev <- et() %>%     et(amt = 100) %>%  # Single dose     et(0) %>%  # Initial time point     et(times) %>%  # Sampling schedule     et(ID = seq(1, n)) %>%  # Subject IDs     as.data.frame()    # Solve the model   sim <- rxSolve(mod, events = ev, iCov = params.all, cores = 0, addCov = T) %>%     mutate(ID = as.integer(id), TIME = as.numeric(time)) %>%     dplyr::select(-c(id, time)) %>%     mutate(AMT = ifelse(TIME == 0, 100, 0)) %>%     mutate(EVID = ifelse(TIME == 0, 101, 0)) %>%     mutate(CMT = ifelse(TIME == 0, 1, 2))    # Add residual error   sim$rv <- rnorm(nrow(sim), 0, 0.2)   sim$DV <- round(sim$cp * (1 + sim$rv), 3)   sim <- merge(sim, params.all)    # Select final columns   dat <- sim %>%     dplyr::select(\"ID\", \"TIME\", \"DV\", \"AMT\", \"EVID\", \"CMT\")    return(dat) }"},{"path":"https://vanhasseltlab.github.io/admr/articles/examplomycin.html","id":"generating-the-dataset","dir":"Articles","previous_headings":"Creating the Examplomycin Dataset","what":"Generating the Dataset","title":"Examplomycin dataset: a pharmacokinetic example","text":"’ll generate examplomycin dataset : - 500 subjects - 9 time points (0.1, 0.25, 0.5, 1, 2, 3, 5, 8, 12 hours) - Random seed reproducibility","code":"examplomycin <- generate_data(   n = 500,  # Number of subjects   times = c(.1, .25, .5, 1, 2, 3, 5, 8, 12),  # Sampling times   seed = 1  # Random seed ) ## ℹ parameter labels from comments are typically ignored in non-interactive mode ## ℹ Need to run with the source intact to parse comments head(examplomycin) ##    ID TIME    DV AMT EVID CMT ## 1 460 0.00 0.000 100  101   1 ## 2 460 0.10 0.752   0    0   2 ## 3 460 0.25 1.932   0    0   2 ## 4 460 0.50 3.694   0    0   2 ## 5 460 1.00 3.479   0    0   2 ## 6 460 2.00 4.003   0    0   2"},{"path":"https://vanhasseltlab.github.io/admr/articles/examplomycin.html","id":"saving-the-dataset","dir":"Articles","previous_headings":"Creating the Examplomycin Dataset","what":"Saving the Dataset","title":"Examplomycin dataset: a pharmacokinetic example","text":"dataset saved package data object use vignettes examples:","code":""},{"path":"https://vanhasseltlab.github.io/admr/articles/examplomycin.html","id":"visualizing-the-dataset","dir":"Articles","previous_headings":"Creating the Examplomycin Dataset","what":"Visualizing the Dataset","title":"Examplomycin dataset: a pharmacokinetic example","text":"’ll create concentration-time plot visualize simulated data:","code":"# Create concentration-time plot ggplot(examplomycin, aes(x = TIME, y = DV, color = factor(ID))) +   geom_line(alpha = 0.7) +    # Connect points with lines   geom_point(size = 2, alpha = 0.8) +  # Add observation points   scale_color_viridis_d(name = \"Subject ID\") +  # Color by subject   labs(     title = \"Concentration-Time Profile\",     x = \"Time (hours)\",     y = \"Observed Concentration (DV)\"   ) +   theme_minimal() +   theme(legend.position = \"none\")  # Hide legend for clarity"},{"path":"https://vanhasseltlab.github.io/admr/articles/examplomycin.html","id":"dataset-structure","dir":"Articles","previous_headings":"Creating the Examplomycin Dataset","what":"Dataset Structure","title":"Examplomycin dataset: a pharmacokinetic example","text":"examplomycin dataset contains following columns: ID: Subject identifier TIME: Observation time (hours) DV: Observed concentration AMT: Dose amount (100 mg NA) EVID: Event type (101 dose, 0 observation) CMT: Compartment number (1 depot, 2 central) dataset serves realistic example demonstrating aggregate data modeling techniques admr package.","code":""},{"path":"https://vanhasseltlab.github.io/admr/articles/multiple.html","id":"introduction-to-aggregate-data-modeling-with-admr","dir":"Articles","previous_headings":"","what":"Introduction to Aggregate Data Modeling with admr","title":"Combining multiple datasets with admr","text":"vignette provides introduction using multiple datasets admr package R. example combine different datasets non-overlapping timepoints. However, principles can applied datasets overlapping timepoints; even datasets different dosing regimens. Therefore, vignette can used guide meta-analysis pharmacokinetic data. research currently conducted validate approach meta-analysis model averaging.","code":""},{"path":"https://vanhasseltlab.github.io/admr/articles/multiple.html","id":"required-packages","dir":"Articles","previous_headings":"Introduction to Aggregate Data Modeling with admr","what":"Required Packages","title":"Combining multiple datasets with admr","text":"First, ensure necessary packages loaded:","code":"library(admr) library(rxode2) library(nlmixr2) library(dplyr) library(tidyr) library(mnorm) library(ggplot2)  # For visualization library(units)"},{"path":"https://vanhasseltlab.github.io/admr/articles/multiple.html","id":"understanding-the-data-format","dir":"Articles","previous_headings":"Introduction to Aggregate Data Modeling with admr","what":"Understanding the Data Format","title":"Combining multiple datasets with admr","text":"admr package works two types data formats: Raw Data: Individual-level observations wide long format. Aggregate Data: Summary statistics (mean covariance) computed raw data. Aggregate Data means variance: Mean variance time point (covariances). vignette Variance-based modelling provides details third option. Let’s look simulated examplomycin dataset, ’ll use throughout vignette:","code":"# Load the dataset data(examplomycin) head(examplomycin) ##    ID TIME    DV AMT EVID CMT ## 1 460 0.00 0.000 100  101   1 ## 2 460 0.10 0.752   0    0   2 ## 3 460 0.25 1.932   0    0   2 ## 4 460 0.50 3.694   0    0   2 ## 5 460 1.00 3.479   0    0   2 ## 6 460 2.00 4.003   0    0   2 # Basic dataset information cat(\"Number of subjects:\", length(unique(examplomycin$ID)), \"\\n\") ## Number of subjects: 500 cat(\"Number of time points:\", length(unique(examplomycin$TIME)), \"\\n\") ## Number of time points: 10 cat(\"Time points:\", paste(sort(unique(examplomycin$TIME)), collapse = \", \"), \"\\n\") ## Time points: 0, 0.1, 0.25, 0.5, 1, 2, 3, 5, 8, 12"},{"path":[]},{"path":"https://vanhasseltlab.github.io/admr/articles/multiple.html","id":"converting-raw-data-to-aggregate-format","dir":"Articles","previous_headings":"Introduction to Aggregate Data Modeling with admr > Data Preparation","what":"Converting Raw Data to Aggregate Format","title":"Combining multiple datasets with admr","text":"first step convert simulated raw data aggregate format. real-world scenarios, might extract summary statistics published studies, depending available information. example, ’ll compute mean covariance examplomycin dataset. ’s : illustrate use multiple datasets, ’ll split data two groups based timepoints: one group timepoints 0.1, 0.25, 0.5, 1 hour; another group timepoints 2, 3, 5, 8, 12 hours. illustrates use dataset absorption phase data dataset elimination phase data. create aggregated data group separately: Compared full aggregated dataset, datasets contains subset timepoints. means covariances timepoints different datasets available, effectively reducing information content. However, admr package can still handle situation effectively.","code":"# Convert to wide format examplomycin_wide <- examplomycin %>%   filter(EVID != 101) %>%  # Remove dosing events   dplyr::select(ID, TIME, DV) %>%  # Select relevant columns   pivot_wider(names_from = TIME, values_from = DV) %>%  # Convert to wide format   dplyr::select(-c(1))  # Remove ID column # Create aggregated data and filter timepoints 1 to 4 examplomycin_aggregated1 <- examplomycin_wide %>%   dplyr::select(c(1:4)) %>%   meancov()  examplomycin_aggregated2 <- examplomycin_wide %>%   dplyr::select(c(5:9)) %>%   meancov()    # View the structure of aggregated data str(examplomycin_aggregated1) ## List of 2 ##  $ E: Named num [1:4] 0.966 1.939 2.788 3.025 ##   ..- attr(*, \"names\")= chr [1:4] \"0.1\" \"0.25\" \"0.5\" \"1\" ##  $ V: num [1:4, 1:4] 0.21 0.308 0.349 0.203 0.308 ... ##   ..- attr(*, \"dimnames\")=List of 2 ##   .. ..$ : chr [1:4] \"0.1\" \"0.25\" \"0.5\" \"1\" ##   .. ..$ : chr [1:4] \"0.1\" \"0.25\" \"0.5\" \"1\" str(examplomycin_aggregated2) ## List of 2 ##  $ E: Named num [1:5] 2.258 1.651 1.063 0.751 0.512 ##   ..- attr(*, \"names\")= chr [1:5] \"2\" \"3\" \"5\" \"8\" ... ##  $ V: num [1:5, 1:5] 0.3447 0.1203 0.0764 0.064 0.0494 ... ##   ..- attr(*, \"dimnames\")=List of 2 ##   .. ..$ : chr [1:5] \"2\" \"3\" \"5\" \"8\" ... ##   .. ..$ : chr [1:5] \"2\" \"3\" \"5\" \"8\" ..."},{"path":"https://vanhasseltlab.github.io/admr/articles/multiple.html","id":"visualizing-the-data","dir":"Articles","previous_headings":"Introduction to Aggregate Data Modeling with admr > Data Preparation","what":"Visualizing the Data","title":"Combining multiple datasets with admr","text":"fitting model, ’s helpful visualize data:","code":"# Give different colours to 1-4 and 5-9 examplomycin <- admr::examplomycin %>%   filter(EVID != 101) %>%  # Remove dosing events   mutate(TIME = factor(TIME, levels = c(0.1, 0.25, 0.5, 1, 2, 3, 5, 8, 12))) %>%   mutate(group = ifelse(TIME %in% c(0.1, 0.25, 0.5, 1), \"Absorption\", \"Elimination\"))  ggplot(examplomycin, aes(x = TIME, y = DV, fill = group)) +   geom_boxplot(position = position_dodge(width = 0.8)) +   labs(     title = \"Examplomycin Concentration Data\",     x = \"Time (hours)\",     y = \"Concentration (mg/L)\"   ) +   theme_minimal() +   scale_fill_manual(values = c(\"Absorption\" = \"blue\", \"Elimination\" = \"red\"))"},{"path":[]},{"path":"https://vanhasseltlab.github.io/admr/articles/multiple.html","id":"defining-the-pharmacokinetic-model","dir":"Articles","previous_headings":"Introduction to Aggregate Data Modeling with admr > Model Specification","what":"Defining the Pharmacokinetic Model","title":"Combining multiple datasets with admr","text":"’ll use two-compartment model first-order absorption. use solved model approach simplicity. model parameters include:","code":"rxModel <- function(){     model({       cp = linCmt(     cl,           # Clearance     v1,           # Volume of central compartment     v2,           # Volume of peripheral compartment     q,            # Inter-compartmental clearance     ka            # Absorption rate constant   )}) }  rxModel <- rxode2(rxModel) rxModel <- rxModel$simulationModel"},{"path":"https://vanhasseltlab.github.io/admr/articles/multiple.html","id":"creating-the-prediction-function","dir":"Articles","previous_headings":"Introduction to Aggregate Data Modeling with admr > Model Specification","what":"Creating the Prediction Function","title":"Combining multiple datasets with admr","text":"prediction function crucial admr package. : - Constructs event table dosing sampling - Solves RxODE model - Returns predicted concentrations required format Since datasets come study design, can use prediction function datasets. However, datasets different dosing regimens characteristics, need define separate prediction functions dataset. can done creating multiple genopts objects, prediction function.","code":"rxode2::rxSetSilentErr(1) ## [1] TRUE predder <- function(time, theta_i, dose = 100) {     n_individuals <- nrow(theta_i)          if (is.null(n_individuals)) {       n_individuals <- 1     }      # Create event table     ev <- eventTable(amount.units=\"mg\", time.units=\"hours\")     ev$add.dosing(dose = dose, nbr.doses = 1, start.time = 0)     ev$add.sampling(time)          # Solve model     out <- rxSolve(rxModel, params = theta_i, events = ev, cores = 0)          # Format output     cp_matrix <- matrix(out$cp, nrow = n_individuals, ncol = length(time),                          byrow = TRUE)          return(cp_matrix) }"},{"path":[]},{"path":"https://vanhasseltlab.github.io/admr/articles/multiple.html","id":"setting-up-model-options","dir":"Articles","previous_headings":"Introduction to Aggregate Data Modeling with admr > Model Fitting","what":"Setting Up Model Options","title":"Combining multiple datasets with admr","text":"genopts function creates options object controls model fitting process: difference opts1 opts2 observation times specified time argument.","code":"opts1 <- genopts(   time = c(.1, .25, .5, 1),  # Observation times   p = list(     beta = c(cl = 5, v1 = 10, v2 = 30, q = 10, ka = 1),  # Population parameters     Omega = matrix(c(0.09, 0, 0, 0, 0,                     0, 0.09, 0, 0, 0,                     0, 0, 0.09, 0, 0,                     0, 0, 0, 0.09, 0,                     0, 0, 0, 0, 0.09), nrow = 5, ncol = 5),  # Random effects     Sigma_prop = 0.04  # Proportional error   ),   nsim = 10000,  # Number of Monte Carlo samples   n = 500,      # Number of individuals   fo_appr = FALSE,  # Disable first-order approximation   omega_expansion = 1,  # Omega expansion factor   f = predder    # Prediction function )    opts2 <- genopts(   time = c(2, 3, 5, 8, 12),  # Observation times   p = list(     beta = c(cl = 5, v1 = 10, v2 = 30, q = 10, ka = 1),  # Population parameters     Omega = matrix(c(0.09, 0, 0, 0, 0,                     0, 0.09, 0, 0, 0,                     0, 0, 0.09, 0, 0,                     0, 0, 0, 0.09, 0,                     0, 0, 0, 0, 0.09), nrow = 5, ncol = 5),  # Random effects     Sigma_prop = 0.04  # Proportional error   ),   nsim = 10000,  # Number of Monte Carlo samples   n = 500,      # Number of individuals   fo_appr = FALSE,  # Disable first-order approximation   omega_expansion = 1,  # Omega expansion factor   f = predder    # Prediction function )"},{"path":"https://vanhasseltlab.github.io/admr/articles/multiple.html","id":"fitting-the-model","dir":"Articles","previous_headings":"Introduction to Aggregate Data Modeling with admr > Model Fitting","what":"Fitting the Model","title":"Combining multiple datasets with admr","text":"fitting model, ensure opts objects aggregated datasets organized lists. fitIRMC function fits model using IR-MC algorithm:","code":"opts <- list(opts1,opts2) examplomycin_aggregated <- list(examplomycin_aggregated1, examplomycin_aggregated2)  fit.admr <- fitIRMC(   opts = opts,   obs = examplomycin_aggregated,   chains = 2,  # Number of parallel chains   maxiter = 2000,  # Maximum iterations   single_dataframe = FALSE,  # Use separate data frames for each dataset   use_grad = TRUE   ) ## Chain 1: ## Iter | NLL and Parameters (11 values) ## -------------------------------------------------------------------------------- ##    1: -1790.659    1.609    2.303    3.401    2.303    0.000   -2.408   -2.408   -2.408   -2.408   -2.408   -3.219 ##  ## ### Wide Search Phase ### ##    2: -1796.419    1.603    2.326    3.393    2.286    0.032   -2.265   -2.052   -2.306   -2.267   -2.565   -3.235 ##    3: -1796.484    1.602    2.305    3.401    2.284    0.013   -2.271   -2.106   -2.324   -2.308   -2.509   -3.235 ##    4: -1796.484    1.602    2.305    3.401    2.284    0.013   -2.271   -2.105   -2.324   -2.307   -2.509   -3.235 ##    5: -1796.484    1.602    2.305    3.401    2.284    0.013   -2.271   -2.105   -2.325   -2.307   -2.509   -3.235 ##    6: -1796.484    1.602    2.305    3.401    2.284    0.013   -2.271   -2.105   -2.325   -2.307   -2.509   -3.235 ##    7: -1796.484    1.602    2.305    3.400    2.284    0.013   -2.271   -2.105   -2.325   -2.307   -2.509   -3.235 ##    8: -1796.484    1.602    2.305    3.400    2.284    0.013   -2.271   -2.105   -2.325   -2.307   -2.509   -3.235 ##    9: -1796.484    1.602    2.305    3.400    2.284    0.013   -2.271   -2.105   -2.325   -2.307   -2.509   -3.235 ##   10: -1796.484    1.602    2.305    3.400    2.284    0.013   -2.271   -2.105   -2.325   -2.307   -2.509   -3.235 ##   11: -1796.484    1.602    2.305    3.400    2.284    0.013   -2.271   -2.105   -2.325   -2.306   -2.509   -3.235 ##   12: -1796.484    1.602    2.305    3.400    2.284    0.013   -2.271   -2.105   -2.325   -2.306   -2.509   -3.235 ## Phase Wide Search Phase converged at iteration 12. ##  ## ### Focussed Search Phase ### ##   13: -1796.484    1.602    2.305    3.400    2.284    0.013   -2.271   -2.105   -2.325   -2.306   -2.509   -3.235 ##   14: -1796.484    1.602    2.305    3.400    2.284    0.013   -2.271   -2.105   -2.325   -2.306   -2.509   -3.235 ## Phase Focussed Search Phase converged at iteration 14. ##  ## ### Fine-Tuning Phase ### ##   15: -1796.484    1.602    2.305    3.400    2.284    0.013   -2.271   -2.105   -2.325   -2.306   -2.509   -3.235 ##   16: -1796.484    1.602    2.305    3.400    2.284    0.014   -2.271   -2.105   -2.326   -2.306   -2.508   -3.235 ## Phase Fine-Tuning Phase converged at iteration 16. ##  ## ### Precision Phase ### ##   17: -1796.484    1.602    2.305    3.400    2.284    0.014   -2.271   -2.105   -2.326   -2.306   -2.508   -3.235 ##   18: -1796.484    1.602    2.305    3.400    2.284    0.014   -2.271   -2.105   -2.326   -2.305   -2.508   -3.235 ##   19: -1796.484    1.602    2.306    3.400    2.284    0.014   -2.271   -2.105   -2.326   -2.305   -2.508   -3.235 ##   20: -1796.484    1.602    2.306    3.400    2.284    0.014   -2.271   -2.105   -2.326   -2.305   -2.508   -3.235 ##   21: -1796.484    1.602    2.306    3.400    2.284    0.014   -2.271   -2.105   -2.326   -2.305   -2.508   -3.235 ##   22: -1796.484    1.602    2.306    3.400    2.285    0.014   -2.271   -2.105   -2.326   -2.305   -2.508   -3.235 ## Phase Precision Phase converged at iteration 22. ##  ## Chain 1 Complete: Final NLL = -1796.484, Time Elapsed = 21.15 seconds ##   ## Phase Wide Search Phase converged at iteration 18. ## Phase Focussed Search Phase converged at iteration 21. ## Phase Fine-Tuning Phase converged at iteration 22. ## Phase Precision Phase converged at iteration 23. ##  ## Chain 2 Complete: Final NLL = -1796.484, Time Elapsed = 25.26 seconds ##"},{"path":[]},{"path":"https://vanhasseltlab.github.io/admr/articles/multiple.html","id":"basic-diagnostics","dir":"Articles","previous_headings":"Introduction to Aggregate Data Modeling with admr > Model Diagnostics","what":"Basic Diagnostics","title":"Combining multiple datasets with admr","text":"print method provides summary model fit:","code":"print(fit.admr) ## -- FitIRMC Summary -- ##  ## -- Objective Function and Information Criteria -- ##  Log-likelihood: -1796.4841 ##             AIC: 3603.97 ##             BIC: 3729.69 ## Condition#(Cov): 165.32 ## Condition#(Cor): 271.29 ##  ## -- Timing Information -- ##      Best Chain: 21.1497 seconds ##      All Chains: 46.4166 seconds ##      Covariance: 33.1216 seconds ##         Elapsed: 79.54 seconds ##  ## -- Population Parameters -- ## # A tibble: 6 × 6 ##   Parameter        Est.      SE  `%RSE` `Back-transformed(95%CI)` `BSV(CV%)` ##   <chr>           <dbl>   <dbl>   <dbl> <chr>                          <dbl> ## 1 cl             1.60    0.0155   0.971 4.96 (4.81, 5.12)               32.1 ## 2 v1             2.31    0.0944   4.10  10.03 (8.34, 12.07)             34.9 ## 3 v2             3.40    0.0439   1.29  29.97 (27.50, 32.66)            31.3 ## 4 q              2.28    0.0206   0.903 9.82 (9.43, 10.23)              31.6 ## 5 ka             0.0138  0.0897 651.    1.01 (0.85, 1.21)               28.5 ## 6 Residual Error 0.0393 NA       NA     0.0393                          NA   ##  ## -- Iteration Diagnostics -- ##  Iter | NLL and Parameters ## -------------------------------------------------------------------------------- ##    1: -1790.659 1.609 2.303 3.401 2.303 0.000 -2.408 -2.408 -2.408 -2.408 -2.408 -3.219 ##    2: -1796.419 1.603 2.326 3.393 2.286 0.032 -2.265 -2.052 -2.306 -2.267 -2.565 -3.235 ##    3: -1796.484 1.602 2.305 3.401 2.284 0.013 -2.271 -2.106 -2.324 -2.308 -2.509 -3.235 ##    4: -1796.484 1.602 2.305 3.401 2.284 0.013 -2.271 -2.105 -2.324 -2.307 -2.509 -3.235 ##    5: -1796.484 1.602 2.305 3.401 2.284 0.013 -2.271 -2.105 -2.325 -2.307 -2.509 -3.235 ##    ... (omitted iterations) ... ##   18: -1796.484 1.602 2.305 3.400 2.284 0.014 -2.271 -2.105 -2.326 -2.305 -2.508 -3.235 ##   19: -1796.484 1.602 2.306 3.400 2.284 0.014 -2.271 -2.105 -2.326 -2.305 -2.508 -3.235 ##   20: -1796.484 1.602 2.306 3.400 2.284 0.014 -2.271 -2.105 -2.326 -2.305 -2.508 -3.235 ##   21: -1796.484 1.602 2.306 3.400 2.284 0.014 -2.271 -2.105 -2.326 -2.305 -2.508 -3.235 ##   22: -1796.484 1.602 2.306 3.400 2.285 0.014 -2.271 -2.105 -2.326 -2.305 -2.508 -3.235"},{"path":"https://vanhasseltlab.github.io/admr/articles/multiple.html","id":"convergence-assessment","dir":"Articles","previous_headings":"Introduction to Aggregate Data Modeling with admr > Model Diagnostics","what":"Convergence Assessment","title":"Combining multiple datasets with admr","text":"plot method visualizes convergence model fit: Upon inspection convergence plots, look : good chain convergence, overlapping predicted observed summary plots, similar final observed vs predicted matrices mean covariance. observe chains converge well, predicted means covariances align closely observed data.","code":"plot(fit.admr)"},{"path":"https://vanhasseltlab.github.io/admr/articles/multiple.html","id":"parameter-estimates","dir":"Articles","previous_headings":"Introduction to Aggregate Data Modeling with admr > Model Diagnostics","what":"Parameter Estimates","title":"Combining multiple datasets with admr","text":"Let’s examine parameter estimates true values used simulation. expect close true values, although, like discussed earlier, estimates may less precise due reduced information content splitting data: observe parameter estimates reasonably close true values, especially considering reduced information content splitting data two groups. deviations, particularly estimates q random effect v1, may attributed lack early timepoint data second dataset. Let’s also visualize dynamics estimated model together true model dosing simulation. ## Advanced Features","code":"# True parameter values params.true <- list(   beta = c(cl = 5, v1 = 10, v2 = 30, q = 10, ka = 1),   Omega = diag(rep(0.09, 5)),   Sigma_prop = 0.04 ) cat(\"True parameter values:\\n\") ## True parameter values: print(params.true) ## $beta ## cl v1 v2  q ka  ##  5 10 30 10  1  ##  ## $Omega ##      [,1] [,2] [,3] [,4] [,5] ## [1,] 0.09 0.00 0.00 0.00 0.00 ## [2,] 0.00 0.09 0.00 0.00 0.00 ## [3,] 0.00 0.00 0.09 0.00 0.00 ## [4,] 0.00 0.00 0.00 0.09 0.00 ## [5,] 0.00 0.00 0.00 0.00 0.09 ##  ## $Sigma_prop ## [1] 0.04 # Extract parameter estimates params <- fit.admr$transformed_params cat(\"Final parameter estimates:\\n\") ## Final parameter estimates: print(params) ## $beta ##        cl        v1        v2         q        ka  ##  4.962124 10.030806 29.970361  9.821153  1.013878  ##  ## $Omega ##           [,1]      [,2]       [,3]     [,4]       [,5] ## [1,] 0.1031999 0.0000000 0.00000000 0.000000 0.00000000 ## [2,] 0.0000000 0.1217946 0.00000000 0.000000 0.00000000 ## [3,] 0.0000000 0.0000000 0.09766634 0.000000 0.00000000 ## [4,] 0.0000000 0.0000000 0.00000000 0.099783 0.00000000 ## [5,] 0.0000000 0.0000000 0.00000000 0.000000 0.08141121 ##  ## $Sigma_prop ## [1] 0.03934987"},{"path":"https://vanhasseltlab.github.io/admr/articles/multiple.html","id":"creating-a-dosing-plot","dir":"Articles","previous_headings":"Introduction to Aggregate Data Modeling with admr > Model Diagnostics","what":"Creating a dosing plot","title":"Combining multiple datasets with admr","text":"visualize dosing regimen predicted concentrations, can create dosing plot. helps understanding pharmacokinetic profile drug time. can done using nlmixr2-universe. First, need define model nlmixr2 syntax simulate dosing regimen estimated true models. Now defined models, can simulate dosing regimen plot results:  combined dataset model (red) closely follows true parameter model (blue). median line estimated model almost perfectly overlaps true model, indicating estimated model. However, estimated model show slightly wider population intervals. scenario isn’t problematic, since wider range still captures true dynamics. case dose optimization, results conservative dose recommendation. However, scenarios, lead - -prediction certain percentiles. estimation error expected due reduced information content variance-data.","code":"params.true <- list(   beta = c(cl = 5, v1 = 10, v2 = 30, q = 10, ka = 1),   Omega = diag(rep(0.09, 5)),   Sigma_prop = 0.04 ) params <- fit.admr$transformed_params  rxModel_true <- function(){   ini({     cl <- params.true$beta[\"cl\"]  # Clearance     v1 <- params.true$beta[\"v1\"]  # Volume of central compartment     v2 <- params.true$beta[\"v2\"] # Volume of peripheral compartment     q <- params.true$beta[\"q\"]    # Inter-compartmental clearance     ka <- params.true$beta[\"ka\"]   # Absorption rate constant      eta_cl ~ params.true$Omega[1,1]     eta_v1 ~ params.true$Omega[2,2]     eta_v2 ~ params.true$Omega[3,3]     eta_q ~ params.true$Omega[4,4]     eta_ka ~ params.true$Omega[5,5]   })   model({     cl <- cl * exp(eta_cl)     v1 <- v1 * exp(eta_v1)     v2 <- v2 * exp(eta_v2)     q <- q * exp(eta_q)     ka <- ka * exp(eta_ka)     cp = linCmt(cl, v1, v2, q, ka)   }) }  rxModel_multiple <- function(){   ini({     cl <- params$beta[\"cl\"]  # Clearance     v1 <- params$beta[\"v1\"]  # Volume of central compartment     v2 <- params$beta[\"v2\"] # Volume of peripheral compartment     q <- params$beta[\"q\"]    # Inter-compartmental clearance     ka <- params$beta[\"ka\"]   # Absorption rate constant      eta_cl ~ params$Omega[1,1]     eta_v1 ~ params$Omega[2,2]     eta_v2 ~ params$Omega[3,3]     eta_q ~ params$Omega[4,4]     eta_ka ~ params$Omega[5,5]   })   model({     cl <- cl * exp(eta_cl)     v1 <- v1 * exp(eta_v1)     v2 <- v2 * exp(eta_v2)     q <- q * exp(eta_q)     ka <- ka * exp(eta_ka)     cp = linCmt(cl, v1, v2, q, ka)   }) }  rxModel_true <- rxode2(rxModel_true()) rxModel_true <- rxModel_true$simulationModel rxModel_multiple <- rxode2(rxModel_multiple()) rxModel_multiple <- rxModel_multiple$simulationModel time_points <- seq(0, 12, by = 0.05)  # Dense time points for smooth curves ev <- eventTable(amount.units=\"mg\", time.units=\"hours\") ev$add.dosing(dose = 100, nbr.doses = 2, dosing.interval = 6) ev$add.sampling(time_points)  sim_true <- rxSolve(rxModel_true, events = ev, cores = 0, nSub = 10000) sim_multiple <- rxSolve(rxModel_multiple, events = ev, cores = 0, nSub = 10000)  # Combine the confidence intervals with a label for the model ci_true <- as.data.frame(confint(sim_true, \"cp\", level=0.95)) %>%   mutate(Model = \"True parameters\") ## summarizing data...done ci_covar <- as.data.frame(confint(sim_multiple, \"cp\", level=0.95)) %>%   mutate(Model = \"Estimated model\") ## summarizing data...done # Bind them together ci_all <- bind_rows(ci_true, ci_covar) %>%   mutate(     p1 = as.numeric(as.character(p1)),     Percentile = factor(Percentile, levels = unique(Percentile[order(p1)]))   )  # Plot both models ggplot(ci_all, aes(x = time, group = interaction(Model, Percentile))) +   geom_ribbon(aes(ymin = p2.5, ymax = p97.5, fill = Model),               alpha = 0.2, colour = NA) +   geom_line(aes(y = p50, colour = Model), size = 0.8) +   labs(     title = \"Central Concentration Simulations\",     x = \"Time\",     y = \"Central Concentration (mg/L)\"   ) +   theme_bw(base_size = 14) +   scale_colour_manual(values = c(\"True parameters\" = \"blue\",                                  \"Estimated model\" = \"red\")) +   scale_fill_manual(values = c(\"True parameters\" = \"blue\",                                \"Estimated model\" = \"red\")) ## Warning: Using `size` aesthetic for lines was deprecated in ggplot2 3.4.0. ## ℹ Please use `linewidth` instead. ## This warning is displayed once every 8 hours. ## Call `lifecycle::last_lifecycle_warnings()` to see where this warning was ## generated."},{"path":"https://vanhasseltlab.github.io/admr/articles/multiple.html","id":"best-practices","dir":"Articles","previous_headings":"Introduction to Aggregate Data Modeling with admr","what":"Best Practices","title":"Combining multiple datasets with admr","text":"conclude, best practices using admr package aggregate data modeling: Always check data missing values outliers Ensure time points consistent across subjects Consider impact dosing events analysis Start simple model gradually add complexity Use meaningful initial values parameters Consider parameter transformations better estimation Use multiple chains improve optimization Monitor convergence carefully Check parameter estimates biological plausibility Always examine convergence plots Validate model predictions observed data information, see package documentation vignettes.","code":""},{"path":"https://vanhasseltlab.github.io/admr/articles/variance.html","id":"variance-based-modelling","dir":"Articles","previous_headings":"","what":"Variance based modelling","title":"Variance-only based modelling with admr","text":"vignette provides introduction variance-based modeling using admr package R. ’ll cover essential steps prepare data, specify pharmacokinetic model, fit model aggregate data, evaluate results. ’ll compare results using mean variance data full mean covariance data. Variance based modeling particularly useful complex aggregate data available, means variances reported. admr package implements Iterative Reweighting Monte Carlo (IRMC) algorithm, efficiently fits models aggregate data iteratively updating parameter estimates using weighted importance sampling.","code":""},{"path":"https://vanhasseltlab.github.io/admr/articles/variance.html","id":"required-packages","dir":"Articles","previous_headings":"Variance based modelling","what":"Required Packages","title":"Variance-only based modelling with admr","text":"First, need load necessary packages:","code":"library(admr) library(rxode2) library(nlmixr2) library(dplyr) library(tidyr) library(mnorm) library(ggplot2)  # For visualization library(units)"},{"path":"https://vanhasseltlab.github.io/admr/articles/variance.html","id":"understanding-the-data-format","dir":"Articles","previous_headings":"Variance based modelling","what":"Understanding the Data Format","title":"Variance-only based modelling with admr","text":"admr package works two types data formats: Raw Data: Individual-level observations wide long format. Aggregate Data: Summary statistics (mean covariance) computed raw data. Aggregate Data means variance: Mean variance time point (covariances). Let’s look examplomycin dataset, ’ll use throughout vignette:","code":"# Load the dataset data(examplomycin) head(examplomycin) ##    ID TIME    DV AMT EVID CMT ## 1 460 0.00 0.000 100  101   1 ## 2 460 0.10 0.752   0    0   2 ## 3 460 0.25 1.932   0    0   2 ## 4 460 0.50 3.694   0    0   2 ## 5 460 1.00 3.479   0    0   2 ## 6 460 2.00 4.003   0    0   2 # Basic dataset information cat(\"Number of subjects:\", length(unique(examplomycin$ID)), \"\\n\") ## Number of subjects: 500 cat(\"Number of time points:\", length(unique(examplomycin$TIME)), \"\\n\") ## Number of time points: 10 cat(\"Time points:\", paste(sort(unique(examplomycin$TIME)), collapse = \", \"), \"\\n\") ## Time points: 0, 0.1, 0.25, 0.5, 1, 2, 3, 5, 8, 12"},{"path":[]},{"path":"https://vanhasseltlab.github.io/admr/articles/variance.html","id":"converting-raw-data-to-aggregate-format","dir":"Articles","previous_headings":"Variance based modelling > Data Preparation","what":"Converting Raw Data to Aggregate Format","title":"Variance-only based modelling with admr","text":"first step convert simulated raw data aggregate format. , create two versions aggregated data: one mean covariance, another mean variance . real-world scenarios, access raw data, step included demonstration purposes.","code":"# Convert to wide format examplomycin_wide <- examplomycin %>%   filter(EVID != 101) %>%  # Remove dosing events   dplyr::select(ID, TIME, DV) %>%  # Select relevant columns   pivot_wider(names_from = TIME, values_from = DV) %>%  # Convert to wide format   dplyr::select(-c(1))  # Remove ID column  # Create aggregated data examplomycin_aggregated <- examplomycin_wide %>%   admr::meancov()  # Compute mean and covariance  # View the structure of aggregated data examplomycin_aggregated ## $E ##      0.1     0.25      0.5        1        2        3        5        8  ## 0.966418 1.938774 2.787908 3.024706 2.257656 1.650808 1.063120 0.751180  ##       12  ## 0.512168  ##  ## $V ##               0.1         0.25         0.5           1          2           3 ## 0.1   0.210318331  0.307810566  0.34863077 0.202610737 0.02244783 -0.04472722 ## 0.25  0.307810566  0.707512991  0.65887098 0.416118052 0.05871261 -0.07441765 ## 0.5   0.348630772  0.658870977  1.09983366 0.530554165 0.10572618 -0.07538386 ## 1     0.202610737  0.416118052  0.53055416 0.803744604 0.16252833  0.02792441 ## 2     0.022447834  0.058712608  0.10572618 0.162528331 0.34465070  0.12026872 ## 3    -0.044727222 -0.074417647 -0.07538386 0.027924410 0.12026872  0.24989260 ## 5    -0.018976800 -0.042420657 -0.04648286 0.001618855 0.07644080  0.11148574 ## 8    -0.006630907 -0.011273701 -0.01981830 0.016197981 0.06398700  0.07493319 ## 12   -0.005625994 -0.005018766 -0.01492001 0.014748325 0.04941463  0.05460018 ##                 5            8           12 ## 0.1  -0.018976800 -0.006630907 -0.005625994 ## 0.25 -0.042420657 -0.011273701 -0.005018766 ## 0.5  -0.046482865 -0.019818299 -0.014920009 ## 1     0.001618855  0.016197981  0.014748325 ## 2     0.076440801  0.063987002  0.049414630 ## 3     0.111485737  0.074933189  0.054600176 ## 5     0.154215442  0.087680168  0.061332530 ## 8     0.087680168  0.096530356  0.057621124 ## 12    0.061332530  0.057621124  0.057988752 # Transform into mean and variance only format examplomycin_aggregated_var <- examplomycin_aggregated examplomycin_aggregated_var$V <- diag(diag(examplomycin_aggregated_var$V))  # View the structure of mean and variance only data examplomycin_aggregated_var ## $E ##      0.1     0.25      0.5        1        2        3        5        8  ## 0.966418 1.938774 2.787908 3.024706 2.257656 1.650808 1.063120 0.751180  ##       12  ## 0.512168  ##  ## $V ##            [,1]     [,2]     [,3]      [,4]      [,5]      [,6]      [,7] ##  [1,] 0.2103183 0.000000 0.000000 0.0000000 0.0000000 0.0000000 0.0000000 ##  [2,] 0.0000000 0.707513 0.000000 0.0000000 0.0000000 0.0000000 0.0000000 ##  [3,] 0.0000000 0.000000 1.099834 0.0000000 0.0000000 0.0000000 0.0000000 ##  [4,] 0.0000000 0.000000 0.000000 0.8037446 0.0000000 0.0000000 0.0000000 ##  [5,] 0.0000000 0.000000 0.000000 0.0000000 0.3446507 0.0000000 0.0000000 ##  [6,] 0.0000000 0.000000 0.000000 0.0000000 0.0000000 0.2498926 0.0000000 ##  [7,] 0.0000000 0.000000 0.000000 0.0000000 0.0000000 0.0000000 0.1542154 ##  [8,] 0.0000000 0.000000 0.000000 0.0000000 0.0000000 0.0000000 0.0000000 ##  [9,] 0.0000000 0.000000 0.000000 0.0000000 0.0000000 0.0000000 0.0000000 ##             [,8]       [,9] ##  [1,] 0.00000000 0.00000000 ##  [2,] 0.00000000 0.00000000 ##  [3,] 0.00000000 0.00000000 ##  [4,] 0.00000000 0.00000000 ##  [5,] 0.00000000 0.00000000 ##  [6,] 0.00000000 0.00000000 ##  [7,] 0.00000000 0.00000000 ##  [8,] 0.09653036 0.00000000 ##  [9,] 0.00000000 0.05798875"},{"path":"https://vanhasseltlab.github.io/admr/articles/variance.html","id":"visualizing-the-data","dir":"Articles","previous_headings":"Variance based modelling > Data Preparation","what":"Visualizing the Data","title":"Variance-only based modelling with admr","text":"fitting model, ’s helpful visualize data:","code":"# Boxplot to visualize variability ggplot(examplomycin, aes(x = TIME, y = DV, group = TIME)) +   geom_boxplot(aes(group = TIME), width = 0.2) +   labs(     title = \"Concentration Variability at Each Time Point\",     x = \"Time (hours)\",     y = \"Concentration (mg/L)\"   ) +   theme_minimal()"},{"path":[]},{"path":"https://vanhasseltlab.github.io/admr/articles/variance.html","id":"defining-the-pharmacokinetic-model","dir":"Articles","previous_headings":"Variance based modelling > Model Specification","what":"Defining the Pharmacokinetic Model","title":"Variance-only based modelling with admr","text":"’ll use solved two-compartment model first-order absorption:","code":"# Define RxODE model rxModel <- function(){   model({     cp = linCmt(       cl,           # Clearance       v1,           # Volume of central compartment       v2,           # Volume of peripheral compartment       q,            # Inter-compartmental clearance       ka            # Absorption rate constant     )}) }  rxModel <- rxode2(rxModel) rxModel <- rxModel$simulationModel"},{"path":"https://vanhasseltlab.github.io/admr/articles/variance.html","id":"creating-the-prediction-function","dir":"Articles","previous_headings":"Variance based modelling > Model Specification","what":"Creating the Prediction Function","title":"Variance-only based modelling with admr","text":"prediction function crucial admr package. : - Constructs event table dosing sampling - Solves RxODE model - Returns predicted concentrations required format can observed steps variance based modeling similar mean covariance based modeling. difference data used fitting model.","code":"rxode2::rxSetSilentErr(1) ## [1] TRUE predder <- function(time, theta_i, dose = 100) {     n_individuals <- nrow(theta_i)          if (is.null(n_individuals)) {       n_individuals <- 1     }      # Create event table     ev <- eventTable(amount.units=\"mg\", time.units=\"hours\")     ev$add.dosing(dose = dose, nbr.doses = 1, start.time = 0)     ev$add.sampling(time)          # Solve model     out <- rxSolve(rxModel, params = theta_i, events = ev, cores = 0)          # Format output     cp_matrix <- matrix(out$cp, nrow = n_individuals, ncol = length(time),                          byrow = TRUE)          return(cp_matrix) }"},{"path":[]},{"path":"https://vanhasseltlab.github.io/admr/articles/variance.html","id":"setting-up-model-options","dir":"Articles","previous_headings":"Variance based modelling > Model Fitting","what":"Setting Up Model Options","title":"Variance-only based modelling with admr","text":"genopts function creates options object controls model fitting process. ’ll twice: mean covariance data, mean variance data. difference two options no_cov argument, set TRUE variance data FALSE mean covariance data.","code":"opts_covar <- genopts(   time = c(.1, .25, .5, 1, 2, 3, 5, 8, 12),  # Observation times   p = list(     beta = c(cl = 5, v1 = 10, v2 = 30, q = 10, ka = 1),  # Population parameters     Omega = matrix(c(0.09, 0, 0, 0, 0,                     0, 0.09, 0, 0, 0,                     0, 0, 0.09, 0, 0,                     0, 0, 0, 0.09, 0,                     0, 0, 0, 0, 0.09), nrow = 5, ncol = 5),  # Random effects     Sigma_prop = 0.04  # Proportional error   ),   nsim = 10000,  # Number of Monte Carlo samples   n = 500,      # Number of individuals   fo_appr = FALSE,  # Disable first-order approximation   omega_expansion = 1,  # Omega expansion factor   f = predder,    # Prediction function   no_cov = FALSE # Use mean and covariance format )   opts_var <- genopts(   time = c(.1, .25, .5, 1, 2, 3, 5, 8, 12),  # Observation times   p = list(     beta = c(cl = 5, v1 = 10, v2 = 30, q = 10, ka = 1),  # Population parameters     Omega = matrix(c(0.09, 0, 0, 0, 0,                     0, 0.09, 0, 0, 0,                     0, 0, 0.09, 0, 0,                     0, 0, 0, 0.09, 0,                     0, 0, 0, 0, 0.09), nrow = 5, ncol = 5),  # Random effects     Sigma_prop = 0.04  # Proportional error   ),   nsim = 10000,  # Number of Monte Carlo samples   n = 500,      # Number of individuals   fo_appr = FALSE,  # Disable first-order approximation   omega_expansion = 1,  # Omega expansion factor   f = predder,    # Prediction function   no_cov = TRUE # Use mean and variance only format )"},{"path":"https://vanhasseltlab.github.io/admr/articles/variance.html","id":"fitting-the-model","dir":"Articles","previous_headings":"Variance based modelling > Model Fitting","what":"Fitting the Model","title":"Variance-only based modelling with admr","text":"fitIRMC function fits model using IRMC algorithm: Convergence speeds lot variance fit using gradients, optimization landscape challenging less information. However NLL slightly worse without gradients. likely due local minima issues, can alleviated using chains, larger MC samples, iterations.","code":"fit.var <- admr::fitIRMC(   opts = opts_var,   obs = examplomycin_aggregated_var,   chains = 6,  # Number of chains   maxiter = 200,  # Maximum iterations   use_grad = T ) ## Chain 1: ## Iter | NLL and Parameters (11 values) ## -------------------------------------------------------------------------------- ##    1: -1242.386    1.609    2.303    3.401    2.303    0.000   -2.408   -2.408   -2.408   -2.408   -2.408   -3.219 ##  ## ### Wide Search Phase ### ##    2: -1261.578    1.593    2.057    3.463    2.177   -0.260   -2.086   -2.749   -2.349   -4.408   -1.914   -3.388 ##    3: -1266.407    1.598    2.055    3.456    2.172   -0.243   -2.126   -2.762   -2.352   -4.408   -1.966   -3.423 ##    4: -1266.408    1.598    2.054    3.456    2.173   -0.243   -2.126   -2.762   -2.352   -4.408   -1.966   -3.423 ##    5: -1266.409    1.598    2.054    3.456    2.173   -0.243   -2.127   -2.762   -2.351   -4.408   -1.966   -3.422 ## Phase Wide Search Phase converged at iteration 5. ##  ## ### Focussed Search Phase ### ##    6: -1266.409    1.598    2.054    3.456    2.173   -0.243   -2.127   -2.762   -2.351   -4.408   -1.967   -3.422 ## Phase Focussed Search Phase converged at iteration 6. ##  ## ### Fine-Tuning Phase ### ##    7: -1266.409    1.598    2.054    3.456    2.173   -0.243   -2.127   -2.762   -2.351   -4.408   -1.967   -3.422 ##    8: -1266.410    1.598    2.054    3.456    2.173   -0.243   -2.127   -2.762   -2.351   -4.408   -1.967   -3.421 ## Phase Fine-Tuning Phase converged at iteration 8. ##  ## ### Precision Phase ### ##    9: -1266.410    1.598    2.054    3.456    2.173   -0.243   -2.127   -2.762   -2.351   -4.408   -1.967   -3.421 ##   10: -1266.411    1.598    2.054    3.457    2.173   -0.243   -2.128   -2.762   -2.351   -4.408   -1.967   -3.420 ## Phase Precision Phase converged at iteration 10. ##  ## Chain 1 Complete: Final NLL = -1266.411, Time Elapsed = 8.99 seconds ##   ## Phase Wide Search Phase converged at iteration 5. ## Phase Focussed Search Phase converged at iteration 6. ## Phase Fine-Tuning Phase converged at iteration 7. ## Phase Precision Phase converged at iteration 8. ##  ## Chain 2 Complete: Final NLL = -1266.426, Time Elapsed = 11.01 seconds ##   ## Phase Wide Search Phase converged at iteration 7. ## Phase Focussed Search Phase converged at iteration 9. ## Phase Fine-Tuning Phase converged at iteration 11. ## Phase Precision Phase converged at iteration 13. ##  ## Chain 3 Complete: Final NLL = -1266.157, Time Elapsed = 9.14 seconds ##   ## Phase Wide Search Phase converged at iteration 5. ## Phase Focussed Search Phase converged at iteration 6. ## Phase Fine-Tuning Phase converged at iteration 10. ## Phase Precision Phase converged at iteration 11. ##  ## Chain 4 Complete: Final NLL = -1266.431, Time Elapsed = 12.41 seconds ##   ## Phase Wide Search Phase converged at iteration 5. ## Phase Focussed Search Phase converged at iteration 7. ## Phase Fine-Tuning Phase converged at iteration 9. ## Phase Precision Phase converged at iteration 11. ##  ## Chain 5 Complete: Final NLL = -1266.439, Time Elapsed = 12.61 seconds ##   ## Phase Focussed Search Phase converged at iteration 17. ## Phase Fine-Tuning Phase converged at iteration 18. ## Phase Precision Phase converged at iteration 19. ##  ## Chain 6 Complete: Final NLL = -1266.379, Time Elapsed = 42.69 seconds ## fit.covar <- admr::fitIRMC(   opts = opts_covar,   obs = examplomycin_aggregated,   chains = 2,  # Number of chains   maxiter = 200,  # Maximum iterations   use_grad = T ) ## Chain 1: ## Iter | NLL and Parameters (11 values) ## -------------------------------------------------------------------------------- ##    1: -1839.520    1.609    2.303    3.401    2.303    0.000   -2.408   -2.408   -2.408   -2.408   -2.408   -3.219 ##  ## ### Wide Search Phase ### ##    2: -1845.306    1.601    2.324    3.399    2.285    0.032   -2.274   -2.183   -2.325   -2.210   -2.418   -3.236 ##    3: -1845.355    1.601    2.317    3.401    2.285    0.026   -2.283   -2.218   -2.338   -2.239   -2.387   -3.235 ##    4: -1845.355    1.601    2.317    3.401    2.285    0.026   -2.283   -2.218   -2.338   -2.239   -2.387   -3.235 ##    5: -1845.355    1.601    2.317    3.401    2.285    0.026   -2.283   -2.218   -2.338   -2.239   -2.387   -3.235 ##    6: -1845.355    1.601    2.317    3.401    2.285    0.026   -2.282   -2.218   -2.338   -2.239   -2.387   -3.235 ##    7: -1845.355    1.601    2.317    3.401    2.285    0.026   -2.282   -2.218   -2.338   -2.239   -2.387   -3.235 ## Phase Wide Search Phase converged at iteration 7. ##  ## ### Focussed Search Phase ### ##    8: -1845.355    1.601    2.317    3.401    2.285    0.026   -2.283   -2.218   -2.338   -2.239   -2.387   -3.235 ##    9: -1845.355    1.601    2.317    3.401    2.285    0.026   -2.283   -2.218   -2.338   -2.239   -2.387   -3.235 ##   10: -1845.355    1.601    2.317    3.401    2.285    0.026   -2.282   -2.218   -2.338   -2.239   -2.387   -3.235 ##   11: -1845.355    1.601    2.317    3.401    2.285    0.026   -2.282   -2.218   -2.338   -2.239   -2.387   -3.235 ## Phase Focussed Search Phase converged at iteration 11. ##  ## ### Fine-Tuning Phase ### ##   12: -1845.355    1.601    2.317    3.401    2.285    0.026   -2.283   -2.218   -2.338   -2.239   -2.387   -3.235 ##   13: -1845.355    1.601    2.317    3.401    2.285    0.026   -2.283   -2.218   -2.338   -2.239   -2.387   -3.235 ##   14: -1845.355    1.601    2.317    3.401    2.285    0.026   -2.282   -2.218   -2.338   -2.239   -2.387   -3.235 ##   15: -1845.355    1.601    2.317    3.401    2.285    0.026   -2.282   -2.218   -2.338   -2.239   -2.387   -3.235 ## Phase Fine-Tuning Phase converged at iteration 15. ##  ## ### Precision Phase ### ##   16: -1845.355    1.601    2.317    3.401    2.285    0.026   -2.283   -2.218   -2.338   -2.239   -2.387   -3.235 ##   17: -1845.355    1.601    2.317    3.401    2.285    0.026   -2.283   -2.218   -2.338   -2.239   -2.387   -3.235 ##   18: -1845.355    1.601    2.317    3.401    2.285    0.026   -2.282   -2.218   -2.338   -2.239   -2.387   -3.235 ##   19: -1845.355    1.601    2.317    3.401    2.285    0.026   -2.282   -2.218   -2.338   -2.239   -2.387   -3.235 ## Phase Precision Phase converged at iteration 19. ##  ## Chain 1 Complete: Final NLL = -1845.355, Time Elapsed = 11.60 seconds ##   ## Phase Wide Search Phase converged at iteration 20. ## Phase Focussed Search Phase converged at iteration 21. ## Phase Fine-Tuning Phase converged at iteration 24. ## Phase Precision Phase converged at iteration 32. ##  ## Chain 2 Complete: Final NLL = -1845.353, Time Elapsed = 25.32 seconds ##"},{"path":[]},{"path":"https://vanhasseltlab.github.io/admr/articles/variance.html","id":"basic-diagnostics","dir":"Articles","previous_headings":"Variance based modelling > Model Diagnostics","what":"Basic Diagnostics","title":"Variance-only based modelling with admr","text":"print method provides summary model fit:","code":"print(fit.var) ## -- FitIRMC Summary -- ##  ## -- Objective Function and Information Criteria -- ##  Log-likelihood: -1266.4385 ##             AIC: 2543.88 ##             BIC: 2601.24 ## Condition#(Cov): 514.83 ## Condition#(Cor): 737.47 ##  ## -- Timing Information -- ##      Best Chain: 12.6118 seconds ##      All Chains: 96.8491 seconds ##      Covariance: 20.2707 seconds ##         Elapsed: 117.12 seconds ##  ## -- Population Parameters -- ## # A tibble: 6 × 6 ##   Parameter         Est.      SE `%RSE` `Back-transformed(95%CI)` `BSV(CV%)` ##   <chr>            <dbl>   <dbl>  <dbl> <chr>                          <dbl> ## 1 cl              1.60    0.0159  0.995 4.94 (4.79, 5.10)              34.3  ## 2 v1              2.06    0.0819  3.97  7.86 (6.70, 9.23)              27.3  ## 3 v2              3.46    0.0397  1.15  31.68 (29.31, 34.25)           30.3  ## 4 q               2.18    0.0286  1.31  8.82 (8.34, 9.33)               8.09 ## 5 ka             -0.234   0.0758 32.4   0.79 (0.68, 0.92)              35.9  ## 6 Residual Error  0.0351 NA      NA     0.0351                         NA    ##  ## -- Iteration Diagnostics -- ##  Iter | NLL and Parameters ## -------------------------------------------------------------------------------- ##    1: -937.937 1.682 2.298 3.293 2.089 0.000 -2.766 -2.667 -2.167 -2.558 -2.741 -2.617 ##    2: -1209.506 1.576 2.086 3.474 2.210 -0.244 -1.967 -3.194 -1.904 -3.030 -1.917 -3.571 ##    3: -1266.274 1.597 2.056 3.454 2.174 -0.241 -2.141 -2.574 -2.386 -5.030 -2.038 -3.361 ##    4: -1266.427 1.597 2.060 3.456 2.175 -0.237 -2.133 -2.583 -2.385 -5.030 -2.054 -3.362 ##    5: -1266.428 1.597 2.060 3.456 2.175 -0.237 -2.133 -2.584 -2.385 -5.030 -2.054 -3.361 ##    ... (omitted iterations) ... ##    7: -1266.431 1.597 2.060 3.457 2.175 -0.237 -2.133 -2.586 -2.385 -5.030 -2.053 -3.358 ##    8: -1266.432 1.597 2.060 3.457 2.175 -0.237 -2.134 -2.586 -2.385 -5.030 -2.053 -3.358 ##    9: -1266.432 1.597 2.060 3.457 2.175 -0.236 -2.134 -2.586 -2.385 -5.030 -2.053 -3.358 ##   10: -1266.438 1.597 2.062 3.456 2.177 -0.234 -2.139 -2.596 -2.385 -5.030 -2.051 -3.351 ##   11: -1266.439 1.597 2.062 3.456 2.177 -0.234 -2.139 -2.596 -2.385 -5.030 -2.051 -3.351 print(fit.covar) ## -- FitIRMC Summary -- ##  ## -- Objective Function and Information Criteria -- ##  Log-likelihood: -1845.3554 ##             AIC: 3701.71 ##             BIC: 3759.07 ## Condition#(Cov): 152.17 ## Condition#(Cor): 216.85 ##  ## -- Timing Information -- ##      Best Chain: 11.6023 seconds ##      All Chains: 36.9287 seconds ##      Covariance: 20.1877 seconds ##         Elapsed: 57.12 seconds ##  ## -- Population Parameters -- ## # A tibble: 6 × 6 ##   Parameter        Est.      SE  `%RSE` `Back-transformed(95%CI)` `BSV(CV%)` ##   <chr>           <dbl>   <dbl>   <dbl> <chr>                          <dbl> ## 1 cl             1.60    0.0152   0.950 4.96 (4.81, 5.11)               31.9 ## 2 v1             2.32    0.0865   3.73  10.14 (8.56, 12.02)             33.0 ## 3 v2             3.40    0.0400   1.18  30.00 (27.74, 32.45)            31.1 ## 4 q              2.29    0.0212   0.928 9.83 (9.43, 10.24)              32.6 ## 5 ka             0.0263  0.0817 311.    1.03 (0.87, 1.20)               30.3 ## 6 Residual Error 0.0394 NA       NA     0.0394                          NA   ##  ## -- Iteration Diagnostics -- ##  Iter | NLL and Parameters ## -------------------------------------------------------------------------------- ##    1: -1839.520 1.609 2.303 3.401 2.303 0.000 -2.408 -2.408 -2.408 -2.408 -2.408 -3.219 ##    2: -1845.306 1.601 2.324 3.399 2.285 0.032 -2.274 -2.183 -2.325 -2.210 -2.418 -3.236 ##    3: -1845.355 1.601 2.317 3.401 2.285 0.026 -2.283 -2.218 -2.338 -2.239 -2.387 -3.235 ##    4: -1845.355 1.601 2.317 3.401 2.285 0.026 -2.283 -2.218 -2.338 -2.239 -2.387 -3.235 ##    5: -1845.355 1.601 2.317 3.401 2.285 0.026 -2.283 -2.218 -2.338 -2.239 -2.387 -3.235 ##    ... (omitted iterations) ... ##   15: -1845.355 1.601 2.317 3.401 2.285 0.026 -2.282 -2.218 -2.338 -2.239 -2.387 -3.235 ##   16: -1845.355 1.601 2.317 3.401 2.285 0.026 -2.283 -2.218 -2.338 -2.239 -2.387 -3.235 ##   17: -1845.355 1.601 2.317 3.401 2.285 0.026 -2.283 -2.218 -2.338 -2.239 -2.387 -3.235 ##   18: -1845.355 1.601 2.317 3.401 2.285 0.026 -2.282 -2.218 -2.338 -2.239 -2.387 -3.235 ##   19: -1845.355 1.601 2.317 3.401 2.285 0.026 -2.282 -2.218 -2.338 -2.239 -2.387 -3.235"},{"path":"https://vanhasseltlab.github.io/admr/articles/variance.html","id":"convergence-assessment","dir":"Articles","previous_headings":"Variance based modelling > Model Diagnostics","what":"Convergence Assessment","title":"Variance-only based modelling with admr","text":"plot method visualizes convergence model fit: First variance data plotted. see model converges reasonbly well within specified iterations, parameters showing variability across chains. Now plot mean covariance data fit: data seems converge slightly better, especially looking chain comparisons. chains converge similar values, whereas variance data, chains show variability resulting NLL. due non-identifiability issues parameters variance data used.","code":"plot(fit.var) plot(fit.covar)"},{"path":"https://vanhasseltlab.github.io/admr/articles/variance.html","id":"true-vs-estimated-parameters","dir":"Articles","previous_headings":"Variance based modelling > Model Diagnostics","what":"True vs Estimated Parameters","title":"Variance-only based modelling with admr","text":"Given true parameter estimates known, can compare estimated parameters true values: observe methods recover true parameters reasonably well, mean covariance method provides accurate estimates due additional information covariances. example model, especially inter-compartmental clearance (q) random effect challenging estimate accurately variance data. However, using larger sample sizes studies help improve estimates data. illustrate differences dynamics, can simulate concentration-time profiles using true parameters estimated parameters methods.","code":"params.true <- list(   beta = c(cl = 5, v1 = 10, v2 = 30, q = 10, ka = 1),   Omega = diag(rep(0.09, 5)),   Sigma_prop = 0.04 ) cat(\"True parameter values:\\n\") ## True parameter values: print(params.true) ## $beta ## cl v1 v2  q ka  ##  5 10 30 10  1  ##  ## $Omega ##      [,1] [,2] [,3] [,4] [,5] ## [1,] 0.09 0.00 0.00 0.00 0.00 ## [2,] 0.00 0.09 0.00 0.00 0.00 ## [3,] 0.00 0.00 0.09 0.00 0.00 ## [4,] 0.00 0.00 0.00 0.09 0.00 ## [5,] 0.00 0.00 0.00 0.00 0.09 ##  ## $Sigma_prop ## [1] 0.04 cat(\"Estimated parameters (mean and variance only):\\n\") ## Estimated parameters (mean and variance only): print(fit.var$transformed_params) ## $beta ##         cl         v1         v2          q         ka  ##  4.9395278  7.8628171 31.6804687  8.8216025  0.7913313  ##  ## $Omega ##           [,1]       [,2]       [,3]        [,4]      [,5] ## [1,] 0.1177831 0.00000000 0.00000000 0.000000000 0.0000000 ## [2,] 0.0000000 0.07456556 0.00000000 0.000000000 0.0000000 ## [3,] 0.0000000 0.00000000 0.09204889 0.000000000 0.0000000 ## [4,] 0.0000000 0.00000000 0.00000000 0.006541875 0.0000000 ## [5,] 0.0000000 0.00000000 0.00000000 0.000000000 0.1285627 ##  ## $Sigma_prop ## [1] 0.03506213"},{"path":"https://vanhasseltlab.github.io/admr/articles/variance.html","id":"dosing-plot-with-confidence-intervals-for-true-vs-estimated-parameters","dir":"Articles","previous_headings":"Variance based modelling > Model Diagnostics","what":"Dosing plot with Confidence Intervals for true vs estimated parameters","title":"Variance-only based modelling with admr","text":"Let’s simulate concentration-time profiles using true parameters estimated parameters methods, plot results confidence intervals. First, define models using true parameters estimated parameters methods: Now can simulate concentration-time profiles plot results:  models capture central tendency true parameters dynamics well. However, variance model shows slightly wider population intervals. scenario isn’t problematic, since wider range still captures true dynamics. However, scenarios, lead - -prediction certain percentiles. estimation error expected due reduced information content variance-data.","code":"params.true <- list(   beta = c(cl = 5, v1 = 10, v2 = 30, q = 10, ka = 1),   Omega = diag(rep(0.09, 5)),   Sigma_prop = 0.04 )  params.covar <- fit.covar$transformed_params params.var <- fit.var$transformed_params  rxModel_true <- function(){   ini({     cl <- params.true$beta[\"cl\"]  # Clearance     v1 <- params.true$beta[\"v1\"]  # Volume of central compartment     v2 <- params.true$beta[\"v2\"] # Volume of peripheral compartment     q <- params.true$beta[\"q\"]    # Inter-compartmental clearance     ka <- params.true$beta[\"ka\"]   # Absorption rate constant      eta_cl ~ params.true$Omega[1,1]     eta_v1 ~ params.true$Omega[2,2]     eta_v2 ~ params.true$Omega[3,3]     eta_q ~ params.true$Omega[4,4]     eta_ka ~ params.true$Omega[5,5]   })   model({     cl <- cl * exp(eta_cl)     v1 <- v1 * exp(eta_v1)     v2 <- v2 * exp(eta_v2)     q <- q * exp(eta_q)     ka <- ka * exp(eta_ka)     cp = linCmt(cl, v1, v2, q, ka)   }) } rxModel_covar <- function(){   ini({     cl <- params.covar$beta[\"cl\"]  # Clearance     v1 <- params.covar$beta[\"v1\"]  # Volume of central compartment     v2 <- params.covar$beta[\"v2\"] # Volume of peripheral compartment     q <- params.covar$beta[\"q\"]    # Inter-compartmental clearance     ka <- params.covar$beta[\"ka\"]   # Absorption rate constant      eta_cl ~ params.covar$Omega[1,1]     eta_v1 ~ params.covar$Omega[2,2]     eta_v2 ~ params.covar$Omega[3,3]     eta_q ~ params.covar$Omega[4,4]     eta_ka ~ params.covar$Omega[5,5]   })   model({     cl <- cl * exp(eta_cl)     v1 <- v1 * exp(eta_v1)     v2 <- v2 * exp(eta_v2)     q <- q * exp(eta_q)     ka <- ka * exp(eta_ka)     cp = linCmt(cl, v1, v2, q, ka)   }) } rxModel_var <- function(){   ini({     cl <- params.var$beta[\"cl\"]  # Clearance     v1 <- params.var$beta[\"v1\"]  # Volume of central compartment     v2 <- params.var$beta[\"v2\"] # Volume of peripheral compartment     q <- params.var$beta[\"q\"]    # Inter-compartmental clearance     ka <- params.var$beta[\"ka\"]   # Absorption rate constant      eta_cl ~ params.var$Omega[1,1]     eta_v1 ~ params.var$Omega[2,2]     eta_v2 ~ params.var$Omega[3,3]     eta_q ~ params.var$Omega[4,4]     eta_ka ~ params.var$Omega[5,5]   })   model({     cl <- cl * exp(eta_cl)     v1 <- v1 * exp(eta_v1)     v2 <- v2 * exp(eta_v2)     q <- q * exp(eta_q)     ka <- ka * exp(eta_ka)     cp = linCmt(cl, v1, v2, q, ka)   }) }  rxModel_true <- rxode2(rxModel_true()) rxModel_true <- rxModel_true$simulationModel rxModel_covar <- rxode2(rxModel_covar()) rxModel_covar <- rxModel_covar$simulationModel rxModel_var <- rxode2(rxModel_var()) rxModel_var <- rxModel_var$simulationModel time_points <- seq(0, 12, by = 0.01)  # Dense time points for smooth curves ev <- eventTable(amount.units=\"mg\", time.units=\"hours\") ev$add.dosing(dose = 100, nbr.doses = 2, dosing.interval = 6) ev$add.sampling(time_points)   sim_true <- rxSolve(rxModel_true, events = ev, cores = 0, nSub = 10000) sim_covar <- rxSolve(rxModel_covar, events = ev, cores = 0, nSub = 10000) sim_var <- rxSolve(rxModel_var, events = ev, cores = 0, nSub = 10000)  # Combine the confidence intervals with a label for the model ci_true <- as.data.frame(confint(sim_true, \"cp\", level=0.95)) %>%   mutate(Model = \"True parameters\") ## summarizing data...done ci_covar <- as.data.frame(confint(sim_covar, \"cp\", level=0.95)) %>%   mutate(Model = \"Covariance fit\") ## summarizing data...done ci_var <- as.data.frame(confint(sim_var, \"cp\", level=0.95)) %>%   mutate(Model = \"Variance fit\") ## summarizing data...done # Bind them together ci_true_covar <- bind_rows(ci_true, ci_covar) %>%   mutate(     p1 = as.numeric(as.character(p1)),     Percentile = factor(Percentile, levels = unique(Percentile[order(p1)]))   )  ci_true_var <- bind_rows(ci_true, ci_var) %>%   mutate(     p1 = as.numeric(as.character(p1)),     Percentile = factor(Percentile, levels = unique(Percentile[order(p1)]))   )   # Plot both models ggplot(ci_true_covar, aes(x = time, group = interaction(Model, Percentile))) +   geom_ribbon(aes(ymin = p2.5, ymax = p97.5, fill = Model),               alpha = 0.2, colour = NA) +   geom_line(aes(y = p50, colour = Model), size = 0.8) +   labs(     title = \"Central Concentration Simulations\",     x = \"Time\",     y = \"Central Concentration (mg/L)\"   ) +   theme_bw(base_size = 14) +   scale_colour_manual(values = c(\"True parameters\" = \"blue\",                                  \"Covariance fit\" = \"red\")) +   scale_fill_manual(values = c(\"True parameters\" = \"blue\",                                \"Covariance fit\" = \"red\")) +   coord_cartesian(xlim = c(0, 12), ylim = c(0, 7)) ## Warning: Using `size` aesthetic for lines was deprecated in ggplot2 3.4.0. ## ℹ Please use `linewidth` instead. ## This warning is displayed once every 8 hours. ## Call `lifecycle::last_lifecycle_warnings()` to see where this warning was ## generated. ggplot(ci_true_var, aes(x = time, group = interaction(Model, Percentile))) +   geom_ribbon(aes(ymin = p2.5, ymax = p97.5, fill = Model),               alpha = 0.2, colour = NA) +   geom_line(aes(y = p50, colour = Model), size = 0.8) +   labs(     title = \"Central Concentration Simulations\",     x = \"Time\",     y = \"Central Concentration (mg/L)\"   ) +   theme_bw(base_size = 14) +   scale_colour_manual(values = c(\"True parameters\" = \"blue\",                                  \"Variance fit\" = \"darkgreen\")) +   scale_fill_manual(values = c(\"True parameters\" = \"blue\",                                  \"Variance fit\" = \"darkgreen\")) +   coord_cartesian(xlim = c(0, 12), ylim = c(0, 7))"},{"path":"https://vanhasseltlab.github.io/admr/articles/variance.html","id":"best-practices","dir":"Articles","previous_headings":"Variance based modelling","what":"Best Practices","title":"Variance-only based modelling with admr","text":"recap, best practices variance-based (also covariance-based) modeling admr: Always check data missing values outliers Ensure time points consistent across subjects Consider impact dosing events analysis Start simple model gradually add complexity Use meaningful initial values parameters Consider parameter transformations better estimation Use multiple chains improve optimization Monitor convergence carefully Check parameter estimates biological plausibility Always examine convergence plots Validate model predictions observed data information, see package documentation vignettes.","code":""},{"path":"https://vanhasseltlab.github.io/admr/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"H. van de Beek. Author, maintainer. P..J. Välitalo. Author. L.B. Zwep. Author. J.G.C. van Hasselt. Author.","code":""},{"path":"https://vanhasseltlab.github.io/admr/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"van de Beek H, Välitalo P, Zwep L, van Hasselt J (2025). admr: Aggregate Data Modelling R. R package version 0.2.1, https://vanhasseltlab.github.io/admr.","code":"@Manual{,   title = {admr: Aggregate Data Modelling in R},   author = {H. {van de Beek} and P.A.J. Välitalo and L.B. Zwep and J.G.C. {van Hasselt}},   year = {2025},   note = {R package version 0.2.1},   url = {https://vanhasseltlab.github.io/admr}, }"},{"path":"https://vanhasseltlab.github.io/admr/index.html","id":"admr-aggregate-data-modeling-in-r","dir":"","previous_headings":"","what":"Aggregate Data Modelling in R","title":"Aggregate Data Modelling in R","text":"admr (Aggregate Data Modeling R) open-source R package designed facilitate pharmacometric modeling using summary-level data. enables users work aggregate data, mean observations variance-covariance matrices, fit pharmacokinetic pharmacodynamic (PK/PD) models efficiently. package implements newly developed Expectation-Maximization (EM) algorithm enhance computational performance provides tools advanced modeling applications.","code":""},{"path":"https://vanhasseltlab.github.io/admr/index.html","id":"overview","dir":"","previous_headings":"","what":"Overview","title":"Aggregate Data Modelling in R","text":"admr package provides comprehensive framework aggregate data modeling pharmacometrics, offering several key advantages: Efficient Parameter Estimation: Uses Iterative Reweighting Monte Carlo (IRMC) algorithm robust fast parameter estimation. Flexible Data Integration: Works individual-level aggregate data, making ideal meta-analyses literature-based modeling. Advanced Modeling Features: Supports complex PK/PD models various error structures parameter transformations. Comprehensive Diagnostics: Built-tools model assessment, convergence checking, parameter stability analysis.","code":""},{"path":"https://vanhasseltlab.github.io/admr/index.html","id":"key-features","dir":"","previous_headings":"","what":"Key Features","title":"Aggregate Data Modelling in R","text":"Efficient Model Fitting: Uses iterative reweighted Monte Carlo (IRMC) robust parameter estimation, improving speed scalability compared traditional Monte Carlo methods. Flexible Data Formats: Supports raw aggregate data formats, allowing integration summary-level data diverse sources, including published literature simulated models. Comprehensive Diagnostics: Built-tools model assessment, convergence checking, parameter stability analysis. Meta-Analysis Support: Facilitates model-based meta-analyses enabling combination summary data across studies. R Integration: Fully compatible R, leveraging popular pharmacometric modeling libraries like rxode2. Open-Source: Developed accessibility ease use pharmacometric community.","code":""},{"path":"https://vanhasseltlab.github.io/admr/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Aggregate Data Modelling in R","text":"R package. R required, RStudio recommended. can install development version admr GitHub :","code":"# install.packages(\"devtools\") devtools::install_github(\"vanhasseltlab/admr\")"},{"path":"https://vanhasseltlab.github.io/admr/index.html","id":"quick-start","dir":"","previous_headings":"","what":"Quick Start","title":"Aggregate Data Modelling in R","text":"complete example use admr fit pharmacokinetic model aggregate data:","code":"# Load required libraries library(admr) library(rxode2) #> rxode2 4.1.0 using 7 threads (see ?getRxThreads) #>   no cache: create with `rxCreateCache()` library(nlmixr2) #> ── Attaching packages ───────────────────────────────────────── nlmixr2 4.0.1 ── #> ✔ lotri        1.0.2     ✔ nlmixr2extra 3.0.2 #> ✔ nlmixr2data  2.0.9     ✔ nlmixr2plot  3.0.3 #> ✔ nlmixr2est   4.1.0 #> ── Optional Packages Loaded/Ignored ─────────────────────────── nlmixr2 4.0.1 ── #> ✖ babelmixr2     ✖ nonmem2rx #> ✖ ggPMX     ✖ posologyr #> ✖ monolix2rx     ✖ shinyMixR #> ✖ nlmixr2lib     ✖ xpose.nlmixr2 #> ✖ nlmixr2rpt #> ── Conflicts ───────────────────────────────────────────── nlmixr2conflicts() ── #> ✖ nlmixr2est::boxCox()     masks rxode2::boxCox() #> ✖ nlmixr2est::yeoJohnson() masks rxode2::yeoJohnson() library(dplyr) #>  #> Attaching package: 'dplyr' #> The following objects are masked from 'package:stats': #>  #>     filter, lag #> The following objects are masked from 'package:base': #>  #>     intersect, setdiff, setequal, union library(tidyr) library(mnorm)  # Load and prepare the simulated individual-level data data(examplomycin) examplomycin_wide <- examplomycin %>%   filter(EVID != 101) %>%   dplyr::select(ID, TIME, DV) %>%   pivot_wider(names_from = TIME, values_from = DV) %>%   dplyr::select(-c(1))  # Create aggregated data as example examplomycin_aggregated <- examplomycin_wide %>%   admr::meancov()  # Define RxODE model rxModel <- RxODE({   cp = linCmt(     cl,           # Clearance     v1,           # Volume of the central compartment     v2,           # Volume of the peripheral compartment     q,            # Inter-compartmental clearance     ka            # Absorption rate constant   ) }) #> using C compiler: 'gcc.exe (GCC) 14.2.0'  # Define prediction function predder <- function(time, theta_i, dose = 100) {   n_individuals <- nrow(theta_i)   if (is.null(n_individuals)) n_individuals <- 1      ev <- eventTable(amount.units=\"mg\", time.units=\"hours\")   ev$add.dosing(dose = dose, nbr.doses = 1, start.time = 0)   ev$add.sampling(time)      out <- rxSolve(rxModel, params = theta_i, events = ev, cores = 0)   cp_matrix <- matrix(out$cp, nrow = n_individuals, ncol = length(time),                       byrow = TRUE)   return(cp_matrix) }  # Create options opts <- genopts(   time = c(.1, .25, .5, 1, 2, 3, 5, 8, 12),   p = list(     beta = c(cl = 5, v1 = 10, v2 = 30, q = 10, ka = 1),     Omega = matrix(c(0.09, 0, 0, 0, 0,                     0, 0.09, 0, 0, 0,                     0, 0, 0.09, 0, 0,                     0, 0, 0, 0.09, 0,                     0, 0, 0, 0, 0.09), nrow = 5, ncol = 5),     Sigma_prop = 0.04   ),   nsim = 2500,   n = 500,   fo_appr = FALSE,   omega_expansion = 1.2,   f = predder )  # Fit model to data result <- fitIRMC(opts = opts, obs = examplomycin_aggregated, chains = 2) #> Chain 1: #> Iter | NLL and Parameters (11 values) #> -------------------------------------------------------------------------------- #>    1: -1839.577    1.609    2.303    3.401    2.303    0.000   -2.408   -2.408   -2.408   -2.408   -2.408   -3.219 #>  #> ### Wide Search Phase ### #>    2: -1845.241    1.601    2.309    3.404    2.284    0.020   -2.280   -2.169   -2.334   -2.245   -2.437   -3.235 #>    3: -1845.278    1.600    2.305    3.406    2.284    0.016   -2.287   -2.200   -2.344   -2.270   -2.412   -3.235 #>    4: -1845.279    1.600    2.305    3.406    2.284    0.016   -2.287   -2.199   -2.344   -2.269   -2.412   -3.235 #> Phase Wide Search Phase converged at iteration 4. #>  #> ### Focussed Search Phase ### #>    5: -1845.280    1.601    2.307    3.405    2.285    0.018   -2.286   -2.200   -2.343   -2.264   -2.411   -3.235 #>    6: -1845.280    1.601    2.307    3.405    2.285    0.018   -2.286   -2.200   -2.343   -2.264   -2.411   -3.235 #>    7: -1845.280    1.601    2.307    3.405    2.285    0.018   -2.286   -2.200   -2.343   -2.264   -2.411   -3.235 #>    8: -1845.280    1.601    2.307    3.405    2.285    0.018   -2.286   -2.200   -2.343   -2.264   -2.411   -3.235 #>    9: -1845.280    1.601    2.307    3.405    2.285    0.018   -2.286   -2.200   -2.343   -2.264   -2.411   -3.235 #> Phase Focussed Search Phase converged at iteration 9. #>  #> ### Fine-Tuning Phase ### #>   10: -1845.280    1.601    2.307    3.405    2.285    0.018   -2.286   -2.200   -2.343   -2.264   -2.411   -3.235 #>   11: -1845.280    1.601    2.307    3.405    2.285    0.018   -2.286   -2.200   -2.343   -2.264   -2.411   -3.235 #>   12: -1845.280    1.601    2.307    3.405    2.285    0.018   -2.286   -2.200   -2.343   -2.264   -2.411   -3.235 #> Phase Fine-Tuning Phase converged at iteration 12. #>  #> ### Precision Phase ### #>   13: -1845.280    1.601    2.307    3.405    2.285    0.018   -2.286   -2.201   -2.343   -2.265   -2.410   -3.235 #>   14: -1845.280    1.601    2.307    3.405    2.285    0.018   -2.286   -2.201   -2.343   -2.265   -2.410   -3.235 #> Phase Precision Phase converged at iteration 14. #>  #> Chain 1 Complete: Final NLL = -1845.280, Time Elapsed = 5.34 seconds #>   #> Phase Wide Search Phase converged at iteration 6. #> Phase Focussed Search Phase converged at iteration 12. #> Phase Fine-Tuning Phase converged at iteration 14. #> Phase Precision Phase converged at iteration 16. #>  #> Chain 2 Complete: Final NLL = -1845.281, Time Elapsed = 6.99 seconds #>  print(result) #> -- FitIRMC Summary -- #>  #> -- Objective Function and Information Criteria -- #>  Log-likelihood: -1845.2806 #>             AIC: 3701.56 #>             BIC: 3758.92 #> Condition#(Cov): 143.74 #> Condition#(Cor): 203.03 #>  #> -- Timing Information -- #>      Best Chain: 6.9939 seconds #>      All Chains: 12.3353 seconds #>      Covariance: 30.2940 seconds #>         Elapsed: 42.63 seconds #>  #> -- Population Parameters -- #> # A tibble: 6 × 6 #>   Parameter        Est.      SE  `%RSE` `Back-transformed(95%CI)` `BSV(CV%)` #>   <chr>           <dbl>   <dbl>   <dbl> <chr>                          <dbl> #> 1 cl             1.60    0.0153   0.955 4.96 (4.81, 5.11)               31.9 #> 2 v1             2.31    0.0839   3.64  10.04 (8.52, 11.84)             33.3 #> 3 v2             3.41    0.0393   1.16  30.12 (27.88, 32.53)            31.0 #> 4 q              2.28    0.0213   0.931 9.82 (9.42, 10.24)              32.2 #> 5 ka             0.0179  0.0792 441.    1.02 (0.87, 1.19)               30.0 #> 6 Residual Error 0.0394 NA       NA     0.0394                          NA   #>  #> -- Iteration Diagnostics -- #>  Iter | NLL and Parameters #> -------------------------------------------------------------------------------- #>    1: -1565.147 1.700 2.198 3.118 2.034 0.000 -2.665 -2.784 -2.129 -2.208 -2.463 -3.133 #>    2: -1842.631 1.605 2.411 3.389 2.288 0.089 -2.325 -1.946 -2.291 -2.121 -2.604 -3.234 #>    3: -1845.276 1.601 2.305 3.406 2.285 0.016 -2.285 -2.197 -2.345 -2.271 -2.413 -3.235 #>    4: -1845.277 1.600 2.305 3.406 2.284 0.016 -2.286 -2.197 -2.344 -2.268 -2.414 -3.235 #>    5: -1845.280 1.600 2.306 3.406 2.285 0.017 -2.286 -2.201 -2.342 -2.266 -2.410 -3.235 #>    ... (omitted iterations) ... #>   12: -1845.281 1.601 2.307 3.405 2.285 0.018 -2.286 -2.201 -2.343 -2.265 -2.410 -3.235 #>   13: -1845.280 1.601 2.307 3.405 2.285 0.018 -2.286 -2.201 -2.343 -2.265 -2.410 -3.235 #>   14: -1845.280 1.601 2.307 3.405 2.285 0.018 -2.286 -2.201 -2.343 -2.265 -2.410 -3.235 #>   15: -1845.280 1.601 2.307 3.405 2.285 0.018 -2.286 -2.201 -2.343 -2.265 -2.410 -3.235 #>   16: -1845.280 1.601 2.307 3.405 2.285 0.018 -2.286 -2.201 -2.343 -2.265 -2.410 -3.235"},{"path":"https://vanhasseltlab.github.io/admr/index.html","id":"documentation","dir":"","previous_headings":"","what":"Documentation","title":"Aggregate Data Modelling in R","text":"package documentation available https://vanhasseltlab.github.io/admr/. Key documentation sections include: Getting Started vignettes Function Reference Examples","code":""},{"path":"https://vanhasseltlab.github.io/admr/index.html","id":"use-cases","dir":"","previous_headings":"","what":"Use Cases","title":"Aggregate Data Modelling in R","text":"admr package particularly useful : Meta-Analysis: Combining data multiple studies individual-level data available Literature-Based Modeling: Fitting models published summary statistics Simulation Studies: Evaluating model performance aggregate data Population PK/PD: Fitting complex models summary-level data","code":""},{"path":"https://vanhasseltlab.github.io/admr/index.html","id":"getting-help","dir":"","previous_headings":"","what":"Getting Help","title":"Aggregate Data Modelling in R","text":"Check documentation Browse GitHub issues Create new issue reproducible example","code":""},{"path":"https://vanhasseltlab.github.io/admr/index.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Aggregate Data Modelling in R","text":"use admr research, please cite :","code":"citation(\"admr\")"},{"path":"https://vanhasseltlab.github.io/admr/index.html","id":"license","dir":"","previous_headings":"","what":"License","title":"Aggregate Data Modelling in R","text":"project licensed MIT License - see LICENSE file details.","code":""},{"path":"https://vanhasseltlab.github.io/admr/reference/admr-package.html","id":null,"dir":"Reference","previous_headings":"","what":"admr: Aggregate data modelling in R — admr-package","title":"admr: Aggregate data modelling in R — admr-package","text":"novel method aggregate data model using non-linear estimation techniques.","code":""},{"path":[]},{"path":"https://vanhasseltlab.github.io/admr/reference/admr-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"admr: Aggregate data modelling in R — admr-package","text":"H. van de Beek P..J. Välitalo","code":""},{"path":"https://vanhasseltlab.github.io/admr/reference/examplomycin.html","id":null,"dir":"Reference","previous_headings":"","what":"Examplomycin Dataset — examplomycin","title":"Examplomycin Dataset — examplomycin","text":"simulated dataset fictional drug examplomycin. dataset contains 500 subjects, 9 timepoints. generated using two-compartment pharmacokinetic model first-order absorption elimination. Random effects residual errors included simulate variability noise.","code":""},{"path":"https://vanhasseltlab.github.io/admr/reference/examplomycin.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Examplomycin Dataset — examplomycin","text":"","code":"examplomycin"},{"path":"https://vanhasseltlab.github.io/admr/reference/examplomycin.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Examplomycin Dataset — examplomycin","text":"data frame 4500 rows 6 variables: ID: Subject ID. TIME: Observation time (hours). DV: Observed drug concentration (mg/L). AMT: Amount drug administered (mg). EVID: Event type indicator (0 observation, 101 dosing). CMT: Compartment number (1 depot, 2 central).","code":""},{"path":"https://vanhasseltlab.github.io/admr/reference/examplomycin.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Examplomycin Dataset — examplomycin","text":"Generated using generate_data function.","code":""},{"path":"https://vanhasseltlab.github.io/admr/reference/examplomycin.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Examplomycin Dataset — examplomycin","text":"","code":"#' # Load required libraries library(admr)  # Load the dataset data(\"examplomycin\")  # View the first few rows head(examplomycin) #>    ID TIME    DV AMT EVID CMT #> 1 460 0.00 0.000 100  101   1 #> 2 460 0.10 0.752   0    0   2 #> 3 460 0.25 1.932   0    0   2 #> 4 460 0.50 3.694   0    0   2 #> 5 460 1.00 3.479   0    0   2 #> 6 460 2.00 4.003   0    0   2"},{"path":"https://vanhasseltlab.github.io/admr/reference/fitIRMC.html","id":null,"dir":"Reference","previous_headings":"","what":"Fit aggregate data using Iterative Reweighting with Monte Carlo updates — fitIRMC","title":"Fit aggregate data using Iterative Reweighting with Monte Carlo updates — fitIRMC","text":"fitIRMC implements Iterative Reweighting (IRMC) algorithm parameter estimation aggregate data models, iterating maximum likelihood updates weighted Monte Carlo updates. function uses nloptr instead optimx optimization includes additional features like multiple chains phase-based optimization.","code":""},{"path":"https://vanhasseltlab.github.io/admr/reference/fitIRMC.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fit aggregate data using Iterative Reweighting with Monte Carlo updates — fitIRMC","text":"","code":"fitIRMC(   opts,   obs,   maxiter = 100,   convcrit_nll = 1e-05,   single_dataframe = TRUE,   phase_fractions = c(0.2, 0.4, 0.2, 0.2),   max_worse_iterations = 10,   chains = 1,   perturbation = 0.1,   seed = 1,   use_grad = FALSE )"},{"path":"https://vanhasseltlab.github.io/admr/reference/fitIRMC.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fit aggregate data using Iterative Reweighting with Monte Carlo updates — fitIRMC","text":"opts list model options generated genopts(). Contains settings model, including prediction function, time points, parameter structure, simulation settings. obs Observed data aggregate form (mean covariance) matrix raw data. maxiter Maximum number iterations optimization algorithm. Default 100. convcrit_nll Convergence criterion negative log-likelihood. algorithm stops relative change negative log-likelihood less value. Default 1e-05. single_dataframe Logical indicating whether use single data frame (TRUE) multiple data frames (FALSE). Default TRUE. phase_fractions Vector fractions optimization phase. sum 1. Default c(0.2, 0.4, 0.2, 0.2). max_worse_iterations Maximum number consecutive worse iterations skipping phase. Default 10. chains Number chains run. Default 1. perturbation Perturbation factor initial parameter values chain. Default 0.1. seed Random seed reproducibility. Default 1. use_grad Logical indicating whether use gradient information optimization.","code":""},{"path":"https://vanhasseltlab.github.io/admr/reference/fitIRMC.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fit aggregate data using Iterative Reweighting with Monte Carlo updates — fitIRMC","text":"object class fit_admr_result containing: p: List parameter estimates iteration nll: Negative log-likelihood values time: Computation time iteration iter: Iteration number chain: Chain number (multiple chains used) phase: Optimization phase number","code":""},{"path":"https://vanhasseltlab.github.io/admr/reference/fitIRMC.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Fit aggregate data using Iterative Reweighting with Monte Carlo updates — fitIRMC","text":"function uses Iterative Reweighting algorithm Monte Carlo sampling optimization. includes several advanced features: Multiple optimization phases different convergence criteria Chains perturbed starting values Phase-based optimization automatic phase skipping Convergence checking based likelihood parameter stationarity optimization process divided phases, convergence criteria settings. algorithm can automatically skip phases optimization progressing.","code":""},{"path":"https://vanhasseltlab.github.io/admr/reference/fitIRMC.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fit aggregate data using Iterative Reweighting with Monte Carlo updates — fitIRMC","text":"","code":"# Load required libraries library(admr) library(rxode2) #> rxode2 4.1.1 using 2 threads (see ?getRxThreads) #>   no cache: create with `rxCreateCache()` library(nlmixr2) #> ── Attaching packages ───────────────────────────────────────── nlmixr2 4.0.1 ── #> ✔ lotri        1.0.2     ✔ nlmixr2extra 3.0.2 #> ✔ nlmixr2data  2.0.9     ✔ nlmixr2plot  3.0.3 #> ✔ nlmixr2est   4.1.1      #> ── Optional Packages Loaded/Ignored ─────────────────────────── nlmixr2 4.0.1 ── #> ✖ babelmixr2     ✖ nonmem2rx #> ✖ ggPMX     ✖ posologyr #> ✖ monolix2rx     ✖ shinyMixR #> ✖ nlmixr2lib     ✖ xpose.nlmixr2 #> ✖ nlmixr2rpt      #> ── Conflicts ───────────────────────────────────────────── nlmixr2conflicts() ── #> ✖ nlmixr2est::boxCox()     masks rxode2::boxCox() #> ✖ nlmixr2est::yeoJohnson() masks rxode2::yeoJohnson() library(dplyr) #>  #> Attaching package: ‘dplyr’ #> The following objects are masked from ‘package:stats’: #>  #>     filter, lag #> The following objects are masked from ‘package:base’: #>  #>     intersect, setdiff, setequal, union library(tidyr) library(mnorm)  # Load and prepare data data(examplomycin) examplomycin_wide <- examplomycin %>%   filter(EVID != 101) %>%   dplyr::select(ID, TIME, DV) %>%   pivot_wider(names_from = TIME, values_from = DV) %>%   dplyr::select(-c(1))  # Create aggregated data examplomycin_aggregated <- examplomycin_wide %>%   admr::meancov()  # Define RxODE model rxModel <- function(){ model({   # Parameters   ke = cl / v1             # Elimination rate constant   k12 = q / v1             # Rate constant for central to peripheral transfer   k21 = q / v2             # Rate constant for peripheral to central transfer    # Differential equations   d/dt(depot)    = -ka * depot   d/dt(central)  = ka * depot - ke * central - k12 * central + k21 * peripheral   d/dt(peripheral) = k12 * central - k21 * peripheral    # Concentration in central compartment   cp = central / v1 }) }  rxModel <- rxode2(rxModel) #>   #>   #> ℹ parameter labels from comments are typically ignored in non-interactive mode #> ℹ Need to run with the source intact to parse comments rxModel <- rxModel$simulationModel #>   #>   #> using C compiler: ‘gcc (Ubuntu 13.3.0-6ubuntu2~24.04) 13.3.0’   # Define prediction function predder <- function(time, theta_i, dose = 100) {   n_individuals <- nrow(theta_i)   if (is.null(n_individuals)) n_individuals <- 1    ev <- eventTable(amount.units=\"mg\", time.units=\"hours\")   ev$add.dosing(dose = dose, nbr.doses = 1, start.time = 0)   ev$add.sampling(time)    out <- rxSolve(rxModel, params = theta_i, events = ev, cores = 0)   cp_matrix <- matrix(out$cp, nrow = n_individuals, ncol = length(time),                       byrow = TRUE)   return(cp_matrix) }  # Create options opts <- genopts(   time = c(.1, .25, .5, 1, 2, 3, 5, 8, 12),   p = list(     beta = c(cl = 5, v1 = 10, v2 = 30, q = 10, ka = 1),     Omega = matrix(c(0.09, 0, 0, 0, 0,                      0, 0.09, 0, 0, 0,                      0, 0, 0.09, 0, 0,                      0, 0, 0, 0.09, 0,                      0, 0, 0, 0, 0.09), nrow = 5, ncol = 5),     Sigma_prop = 0.04   ),   nsim = 2500,   n = 500,   fo_appr = FALSE,   omega_expansion = 1,   f = predder )  # Run optimization result <- fitIRMC(opts, examplomycin_aggregated) #> Chain 1: #> Iter | NLL and Parameters (11 values) #> -------------------------------------------------------------------------------- #>    1:   70.389    1.609    2.303    3.401    2.303    0.000   -2.408   -2.408   -2.408   -2.408   -2.408   -3.219 #>  #> ### Wide Search Phase ### #>    2: 8980.099    1.592    4.303    2.776    3.112    2.000   -2.622   -1.782   -4.408   -3.384   -0.808   -2.831 #>    3: 2355.402   -0.408    2.303    2.738    2.995    0.000   -0.622   -2.060   -6.408   -5.012   -1.449   -2.096 #>    4: -1415.828    1.592    2.329    2.709    3.023    0.216   -2.622   -3.146   -5.235   -4.964   -2.509   -2.955 #>    5: -562.311    2.104    3.067    2.535    3.172    0.085   -0.622   -1.146   -7.235   -5.383   -1.219   -2.988 #>    6: -1593.680    1.541    2.335    2.465    3.198    0.025   -1.596   -3.146   -9.235   -4.394   -2.213   -3.035 #>    7: -1736.426    1.662    2.405    2.451    3.258    0.102   -2.199   -5.146   -9.255   -2.394   -1.363   -3.062 #>    8: -1561.368    1.578    2.348    2.428    3.081   -0.027   -1.742   -5.972  -10.276   -0.802   -1.462   -3.117 #>    9: -1772.619    1.644    2.321    2.420    3.325    0.047   -2.355   -6.735  -11.640   -1.977   -1.622   -3.131 #>   10: -1774.674    1.643    2.317    2.416    3.321    0.036   -2.298   -7.909  -11.692   -1.984   -1.624   -3.128 #>   11: -1770.642    1.632    2.376    2.417    3.344    0.105   -2.301   -6.470  -11.889   -2.083   -1.613   -3.128 #>   12: -1770.794    1.623    2.360    2.421    3.365    0.083   -2.355   -7.696  -11.958   -1.870   -1.715   -3.142 #>   13: -1769.597    1.624    2.351    2.425    3.357    0.081   -2.351   -8.703  -11.890   -1.806   -1.720   -3.134 #>   14: -1770.377    1.642    2.348    2.421    3.315    0.062   -2.268   -9.747  -11.914   -1.795   -1.566   -3.132 #>   15: -1767.866    1.619    2.334    2.419    3.305    0.036   -2.262   -8.551  -11.787   -1.806   -1.587   -3.134 #>   16: -1763.517    1.615    2.392    2.420    3.356    0.141   -2.342   -7.155  -11.733   -1.977   -1.585   -3.144 #>   17: -1765.093    1.645    2.388    2.414    3.272    0.092   -2.213   -8.509  -11.947   -1.602   -1.511   -3.146 #>   18: -1777.086    1.640    2.384    2.412    3.308    0.084   -2.364   -9.038  -12.193   -2.040   -1.609   -3.128 #>   19: -1776.439    1.640    2.381    2.409    3.297    0.080   -2.267  -10.058  -12.221   -1.886   -1.554   -3.135 #>   20: -1760.158    1.619    2.406    2.410    3.345    0.168   -2.280   -8.863  -12.065   -2.034   -1.525   -3.142 #>  #> ### Focussed Search Phase ### #>   21: -1766.286    1.626    2.378    2.408    3.292    0.060   -2.158   -9.798  -12.527   -1.632   -1.509   -3.133 #>   22: -1779.490    1.638    2.376    2.407    3.312    0.076   -2.369  -10.053  -12.760   -2.028   -1.612   -3.133 #>   23: -1780.168    1.636    2.374    2.405    3.308    0.077   -2.366  -10.656  -12.834   -1.998   -1.610   -3.130 #>   24: -1780.697    1.636    2.372    2.404    3.306    0.071   -2.363  -11.304  -12.906   -2.061   -1.564   -3.137 #>   25: -1781.029    1.638    2.371    2.401    3.302    0.066   -2.300  -11.937  -12.993   -1.981   -1.574   -3.132 #>   26: -1782.014    1.638    2.370    2.400    3.298    0.062   -2.338  -12.552  -13.055   -1.988   -1.580   -3.136 #>   27: -1783.109    1.637    2.369    2.398    3.309    0.068   -2.342  -13.049  -13.083   -2.032   -1.595   -3.136 #>   28: -1783.642    1.637    2.368    2.397    3.308    0.071   -2.340  -13.725  -13.162   -2.064   -1.596   -3.136 #>   29: -1784.110    1.637    2.368    2.396    3.308    0.070   -2.339  -14.334  -13.237   -2.063   -1.629   -3.135 #>   30: -1784.720    1.638    2.368    2.394    3.306    0.065   -2.345  -14.934  -13.313   -2.064   -1.600   -3.138 #>   31: -1785.148    1.636    2.368    2.393    3.308    0.068   -2.348  -15.544  -13.392   -2.098   -1.600   -3.140 #>   32: -1784.573    1.636    2.368    2.395    3.306    0.067   -2.344  -16.189  -13.473   -2.033   -1.600   -3.140 #>   33: -1784.967    1.636    2.368    2.394    3.306    0.067   -2.374  -16.755  -13.543   -2.063   -1.602   -3.141 #>   34: -1785.241    1.637    2.367    2.393    3.308    0.067   -2.374  -17.362  -13.619   -2.095   -1.603   -3.142 #>   35: -1785.491    1.637    2.367    2.392    3.308    0.067   -2.374  -17.970  -13.694   -2.062   -1.602   -3.143 #>   36: -1785.725    1.637    2.367    2.392    3.308    0.066   -2.374  -18.579  -13.770   -2.030   -1.603   -3.143 #>   37: -1785.813    1.637    2.367    2.392    3.308    0.066   -2.374  -19.151  -13.841   -2.098   -1.603   -3.139 #>   38: -1785.844    1.637    2.367    2.392    3.308    0.066   -2.374  -19.760  -13.916   -2.065   -1.602   -3.139 #>   39: -1785.912    1.637    2.367    2.391    3.311    0.066   -2.374  -20.331  -13.987   -2.065   -1.602   -3.143 #>   40: -1785.960    1.637    2.367    2.391    3.311    0.067   -2.337  -20.901  -14.051   -2.033   -1.602   -3.143 #>   41: -1785.978    1.637    2.367    2.391    3.311    0.066   -2.337  -21.509  -14.126   -2.066   -1.602   -3.143 #>   42: -1786.004    1.637    2.367    2.391    3.311    0.066   -2.367  -22.078  -14.196   -2.036   -1.602   -3.143 #>   43: -1786.022    1.637    2.367    2.391    3.312    0.066   -2.367  -22.686  -14.272   -2.069   -1.602   -3.143 #>   44: -1786.034    1.637    2.367    2.391    3.312    0.066   -2.367  -23.294  -14.347   -2.036   -1.602   -3.143 #>   45: -1786.022    1.637    2.367    2.391    3.312    0.066   -2.367  -23.903  -14.423   -2.069   -1.602   -3.143 #>   46: -1786.041    1.637    2.367    2.391    3.312    0.066   -2.367  -24.511  -14.498   -2.036   -1.602   -3.143 #>   47: -1786.002    1.637    2.367    2.391    3.315    0.066   -2.367  -25.043  -14.498   -2.071   -1.602   -3.143 #>   48: -1786.025    1.637    2.367    2.391    3.315    0.066   -2.332  -25.577  -14.465   -2.040   -1.602   -3.143 #>   49: -1786.025    1.637    2.367    2.391    3.315    0.066   -2.332  -26.077  -14.465   -2.040   -1.602   -3.143 #>   50: -1785.972    1.637    2.367    2.391    3.317    0.066   -2.366  -26.503  -14.465   -2.078   -1.602   -3.143 #>   51: -1785.974    1.637    2.367    2.391    3.317    0.067   -2.366  -27.003  -14.465   -2.078   -1.602   -3.143 #>   52: -1786.032    1.637    2.367    2.391    3.317    0.067   -2.366  -27.003  -15.036   -2.007   -1.602   -3.143 #>   53: -1786.062    1.637    2.367    2.391    3.317    0.063   -2.363  -27.003  -15.568   -2.039   -1.602   -3.143 #>   54: -1786.071    1.637    2.367    2.391    3.317    0.063   -2.363  -27.003  -16.068   -2.039   -1.602   -3.143 #>   55: -1786.071    1.637    2.367    2.391    3.317    0.063   -2.363  -27.003  -16.568   -2.039   -1.602   -3.143 #>   56: -1786.071    1.637    2.367    2.391    3.317    0.063   -2.363  -27.003  -17.068   -2.039   -1.602   -3.143 #>   57: -1786.080    1.636    2.367    2.391    3.317    0.063   -2.363  -27.003  -17.567   -2.039   -1.602   -3.143 #>   58: -1786.088    1.636    2.367    2.391    3.317    0.063   -2.363  -27.003  -18.067   -2.039   -1.602   -3.143 #>   59: -1786.088    1.636    2.367    2.391    3.317    0.063   -2.363  -27.003  -18.567   -2.039   -1.602   -3.143 #>   60: -1786.094    1.636    2.367    2.391    3.317    0.063   -2.363  -27.003  -19.067   -2.039   -1.602   -3.143 #>  #> ### Fine-Tuning Phase ### #>   61: -1786.078    1.636    2.367    2.391    3.317    0.063   -2.363  -27.236  -19.067   -2.056   -1.602   -3.143 #>   62: -1785.916    1.636    2.367    2.391    3.317    0.063   -2.363  -27.447  -19.049   -2.057   -1.622   -3.143 #>   63: -1785.880    1.636    2.367    2.391    3.317    0.063   -2.363  -27.662  -19.032   -2.075   -1.622   -3.143 #>   64: -1785.968    1.636    2.367    2.391    3.317    0.064   -2.363  -27.662  -19.337   -2.038   -1.622   -3.126 #>   65: -1786.066    1.636    2.367    2.391    3.317    0.064   -2.363  -27.662  -19.569   -2.038   -1.604   -3.126 #>   66: -1786.066    1.636    2.367    2.391    3.317    0.064   -2.363  -27.662  -19.819   -2.038   -1.604   -3.126 #>   67: -1786.066    1.636    2.367    2.391    3.317    0.064   -2.363  -27.662  -20.069   -2.038   -1.604   -3.126 #>   68: -1786.066    1.636    2.367    2.391    3.317    0.064   -2.363  -27.662  -20.319   -2.038   -1.604   -3.126 #>   69: -1786.063    1.636    2.367    2.391    3.317    0.062   -2.363  -27.662  -20.570   -2.038   -1.604   -3.126 #>   70: -1786.094    1.636    2.367    2.391    3.316    0.063   -2.362  -27.662  -20.841   -2.036   -1.604   -3.142 #>  #> ### Precision Phase ### #>   71: -1786.114    1.635    2.367    2.391    3.316    0.064   -2.362  -27.013  -19.067   -2.039   -1.602   -3.143 #>   72: -1786.123    1.634    2.367    2.391    3.317    0.065   -2.363  -27.023  -19.067   -2.039   -1.602   -3.143 #>   73: -1786.113    1.635    2.367    2.391    3.317    0.065   -2.363  -27.033  -19.067   -2.039   -1.603   -3.143 #>   74: -1786.124    1.634    2.367    2.391    3.317    0.066   -2.363  -27.042  -19.068   -2.039   -1.603   -3.143 #>   75: -1786.114    1.635    2.367    2.391    3.316    0.067   -2.363  -27.052  -19.068   -2.039   -1.603   -3.143 #>   76: -1786.121    1.634    2.367    2.391    3.315    0.066   -2.363  -27.062  -19.068   -2.040   -1.603   -3.143 #>   77: -1786.112    1.635    2.367    2.391    3.316    0.067   -2.363  -27.071  -19.068   -2.040   -1.603   -3.143 #>   78: -1786.120    1.634    2.367    2.391    3.315    0.066   -2.363  -27.081  -19.068   -2.040   -1.604   -3.143 #>   79: -1786.111    1.635    2.367    2.391    3.316    0.067   -2.363  -27.091  -19.068   -2.040   -1.604   -3.143 #>   80: -1786.118    1.634    2.367    2.391    3.315    0.066   -2.363  -27.100  -19.068   -2.040   -1.604   -3.143 #>   81: -1786.108    1.635    2.367    2.391    3.316    0.067   -2.363  -27.110  -19.068   -2.041   -1.604   -3.143 #>   82: -1786.116    1.634    2.367    2.391    3.315    0.066   -2.363  -27.120  -19.068   -2.041   -1.604   -3.143 #>   83: -1786.108    1.635    2.367    2.391    3.316    0.067   -2.363  -27.130  -19.068   -2.041   -1.604   -3.143 #>   84: -1786.116    1.634    2.367    2.391    3.315    0.066   -2.363  -27.139  -19.068   -2.041   -1.604   -3.143 #>  #> Chain 1 Complete: Final NLL = -1786.124, Time Elapsed = 90.18 seconds #>   print(result) #> -- FitIRMC Summary -- #>  #> -- Objective Function and Information Criteria -- #>  Log-likelihood: -1786.1235 #>             AIC: 3583.25 #>             BIC: 3640.61 #> Condition#(Cov): 29.39 #> Condition#(Cor): 35.43 #>  #> -- Timing Information -- #>      Best Chain: 90.1788 seconds #>      All Chains: 90.1811 seconds #>      Covariance: 13.0886 seconds #>         Elapsed: 103.27 seconds #>  #> -- Population Parameters -- #> # A tibble: 6 × 6 #>   Parameter        Est.      SE `%RSE` `Back-transformed(95%CI)` `BSV(CV%)` #>   <chr>           <dbl>   <dbl>  <dbl> <chr>                          <dbl> #> 1 cl             1.63    0.0141  0.861 5.12 (4.98, 5.27)          30.7      #> 2 v1             2.37    0.0380  1.61  10.67 (9.90, 11.50)         0.000134 #> 3 v2             2.39    0.0206  0.863 10.92 (10.49, 11.38)        0.00724  #> 4 q              3.32    0.0282  0.849 27.57 (26.09, 29.13)       36.1      #> 5 ka             0.0660  0.0375 56.8   1.07 (0.99, 1.15)          44.9      #> 6 Residual Error 0.0432 NA      NA     0.0432                     NA        #>  #> -- Iteration Diagnostics -- #>  Iter | NLL and Parameters #> -------------------------------------------------------------------------------- #>    1: 70.389 1.609 2.303 3.401 2.303 0.000 -2.408 -2.408 -2.408 -2.408 -2.408 -3.219 #>    2: 8980.099 1.592 4.303 2.776 3.112 2.000 -2.622 -1.782 -4.408 -3.384 -0.808 -2.831 #>    3: 2355.402 -0.408 2.303 2.738 2.995 0.000 -0.622 -2.060 -6.408 -5.012 -1.449 -2.096 #>    4: -1415.828 1.592 2.329 2.709 3.023 0.216 -2.622 -3.146 -5.235 -4.964 -2.509 -2.955 #>    5: -562.311 2.104 3.067 2.535 3.172 0.085 -0.622 -1.146 -7.235 -5.383 -1.219 -2.988 #>    ... (omitted iterations) ... #>   80: -1786.118 1.634 2.367 2.391 3.315 0.066 -2.363 -27.100 -19.068 -2.040 -1.604 -3.143 #>   81: -1786.108 1.635 2.367 2.391 3.316 0.067 -2.363 -27.110 -19.068 -2.041 -1.604 -3.143 #>   82: -1786.116 1.634 2.367 2.391 3.315 0.066 -2.363 -27.120 -19.068 -2.041 -1.604 -3.143 #>   83: -1786.108 1.635 2.367 2.391 3.316 0.067 -2.363 -27.130 -19.068 -2.041 -1.604 -3.143 #>   84: -1786.116 1.634 2.367 2.391 3.315 0.066 -2.363 -27.139 -19.068 -2.041 -1.604 -3.143 #>"},{"path":"https://vanhasseltlab.github.io/admr/reference/fitMC.html","id":null,"dir":"Reference","previous_headings":"","what":"Fit aggregate data using the bobyqa algorithm with Monte Carlo updates — fitMC","title":"Fit aggregate data using the bobyqa algorithm with Monte Carlo updates — fitMC","text":"fitMC implements bobyqa algorithm parameter estimation aggregate data models, iterating maximum likelihood updates Monte Carlo updates. iteration creates new Monte Carlo samples updates parameter values. function used compare performance different implementations aggregate data modeling.","code":""},{"path":"https://vanhasseltlab.github.io/admr/reference/fitMC.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fit aggregate data using the bobyqa algorithm with Monte Carlo updates — fitMC","text":"","code":"fitMC(   opts,   obs,   maxiter = 5000,   convcrit_nll = 1e-05,   single_dataframe = TRUE,   chains = 1,   perturbation = 0.1,   seed = 1,   use_grad = FALSE )"},{"path":"https://vanhasseltlab.github.io/admr/reference/fitMC.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fit aggregate data using the bobyqa algorithm with Monte Carlo updates — fitMC","text":"opts list model options generated genopts(). Contains settings model, including prediction function, time points, parameter structure, simulation settings. obs Observed data aggregate form (mean covariance) matrix raw data. maxiter Maximum number iterations optimization algorithm. Default 100. convcrit_nll Convergence criterion negative log-likelihood. algorithm stops relative change negative log-likelihood less value. Default 1e-05. single_dataframe Logical indicating whether use single data frame (TRUE) multiple data frames (FALSE). Default TRUE. chains Number chains run. Default 1. perturbation Perturbation factor initial parameter values chain. Default 0.1. seed Random seed reproducibility. Default 1. use_grad Logical indicating whether use gradient information optimization.","code":""},{"path":"https://vanhasseltlab.github.io/admr/reference/fitMC.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fit aggregate data using the bobyqa algorithm with Monte Carlo updates — fitMC","text":"object class fit_admr_result containing: p: List parameter estimates iteration nll: Negative log-likelihood values time: Computation time iteration iter: Iteration number chain: Chain number (used standard MC algorithm) phase: Optimization phase number","code":""},{"path":"https://vanhasseltlab.github.io/admr/reference/fitMC.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Fit aggregate data using the bobyqa algorithm with Monte Carlo updates — fitMC","text":"function uses Monte Carlo algorithm Monte Carlo sampling optimization. optimization process performed using bobyqa algorithm, suitable non-linear optimization problems. function supports single multiple data frames, allowing flexibility observed data structured.","code":""},{"path":"https://vanhasseltlab.github.io/admr/reference/fitMC.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fit aggregate data using the bobyqa algorithm with Monte Carlo updates — fitMC","text":"","code":"# Load required libraries library(admr) library(rxode2) library(nlmixr2) library(dplyr) library(tidyr) library(mnorm)  # Load and prepare data data(examplomycin) examplomycin_wide <- examplomycin %>%   filter(EVID != 101) %>%   dplyr::select(ID, TIME, DV) %>%   pivot_wider(names_from = TIME, values_from = DV) %>%   dplyr::select(-c(1))  # Create aggregated data examplomycin_aggregated <- examplomycin_wide %>%   admr::meancov()  # Define RxODE model rxModel <- function(){ model({   # Parameters   ke = cl / v1             # Elimination rate constant   k12 = q / v1             # Rate constant for central to peripheral transfer   k21 = q / v2             # Rate constant for peripheral to central transfer    # Differential equations   d/dt(depot)    = -ka * depot   d/dt(central)  = ka * depot - ke * central - k12 * central + k21 * peripheral   d/dt(peripheral) = k12 * central - k21 * peripheral    # Concentration in central compartment   cp = central / v1 }) }  rxModel <- rxode2(rxModel) #>   #>   #> ℹ parameter labels from comments are typically ignored in non-interactive mode #> ℹ Need to run with the source intact to parse comments rxModel <- rxModel$simulationModel #>   #>   #> using C compiler: ‘gcc (Ubuntu 13.3.0-6ubuntu2~24.04) 13.3.0’  # Define prediction function predder <- function(time, theta_i, dose = 100) {   n_individuals <- nrow(theta_i)   if (is.null(n_individuals)) n_individuals <- 1    ev <- eventTable(amount.units=\"mg\", time.units=\"hours\")   ev$add.dosing(dose = dose, nbr.doses = 1, start.time = 0)   ev$add.sampling(time)    out <- rxSolve(rxModel, params = theta_i, events = ev, cores = 0)   cp_matrix <- matrix(out$cp, nrow = n_individuals, ncol = length(time),                       byrow = TRUE)   return(cp_matrix) }  # Create options opts <- genopts(   time = c(.1, .25, .5, 1, 2, 3, 5, 8, 12),   p = list(     beta = c(cl = 5, v1 = 10, v2 = 30, q = 10, ka = 1),     Omega = matrix(c(0.09, 0, 0, 0, 0,                      0, 0.09, 0, 0, 0,                      0, 0, 0.09, 0, 0,                      0, 0, 0, 0.09, 0,                      0, 0, 0, 0, 0.09), nrow = 5, ncol = 5),     Sigma_prop = 0.04   ),   nsim = 2500,   n = 500,   fo_appr = FALSE,   omega_expansion = 1.2,   f = predder )  # Run optimization result <- fitMC(opts, examplomycin_aggregated) #> Error: Not a matrix. print(result) #> Error: object 'result' not found"},{"path":"https://vanhasseltlab.github.io/admr/reference/gen_pop_EV.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute expected population-level mean and covariance — gen_pop_EV","title":"Compute expected population-level mean and covariance — gen_pop_EV","text":"gen_pop_EV computes expected population-level mean covariance model predictions using either first-order approximation (FO) Monte Carlo (MC) methods. function core component aggregate data modeling framework, used generate expected values model fitting optimization.","code":""},{"path":"https://vanhasseltlab.github.io/admr/reference/gen_pop_EV.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute expected population-level mean and covariance — gen_pop_EV","text":"","code":"gen_pop_EV(opts)"},{"path":"https://vanhasseltlab.github.io/admr/reference/gen_pop_EV.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute expected population-level mean and covariance — gen_pop_EV","text":"opts list model options generated genopts(). Contains settings model, including: Prediction function (f) Time points prediction Population parameters (beta) -subject variability (Omega) Method selection (fo_appr) Number Monte Carlo samples (nsim) Omega expansion factor","code":""},{"path":"https://vanhasseltlab.github.io/admr/reference/gen_pop_EV.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute expected population-level mean and covariance — gen_pop_EV","text":"list containing: E: Expected mean model predictions time point V: Expected covariance matrix predictions across time points","code":""},{"path":"https://vanhasseltlab.github.io/admr/reference/gen_pop_EV.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compute expected population-level mean and covariance — gen_pop_EV","text":"function implements two methods computing population expectations: First-Order (FO) Approximation (opts$fo_appr TRUE): Uses linearization around random effects (η) Steps: . Generate random effects samples b. Compute importance sampling weights based η distribution c. individual: Compute FOCE approximation mean covariance Apply importance sampling weights d. Combine weighted results across individuals Advantages: Computationally efficient complex models Good accuracy nearly linear systems Used : Number Monte Carlo samples small (nsim < 10) Model approximately linear random effects Monte Carlo (MC) Approximation (opts$fo_appr FALSE): Uses direct simulation estimate expectations Steps: . Generate random effects samples b. Compute full model predictions sample c. Calculate empirical mean covariance d. Apply importance sampling omega expansion used Advantages: linearization assumptions accurate highly nonlinear models Used : Sufficient Monte Carlo samples available High accuracy required Model highly nonlinear choice methods depends : Model complexity nonlinearity Required accuracy Computational resources Number available Monte Carlo samples","code":""},{"path":"https://vanhasseltlab.github.io/admr/reference/gen_pop_EV.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute expected population-level mean and covariance — gen_pop_EV","text":"","code":"# Load required libraries library(admr) library(rxode2) library(nlmixr2) library(dplyr) library(tidyr) library(mnorm)   # Define RxODE model rxModel <- function(){ model({   # Parameters   ke = cl / v1             # Elimination rate constant   k12 = q / v1             # Rate constant for central to peripheral transfer   k21 = q / v2             # Rate constant for peripheral to central transfer    # Differential equations   d/dt(depot)    = -ka * depot   d/dt(central)  = ka * depot - ke * central - k12 * central + k21 * peripheral   d/dt(peripheral) = k12 * central - k21 * peripheral    # Concentration in central compartment   cp = central / v1 }) }  rxModel <- rxode2(rxModel) #>   #>   #> ℹ parameter labels from comments are typically ignored in non-interactive mode #> ℹ Need to run with the source intact to parse comments rxModel <- rxModel$simulationModel #>   #>    # Define prediction function for a two-compartment model predder <- function(time, theta_i, dose = 100) {   n_individuals <- nrow(theta_i)   if (is.null(n_individuals)) n_individuals <- 1    # Create event table for dosing and sampling   ev <- eventTable(amount.units=\"mg\", time.units=\"hours\")   ev$add.dosing(dose = dose, nbr.doses = 1, start.time = 0)   ev$add.sampling(time)    # Solve ODE system   out <- rxSolve(rxModel, params = theta_i, events = ev, cores = 0)    # Return matrix of predictions   matrix(out$cp, nrow = n_individuals, ncol = length(time), byrow = TRUE) }  # Create options for a two-compartment model opts <- genopts(   f = predder,   time = c(.1, .25, .5, 1, 2, 3, 5, 8, 12),   p = list(     # Population parameters (fixed effects)     beta = c(cl = 5,    # Clearance (L/h)             v1 = 10,    # Central volume (L)             v2 = 30,    # Peripheral volume (L)             q = 10,     # Inter-compartmental clearance (L/h)             ka = 1),    # Absorption rate (1/h)      # Between-subject variability (30% CV on all parameters)     Omega = matrix(c(0.09, 0, 0, 0, 0,                     0, 0.09, 0, 0, 0,                     0, 0, 0.09, 0, 0,                     0, 0, 0, 0.09, 0,                     0, 0, 0, 0, 0.09), nrow = 5, ncol = 5),      # Residual error (30% CV)     Sigma_prop = 0.04   ),   nsim = 2500,  # Number of Monte Carlo samples   n = 2500,      # Number of individuals   fo_appr = FALSE  # Use Monte Carlo approximation )  # Generate population expectations ev <- gen_pop_EV(opts)"},{"path":"https://vanhasseltlab.github.io/admr/reference/gendataset.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate a simulated dataset — gendataset","title":"Generate a simulated dataset — gendataset","text":"gendataset generates simulated dataset based model structure random effects specified options. function can generate data either raw format nlmixr format, optional residual error.","code":""},{"path":"https://vanhasseltlab.github.io/admr/reference/gendataset.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate a simulated dataset — gendataset","text":"","code":"gendataset(opts, seed = 1, reserr = TRUE, nlmixrform = FALSE)"},{"path":"https://vanhasseltlab.github.io/admr/reference/gendataset.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate a simulated dataset — gendataset","text":"opts list model options generated genopts(). Contains settings model, including prediction function, time points, parameter structure, simulation settings. seed Random seed reproducibility. Default 1. reserr Logical indicating whether add residual error simulated data. Default TRUE. nlmixrform Logical indicating whether return data nlmixr format. TRUE, returns data frame columns: dv, time, id, amt, evid, cmt. FALSE, returns matrix simulated observations. Default FALSE.","code":""},{"path":"https://vanhasseltlab.github.io/admr/reference/gendataset.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate a simulated dataset — gendataset","text":"nlmixrform FALSE, returns matrix simulated observations dimensions nsim x length(time). nlmixrform TRUE, returns data frame nlmixr format columns: dv: Dependent variable (e.g., concentration measurements) time: Observation time points id: Subject identifier amt: Dose amount (NA observations, typically mg) evid: Event identifier (101 dosing, 0 observation) cmt: Compartment number (1 depot/dosing, 2 central/observation)","code":""},{"path":"https://vanhasseltlab.github.io/admr/reference/gendataset.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generate a simulated dataset — gendataset","text":"function generates simulated data following steps: Generating random effects (η) multivariate normal distribution Computing individual parameters (θᵢ) using log-normal transformations Simulating concentration-time profiles using prediction function Adding residual error components requested: - Proportional error: y = f(t,θ)(1 + ε), ε ~ N(0,σ²_prop) - Additive error: y = f(t,θ) + ε, ε ~ N(0,σ²_add) Formatting output either raw matrix nlmixr-compatible format residual error model can include: Proportional error (specified Sigma_prop) Additive error (specified Sigma_add) Combined error model (Sigma_prop Sigma_add) function supports reproducible simulations seed parameter compatible population PK modeling simulation workflows.","code":""},{"path":"https://vanhasseltlab.github.io/admr/reference/gendataset.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate a simulated dataset — gendataset","text":"","code":"# Load required libraries library(admr) library(rxode2) library(nlmixr2) library(dplyr) library(tidyr) library(mnorm)  # Define RxODE model rxModel <- function(){ model({   # Parameters   ke = cl / v1             # Elimination rate constant   k12 = q / v1             # Rate constant for central to peripheral transfer   k21 = q / v2             # Rate constant for peripheral to central transfer    # Differential equations   d/dt(depot)    = -ka * depot   d/dt(central)  = ka * depot - ke * central - k12 * central + k21 * peripheral   d/dt(peripheral) = k12 * central - k21 * peripheral    # Concentration in central compartment   cp = central / v1 }) }  rxModel <- rxode2(rxModel) #>   #>   #> ℹ parameter labels from comments are typically ignored in non-interactive mode #> ℹ Need to run with the source intact to parse comments rxModel <- rxModel$simulationModel #>   #>    # Define prediction function for a two-compartment model predder <- function(time, theta_i, dose = 100) {   n_individuals <- nrow(theta_i)   if (is.null(n_individuals)) n_individuals <- 1    # Create event table for dosing and sampling   ev <- eventTable(amount.units=\"mg\", time.units=\"hours\")   ev$add.dosing(dose = dose, nbr.doses = 1, start.time = 0)   ev$add.sampling(time)    # Solve ODE system   out <- rxSolve(rxModel, params = theta_i, events = ev, cores = 0)    # Return matrix of predictions   matrix(out$cp, nrow = n_individuals, ncol = length(time), byrow = TRUE) }  # Create options for a two-compartment model opts <- genopts(   f = predder,   time = c(.1, .25, .5, 1, 2, 3, 5, 8, 12),   p = list(     # Population parameters (fixed effects)     beta = c(cl = 5,    # Clearance (L/h)             v1 = 10,    # Central volume (L)             v2 = 30,    # Peripheral volume (L)             q = 10,     # Inter-compartmental clearance (L/h)             ka = 1),    # Absorption rate (1/h)      # Between-subject variability (30% CV on all parameters)     Omega = matrix(c(0.09, 0, 0, 0, 0,                     0, 0.09, 0, 0, 0,                     0, 0, 0.09, 0, 0,                     0, 0, 0, 0.09, 0,                     0, 0, 0, 0, 0.09), nrow = 5, ncol = 5),      # Residual error (20% CV)     Sigma_prop = 0.04   ),   nsim = 2500,  # Number of Monte Carlo samples   n = 500,      # Number of individuals   fo_appr = FALSE  # Use Monte Carlo approximation )  # Generate a dataset with 100 individuals dataset <- gendataset(opts, n = 100)"},{"path":"https://vanhasseltlab.github.io/admr/reference/genfitfunc.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate a fitting function for optimization — genfitfunc","title":"Generate a fitting function for optimization — genfitfunc","text":"genfitfunc generates fitting function optimization computes negative log-likelihood model given observed data current parameter estimates. function handles raw data aggregate data (mean covariance) formats.","code":""},{"path":"https://vanhasseltlab.github.io/admr/reference/genfitfunc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate a fitting function for optimization — genfitfunc","text":"","code":"genfitfunc(opts, obs)"},{"path":"https://vanhasseltlab.github.io/admr/reference/genfitfunc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate a fitting function for optimization — genfitfunc","text":"opts list model options generated genopts(). Contains settings model, including: f: Prediction function model time: Vector observation times p: List parameter values structure nsim: Number Monte Carlo samples n: Number individuals pt: Parameter values transformed scale ptrans: Parameter transformation function obs Observed data one two formats: 1. Aggregate form: List elements: - E: Vector means time point - V: Covariance matrix observations 2. Raw data matrix: - Rows: Individual observations (nsim) - Columns: Time points","code":""},{"path":"https://vanhasseltlab.github.io/admr/reference/genfitfunc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate a fitting function for optimization — genfitfunc","text":"function signature function(p, givedetails = FALSE, opts_overrides) : p: Parameter values (transformed untransformed) givedetails: TRUE, returns additional attributes: - EV: Expected values (mean covariance) - obs: Observed data - nllfun: Negative log-likelihood function - opts: Model options used opts_overrides: Optional list override model options Returns: Negative log-likelihood value","code":""},{"path":"https://vanhasseltlab.github.io/admr/reference/genfitfunc.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generate a fitting function for optimization — genfitfunc","text":"Algorithm Steps: Data Preparation: Validates input data format Converts raw data aggregate form needed Uses expected data observations provided Parameter Processing: Handles transformed untransformed parameters Updates model options current parameters Likelihood Computation: Generates expected values using gen_pop_EV Computes covariance matrix inverse Calculates negative log-likelihood Error Handling: Checks matrix inversion problems Validates data dimensions Ensures proper parameter transformations Mathematical Details: Negative Log-Likelihood: $$-2\\log L = n\\log|V| + (y - \\mu)^T V^{-1} (y - \\mu)$$ : - n: Number individuals - V: Model-predicted covariance matrix - y: Observed means - μ: Model-predicted means Parameter Transformations: - Log transform positive parameters - Logit transform bounded parameters - Identity unrestricted parameters","code":""},{"path":"https://vanhasseltlab.github.io/admr/reference/genfitfunc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate a fitting function for optimization — genfitfunc","text":"","code":"# Load required libraries library(admr) library(rxode2) library(nlmixr2) library(dplyr) library(tidyr) library(mnorm)   # Load and prepare data data(examplomycin) examplomycin_wide <- examplomycin %>%   filter(EVID != 101) %>%   dplyr::select(ID, TIME, DV) %>%   pivot_wider(names_from = TIME, values_from = DV) %>%   dplyr::select(-c(1))  # Create aggregated data examplomycin_aggregated <- examplomycin_wide %>%   admr::meancov()  # Define RxODE model rxModel <- function(){ model({   # Parameters   ke = cl / v1             # Elimination rate constant   k12 = q / v1             # Rate constant for central to peripheral transfer   k21 = q / v2             # Rate constant for peripheral to central transfer    # Differential equations   d/dt(depot)    = -ka * depot   d/dt(central)  = ka * depot - ke * central - k12 * central + k21 * peripheral   d/dt(peripheral) = k12 * central - k21 * peripheral    # Concentration in central compartment   cp = central / v1 }) }  rxModel <- rxode2(rxModel) #>   #>   #> ℹ parameter labels from comments are typically ignored in non-interactive mode #> ℹ Need to run with the source intact to parse comments rxModel <- rxModel$simulationModel #>   #>    # Define prediction function for a two-compartment model predder <- function(time, theta_i, dose = 100) {   n_individuals <- nrow(theta_i)   if (is.null(n_individuals)) n_individuals <- 1    # Create event table for dosing and sampling   ev <- eventTable(amount.units=\"mg\", time.units=\"hours\")   ev$add.dosing(dose = dose, nbr.doses = 1, start.time = 0)   ev$add.sampling(time)    # Solve ODE system   out <- rxSolve(rxModel, params = theta_i, events = ev, cores = 0)    # Return matrix of predictions   matrix(out$cp, nrow = n_individuals, ncol = length(time), byrow = TRUE) }  # Create options for a two-compartment model opts <- genopts(   f = predder,   time = c(.1, .25, .5, 1, 2, 3, 5, 8, 12),   p = list(     # Population parameters (fixed effects)     beta = c(cl = 5,    # Clearance (L/h)             v1 = 10,    # Central volume (L)             v2 = 30,    # Peripheral volume (L)             q = 10,     # Inter-compartmental clearance (L/h)             ka = 1),    # Absorption rate (1/h)      # Between-subject variability (30% CV on all parameters)     Omega = matrix(c(0.09, 0, 0, 0, 0,                     0, 0.09, 0, 0, 0,                     0, 0, 0.09, 0, 0,                     0, 0, 0, 0.09, 0,                     0, 0, 0, 0, 0.09), nrow = 5, ncol = 5),      # Residual error (20% CV)     Sigma_prop = 0.04   ),   nsim = 2500,  # Number of Monte Carlo samples   n = 500,      # Number of individuals   fo_appr = FALSE  # Use Monte Carlo approximation )  # Generate objective function for optimization objfun <- genfitfunc(opts, examplomycin_aggregated)  # Test the objective function with initial parameters init_params <- opts$p nll <- objfun(init_params)"},{"path":"https://vanhasseltlab.github.io/admr/reference/genopts.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate options for aggregate data modeling — genopts","title":"Generate options for aggregate data modeling — genopts","text":"genopts initializes generates core options settings aggregate data modeling optimization. creates comprehensive options object contains necessary information model fitting, including random effects, simulation settings, likelihood approximations. function main entry point setting aggregate data modeling package.","code":""},{"path":"https://vanhasseltlab.github.io/admr/reference/genopts.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate options for aggregate data modeling — genopts","text":"","code":"genopts(   f,   time,   p,   h,   nsim = 1,   n = 30,   adist = NULL,   interact = TRUE,   fo_appr = (nsim < 10),   biseq = NA,   omega_expansion = 1,   single_betas = NA,   p_thetai = function(p, origbeta, bi) {      dmnorm(bi, mean = log(p$beta/origbeta),     sigma = p$Omega, log = TRUE)$den  },   g = function(beta, bi = rep(0, length(beta)), ai) { beta * exp(bi)  },   no_cov = F )"},{"path":"https://vanhasseltlab.github.io/admr/reference/genopts.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate options for aggregate data modeling — genopts","text":"f prediction function simulates model output given parameters time points. function signature function(time, theta_i, ...) : time: Vector time points theta_i: Matrix individual parameters Returns: Matrix predictions time Vector time points evaluate model predictions. p List containing initial parameter values structure: beta: Vector population parameters (fixed effects) Omega: Covariance matrix random effects (-subject variability) Sigma_prop: Proportional error variance (optional) Sigma_add: Additive error variance (optional) h error function computes variance predictions. provided, default function used adds proportional additive error components. nsim Number Monte Carlo samples per iteration. Default 1. n Number individuals dataset. Used OFV, AIC, BIC calculation. Default 30. adist Distribution random effects. Default NULL (normal distribution). interact Logical indicating whether use FOCEI interaction. Default TRUE. fo_appr Logical indicating whether use first-order approximation. Default TRUE nsim < 10, FALSE otherwise. biseq Sequence random effects. Default NA (generated internally). omega_expansion Factor expand covariance matrix estimation. Default 1. single_betas Matrix beta parameters multiple models. Default NA. p_thetai Function compute log-density random effects. Default multivariate normal density. g Function transform population parameters individual parameters. Default exponential transformation. no_cov Logical indicating whether ignore covariance error model. Default FALSE.","code":""},{"path":"https://vanhasseltlab.github.io/admr/reference/genopts.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate options for aggregate data modeling — genopts","text":"list containing: f: prediction function time: Time points evaluation p: Parameter structure initial values h: error function nsim: Number Monte Carlo samples n: Number individuals adist: Distribution random effects interact: FOCEI interaction flag fo_appr: First-order approximation flag biseq: Random effects sequence omega_expansion: Covariance expansion factor single_betas: Beta parameters multiple models p_thetai: Random effects density function g: Parameter transformation function pt: Transformed initial parameters ptrans: Function back-transform parameters pderiv: Function compute parameter derivatives d_g_d_beta: Derivative g respect beta d_g_d_bi: Derivative g respect random effects d_bi_d_omega: Derivative random effects respect Omega d_omega_d_Omega: Derivative transformed Omega respect untransformed no_cov: Logical indicating whether ignore covariance","code":""},{"path":"https://vanhasseltlab.github.io/admr/reference/genopts.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generate options for aggregate data modeling — genopts","text":"function performs several key operations: Parameter Transformation: - Converts parameters optimization scale - Computes derivatives optimization - Handles fixed parameters Random Effects Generation: - Uses Sobol sequences quasi-random sampling - Applies normal quantile transformation - Supports custom distributions Error Function Setup: - Handles proportional error: y = f(t,θ)(1 + ε) - Handles additive error: y = f(t,θ) + ε - Combines error types Key features: Automatic derivative computation parameter transformations Support multiple models parameter structures Flexible error model specification Efficient random effects generation","code":""},{"path":"https://vanhasseltlab.github.io/admr/reference/genopts.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate options for aggregate data modeling — genopts","text":"","code":"# Load required libraries library(admr) library(rxode2) library(nlmixr2) library(dplyr) library(tidyr) library(mnorm)   # Define prediction function for a two-compartment model predder <- function(time, theta_i, dose = 100) {   n_individuals <- nrow(theta_i)   if (is.null(n_individuals)) n_individuals <- 1    # Create event table for dosing and sampling   ev <- eventTable(amount.units=\"mg\", time.units=\"hours\")   ev$add.dosing(dose = dose, nbr.doses = 1, start.time = 0)   ev$add.sampling(time)    # Solve ODE system   out <- rxSolve(rxModel, params = theta_i, events = ev, cores = 0)    # Return matrix of predictions   matrix(out$cp, nrow = n_individuals, ncol = length(time), byrow = TRUE) }  # Create options for a two-compartment model opts <- genopts(   f = predder,   time = c(.1, .25, .5, 1, 2, 3, 5, 8, 12),   p = list(     # Population parameters (fixed effects)     beta = c(cl = 5,    # Clearance (L/h)             v1 = 10,    # Central volume (L)             v2 = 30,    # Peripheral volume (L)             q = 10,     # Inter-compartmental clearance (L/h)             ka = 1),    # Absorption rate (1/h)      # Between-subject variability (30% CV on all parameters)     Omega = matrix(c(0.09, 0, 0, 0, 0,                     0, 0.09, 0, 0, 0,                     0, 0, 0.09, 0, 0,                     0, 0, 0, 0.09, 0,                     0, 0, 0, 0, 0.09), nrow = 5, ncol = 5),      # Residual error (20% CV)     Sigma_prop = 0.04   ),   nsim = 2500,  # Number of Monte Carlo samples   n = 500,      # Number of individuals   fo_appr = FALSE,  # Use Monte Carlo approximation   omega_expansion = 1.2  # Expand covariance during estimation )"},{"path":"https://vanhasseltlab.github.io/admr/reference/meancov.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute mean and covariance of a matrix — meancov","title":"Compute mean and covariance of a matrix — meancov","text":"meancov computes mean covariance matrix, optionally weights. function used convert raw data aggregate form (mean covariance) use aggregate data modeling.","code":""},{"path":"https://vanhasseltlab.github.io/admr/reference/meancov.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute mean and covariance of a matrix — meancov","text":"","code":"meancov(m, wt)"},{"path":"https://vanhasseltlab.github.io/admr/reference/meancov.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute mean and covariance of a matrix — meancov","text":"m numeric matrix data frame containing observations. row represents individual, column represents time point. pharmacometric data, columns typically represent concentration measurements different time points. wt Optional vector weights observation. provided, observations weighted equally. Weights can used account different sample sizes reliability different data sources.","code":""},{"path":"https://vanhasseltlab.github.io/admr/reference/meancov.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute mean and covariance of a matrix — meancov","text":"list containing: E: Vector means time point (population typical values) V: Covariance matrix representing variability individuals","code":""},{"path":"https://vanhasseltlab.github.io/admr/reference/meancov.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compute mean and covariance of a matrix — meancov","text":"function computes: mean column (time point) using colMeans unweighted data weighted means weighted data covariance matrix using cov.wt maximum likelihood estimation, provides unbiased estimates population covariance maximum likelihood estimation method used : provides unbiased estimates covariance matrix appropriate aggregate data modeling want estimate population parameters handles balanced unbalanced designs optional weights Key features: Handles missing data automatically underlying cov.wt function Provides numerically stable computations Can used raw PK data simulated data Supports weighted calculations meta-analysis combined analysis","code":""},{"path":"https://vanhasseltlab.github.io/admr/reference/meancov.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute mean and covariance of a matrix — meancov","text":"","code":"# Load required libraries library(admr) library(rxode2)  # Create a matrix of concentration measurements # 10 subjects measured at 10 time points m <- matrix(rnorm(100), nrow = 10, ncol = 10)  # Compute unweighted mean and covariance # Useful for single-study analysis result <- meancov(m)  # Compute weighted mean and covariance # Useful for meta-analysis or when combining studies weights <- runif(10)  # weights could represent study sizes result_weighted <- meancov(m, weights)"},{"path":"https://vanhasseltlab.github.io/admr/reference/omegas.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a covariance matrix with specified diagonal and off-diagonal values — omegas","title":"Create a covariance matrix with specified diagonal and off-diagonal values — omegas","text":"omegas creates covariance matrix specified diagonal -diagonal values. function useful creating initial fixed covariance matrices random effects pharmacometric models.","code":""},{"path":"https://vanhasseltlab.github.io/admr/reference/omegas.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a covariance matrix with specified diagonal and off-diagonal values — omegas","text":"","code":"omegas(diag, offdiag, n_om)"},{"path":"https://vanhasseltlab.github.io/admr/reference/omegas.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a covariance matrix with specified diagonal and off-diagonal values — omegas","text":"diag Value diagonal elements matrix. represents variance random effect. log-normal distributions, typically squared coefficient variation (CV²) log scale. offdiag Value -diagonal elements matrix. represents covariance random effects. value 0 indicates independence random effects. n_om Size matrix (number random effects). match number random effects model (e.g., 2 CL V one-compartment model).","code":""},{"path":"https://vanhasseltlab.github.io/admr/reference/omegas.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a covariance matrix with specified diagonal and off-diagonal values — omegas","text":"symmetric matrix size n_om x n_om : Diagonal elements equal diag (variances) -diagonal elements equal offdiag (covariances)","code":""},{"path":"https://vanhasseltlab.github.io/admr/reference/omegas.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create a covariance matrix with specified diagonal and off-diagonal values — omegas","text":"function creates symmetric covariance matrix random effects : Diagonal elements (ω²) represent -subject variability -diagonal elements (ω_ij) represent correlations parameters resulting matrix must positive definite valid computations Common use cases include: Initial estimates model fitting: - Setting diagonal elements expected variability (e.g., 0.09 30% CV) - Starting zero correlations (offdiag = 0) Simulation studies: - Specifying known parameter variability - Testing impact parameter correlations Sensitivity analysis: - Evaluating model behavior different variability assumptions - Assessing impact parameter correlations Mathematical details: log-normal distributions: CV ≈ sqrt(exp(ω²) - 1) Correlation ρ_ij = ω_ij / sqrt(ω_ii * ω_jj) Matrix must positive definite: eigenvalues > 0","code":""},{"path":"https://vanhasseltlab.github.io/admr/reference/omegas.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a covariance matrix with specified diagonal and off-diagonal values — omegas","text":"","code":"# Load required libraries library(admr) library(rxode2)  # Create a diagonal matrix for a one-compartment model # 30% CV on CL and V (ω² = 0.09 for each) omega1 <- omegas(0.09, 0, 2)  # Create a matrix with correlations for a two-compartment model # 30% CV on all parameters (CL, V1, Q, V2) # Correlation of 0.3 between parameters omega2 <- omegas(0.09, 0.03, 4)  # Create a matrix for testing parameter correlations # High variability (50% CV, ω² = 0.25) and strong correlations (0.1) omega3 <- omegas(0.25, 0.1, 3)"},{"path":"https://vanhasseltlab.github.io/admr/reference/p_to_optim.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert parameters to optimizable form — p_to_optim","title":"Convert parameters to optimizable form — p_to_optim","text":"p_to_optim converts parameter list form suitable optimization transforming parameters computing derivatives. function handles transformation fixed random effect parameters.","code":""},{"path":"https://vanhasseltlab.github.io/admr/reference/p_to_optim.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert parameters to optimizable form — p_to_optim","text":"","code":"p_to_optim(p)"},{"path":"https://vanhasseltlab.github.io/admr/reference/p_to_optim.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert parameters to optimizable form — p_to_optim","text":"p list containing parameter structure: beta: Vector population parameters (fixed effects) e.g., clearance (CL), volume (V), absorption rate (ka) Omega: Covariance matrix random effects (-subject variability) diagonal elements variances, -diagonal covariances Sigma_prop: Proportional error variance (optional) represents CV² residual error Sigma_add: Additive error variance (optional) represents constant error magnitude","code":""},{"path":"https://vanhasseltlab.github.io/admr/reference/p_to_optim.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert parameters to optimizable form — p_to_optim","text":"list containing: values: Vector transformed parameter values optimization scale backtransformfunc: Function convert optimized values back original scale d_psi_d_psitrans_long: Function computing long-form parameter derivatives d_psi_d_psitrans_short: Function computing short-form parameter derivatives d_bi_d_omega: Derivatives random effects respect Omega elements d_omega_d_Omega: Derivatives transformed Omega respect untransformed","code":""},{"path":"https://vanhasseltlab.github.io/admr/reference/p_to_optim.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Convert parameters to optimizable form — p_to_optim","text":"Parameter Transformations: Population Parameters (beta): - Log transformation positive parameters - Identity transformation unrestricted parameters - Logit transformation parameters bounded 0 1 Variance Components (Omega diagonal): - Log transformation ensure positivity - Typically represents -subject variability Correlation Components (Omega -diagonal): - Inverse hyperbolic tangent (atanh) transformation - Ensures correlations remain -1 1 Residual Error (Sigma): - Log transformation variance parameters - Handles proportional additive error structures Derivative Computations: First-order derivatives optimization algorithms Chain rule applied composed transformations Separate handling variance correlation parameters Support dense sparse matrices Special Features: Handles fixed parameters (specified character strings) Preserves parameter names throughout transformations Automatic conversion exponential error proportional Validates parameter values transformations","code":""},{"path":"https://vanhasseltlab.github.io/admr/reference/p_to_optim.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert parameters to optimizable form — p_to_optim","text":"","code":"# Load required libraries library(admr) library(rxode2)  # Define a two-compartment model parameters p <- list(   # Population parameters (fixed effects)   beta = c(cl = 5,    # Clearance (L/h)           v1 = 10,    # Central volume (L)           v2 = 30,    # Peripheral volume (L)           q = 10,     # Inter-compartmental clearance (L/h)           ka = 1),    # Absorption rate (1/h)    # Between-subject variability (30% CV on all parameters)   Omega = matrix(c(0.09, 0, 0, 0, 0,                   0, 0.09, 0, 0, 0,                   0, 0, 0.09, 0, 0,                   0, 0, 0, 0.09, 0,                   0, 0, 0, 0, 0.09), nrow = 5, ncol = 5),    # Residual error (20% CV)   Sigma_prop = 0.04 )  # Convert to optimization scale p_optim <- p_to_optim(p)  # Back-transform to original scale p_orig <- p_optim$backtransformfunc(p_optim$values)"},{"path":"https://vanhasseltlab.github.io/admr/reference/plot.fit_admr_result.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot diagnostics of fitIRMC results — plot.fit_admr_result","title":"Plot diagnostics of fitIRMC results — plot.fit_admr_result","text":"Plot diagnostics fitIRMC results","code":""},{"path":"https://vanhasseltlab.github.io/admr/reference/plot.fit_admr_result.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot diagnostics of fitIRMC results — plot.fit_admr_result","text":"","code":"# S3 method for class 'fit_admr_result' plot(x, ...)"},{"path":"https://vanhasseltlab.github.io/admr/reference/plot.fit_admr_result.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot diagnostics of fitIRMC results — plot.fit_admr_result","text":"x fitted model object returned fitIRMC ... Additional arguments (used)","code":""},{"path":"https://vanhasseltlab.github.io/admr/reference/print.fit_admr_result.html","id":null,"dir":"Reference","previous_headings":"","what":"Print fitIRMC results — print.fit_admr_result","title":"Print fitIRMC results — print.fit_admr_result","text":"Print fitIRMC results","code":""},{"path":"https://vanhasseltlab.github.io/admr/reference/print.fit_admr_result.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print fitIRMC results — print.fit_admr_result","text":"","code":"# S3 method for class 'fit_admr_result' print(x, ...)"},{"path":"https://vanhasseltlab.github.io/admr/reference/print.fit_admr_result.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print fitIRMC results — print.fit_admr_result","text":"x fitted model object returned fitIRMC ... Additional arguments (used)","code":""},{"path":"https://vanhasseltlab.github.io/admr/reference/timedIRMC.html","id":null,"dir":"Reference","previous_headings":"","what":"Fit aggregate data using Iterative Reweighting with Monte Carlo updates — timedIRMC","title":"Fit aggregate data using Iterative Reweighting with Monte Carlo updates — timedIRMC","text":"timedIRMC implements Iterative Reweighting (IRMC) algorithm parameter estimation aggregate data models, iterating maximum likelihood updates weighted Monte Carlo updates. function used compare performance different implementations aggregate data modeling.","code":""},{"path":"https://vanhasseltlab.github.io/admr/reference/timedIRMC.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fit aggregate data using Iterative Reweighting with Monte Carlo updates — timedIRMC","text":"","code":"timedIRMC(init, opts, obs, maxiter = 100, convcrit_nll = 5e-04, nomap = TRUE)"},{"path":"https://vanhasseltlab.github.io/admr/reference/timedIRMC.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fit aggregate data using Iterative Reweighting with Monte Carlo updates — timedIRMC","text":"init Initial parameter values optimization. transformed parameters generated opts$pt. opts list model options generated genopts(). Contains settings model, including prediction function, time points, parameter structure, simulation settings. obs Observed data aggregate form (mean covariance) matrix raw data. maxiter Maximum number iterations optimization algorithm. Default 100. convcrit_nll Convergence criterion negative log-likelihood. algorithm stops relative change negative log-likelihood less value. Default 5e-04. nomap Logical indicating whether use multiple models (FALSE) single model (TRUE). Default TRUE.","code":""},{"path":"https://vanhasseltlab.github.io/admr/reference/timedIRMC.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fit aggregate data using Iterative Reweighting with Monte Carlo updates — timedIRMC","text":"data frame containing: p: List parameter estimates iteration nll: Negative log-likelihood values time: Computation time iteration iter: Iteration number","code":""},{"path":"https://vanhasseltlab.github.io/admr/reference/timedIRMC.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Fit aggregate data using Iterative Reweighting with Monte Carlo updates — timedIRMC","text":"function uses Iterative Reweighting algorithm Monte Carlo sampling optimization. iteration, generates Monte Carlo samples updates parameter estimates using weighted importance sampling. algorithm continues convergence maximum number iterations reached.","code":""},{"path":"https://vanhasseltlab.github.io/admr/reference/timedIRMC.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fit aggregate data using Iterative Reweighting with Monte Carlo updates — timedIRMC","text":"","code":"# Load required libraries library(admr) library(rxode2) library(nlmixr2) library(dplyr) library(tidyr) library(mnorm)  # Load and prepare data data(examplomycin) examplomycin_wide <- examplomycin %>%   filter(EVID != 101) %>%   dplyr::select(ID, TIME, DV) %>%   pivot_wider(names_from = TIME, values_from = DV) %>%   dplyr::select(-c(1))  # Create aggregated data examplomycin_aggregated <- examplomycin_wide %>%   admr::meancov()  # Define RxODE model rxModel <- function(){ model({   # Parameters   ke = cl / v1             # Elimination rate constant   k12 = q / v1             # Rate constant for central to peripheral transfer   k21 = q / v2             # Rate constant for peripheral to central transfer    # Differential equations   d/dt(depot)    = -ka * depot   d/dt(central)  = ka * depot - ke * central - k12 * central + k21 * peripheral   d/dt(peripheral) = k12 * central - k21 * peripheral    # Concentration in central compartment   cp = central / v1 }) }  rxModel <- rxode2(rxModel) #>   #>   #> ℹ parameter labels from comments are typically ignored in non-interactive mode #> ℹ Need to run with the source intact to parse comments rxModel <- rxModel$simulationModel #>   #>    # Define prediction function predder <- function(time, theta_i, dose = 100) {   n_individuals <- nrow(theta_i)   if (is.null(n_individuals)) n_individuals <- 1    ev <- eventTable(amount.units=\"mg\", time.units=\"hours\")   ev$add.dosing(dose = dose, nbr.doses = 1, start.time = 0)   ev$add.sampling(time)    out <- rxSolve(rxModel, params = theta_i, events = ev, cores = 0)   cp_matrix <- matrix(out$cp, nrow = n_individuals, ncol = length(time),                       byrow = TRUE)   return(cp_matrix) }  # Create options opts <- genopts(   time = c(.1, .25, .5, 1, 2, 3, 5, 8, 12),   p = list(     beta = c(cl = 5, v1 = 10, v2 = 30, q = 10, ka = 1),     Omega = matrix(c(0.09, 0, 0, 0, 0,                      0, 0.09, 0, 0, 0,                      0, 0, 0.09, 0, 0,                      0, 0, 0, 0.09, 0,                      0, 0, 0, 0, 0.09), nrow = 5, ncol = 5),     Sigma_prop = 0.04   ),   nsim = 2500,   n = 500,   fo_appr = FALSE,   omega_expansion = 1.2,   f = predder )  # Run optimization result <- timedIRMC(opts$pt, opts, examplomycin_aggregated) #> iteration 1, nll=58.6588992213695 #> iteration 2, nll=10120.0652052777 #> iteration 3, nll=976.217989450599 #> iteration 4, nll=1902.74575614608 #> iteration 5, nll=4.37702663109096 #> iteration 6, nll=-1281.31566755092 #> iteration 7, nll=-1737.5996228288 #> iteration 8, nll=-1834.58029289539 #> iteration 9, nll=-1845.11490679444 #> iteration 10, nll=-1845.11667765342 #> iteration 11, nll=-1845.15311166459 #> iteration 12, nll=-1845.13996335289 #> iteration 13, nll=-1845.14145074914 #> iteration 14, nll=-1845.14150897451 #> should break now due to no difference between OFV and appr OFV print(result) #> # A tibble: 14 × 5 #>    p               nll appr_nll time                 iter #>    <list>        <dbl>    <dbl> <dttm>              <dbl> #>  1 <dbl [11]>    58.7      58.7 2025-11-28 09:47:21     1 #>  2 <dbl [11]> 10120.    -1498.  2025-11-28 09:47:23     2 #>  3 <dbl [11]>   976.     -773.  2025-11-28 09:47:24     3 #>  4 <dbl [11]>  1903.    -1679.  2025-11-28 09:47:30     4 #>  5 <dbl [11]>     4.38  -1780.  2025-11-28 09:47:33     5 #>  6 <dbl [11]> -1281.    -1806.  2025-11-28 09:47:35     6 #>  7 <dbl [11]> -1738.    -1825.  2025-11-28 09:47:36     7 #>  8 <dbl [11]> -1835.    -1841.  2025-11-28 09:47:37     8 #>  9 <dbl [11]> -1845.    -1845.  2025-11-28 09:47:38     9 #> 10 <dbl [11]> -1845.    -1845.  2025-11-28 09:47:40    10 #> 11 <dbl [11]> -1845.    -1845.  2025-11-28 09:47:40    11 #> 12 <dbl [11]> -1845.    -1845.  2025-11-28 09:47:41    12 #> 13 <dbl [11]> -1845.    -1845.  2025-11-28 09:47:41    13 #> 14 <dbl [11]> -1845.    -1845.  2025-11-28 09:47:41    14"},{"path":"https://vanhasseltlab.github.io/admr/reference/timedbobyqa.html","id":null,"dir":"Reference","previous_headings":"","what":"Fit aggregate data using the bobyqa algorithm with Monte Carlo updates — timedbobyqa","title":"Fit aggregate data using the bobyqa algorithm with Monte Carlo updates — timedbobyqa","text":"timedbobyqa implements bobyqa algorithm parameter estimation aggregate data models, iterating maximum likelihood updates Monte Carlo updates. iteration creates new Monte Carlo samples updates parameter values. function used compare performance different implementations aggregate data modeling.","code":""},{"path":"https://vanhasseltlab.github.io/admr/reference/timedbobyqa.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fit aggregate data using the bobyqa algorithm with Monte Carlo updates — timedbobyqa","text":"","code":"timedbobyqa(init, opts, obs, nomap = TRUE)"},{"path":"https://vanhasseltlab.github.io/admr/reference/timedbobyqa.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fit aggregate data using the bobyqa algorithm with Monte Carlo updates — timedbobyqa","text":"init Initial parameter values optimization. transformed parameters generated opts$pt. opts list model options generated genopts(). Contains settings model, including prediction function, time points, parameter structure, simulation settings. obs Observed data aggregate form (mean covariance) matrix raw data. nomap Logical indicating whether use multiple models (FALSE) single model (TRUE). Default TRUE.","code":""},{"path":"https://vanhasseltlab.github.io/admr/reference/timedbobyqa.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fit aggregate data using the bobyqa algorithm with Monte Carlo updates — timedbobyqa","text":"data frame containing: p: List parameter estimates iteration nll: Negative log-likelihood values time: Computation time iteration iter: Iteration number","code":""},{"path":"https://vanhasseltlab.github.io/admr/reference/timedbobyqa.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Fit aggregate data using the bobyqa algorithm with Monte Carlo updates — timedbobyqa","text":"function uses bobyqa algorithm optimx package optimization. performs Monte Carlo sampling iteration update parameter estimates. algorithm continues convergence maximum number iterations reached.","code":""},{"path":"https://vanhasseltlab.github.io/admr/reference/timedbobyqa.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fit aggregate data using the bobyqa algorithm with Monte Carlo updates — timedbobyqa","text":"","code":"# Load required libraries library(admr) library(rxode2) library(nlmixr2) library(dplyr) library(tidyr) library(mnorm)  # Load and prepare data data(examplomycin) examplomycin_wide <- examplomycin %>%   filter(EVID != 101) %>%   dplyr::select(ID, TIME, DV) %>%   pivot_wider(names_from = TIME, values_from = DV) %>%   dplyr::select(-c(1))  # Create aggregated data examplomycin_aggregated <- examplomycin_wide %>%   admr::meancov()  # Define RxODE model rxModel <- function(){ model({   # Parameters   ke = cl / v1             # Elimination rate constant   k12 = q / v1             # Rate constant for central to peripheral transfer   k21 = q / v2             # Rate constant for peripheral to central transfer    # Differential equations   d/dt(depot)    = -ka * depot   d/dt(central)  = ka * depot - ke * central - k12 * central + k21 * peripheral   d/dt(peripheral) = k12 * central - k21 * peripheral    # Concentration in central compartment   cp = central / v1 }) }  rxModel <- rxode2(rxModel) #>   #>   #> ℹ parameter labels from comments are typically ignored in non-interactive mode #> ℹ Need to run with the source intact to parse comments rxModel <- rxModel$simulationModel #>   #>    # Define prediction function predder <- function(time, theta_i, dose = 100) {   n_individuals <- nrow(theta_i)   if (is.null(n_individuals)) n_individuals <- 1    ev <- eventTable(amount.units=\"mg\", time.units=\"hours\")   ev$add.dosing(dose = dose, nbr.doses = 1, start.time = 0)   ev$add.sampling(time)    out <- rxSolve(rxModel, params = theta_i, events = ev, cores = 0)   cp_matrix <- matrix(out$cp, nrow = n_individuals, ncol = length(time),                       byrow = TRUE)   return(cp_matrix) }  # Create options opts <- genopts(   time = c(.1, .25, .5, 1, 2, 3, 5, 8, 12),   p = list(     beta = c(cl = 5, v1 = 10, v2 = 30, q = 10, ka = 1),     Omega = matrix(c(0.09, 0, 0, 0, 0,                      0, 0.09, 0, 0, 0,                      0, 0, 0.09, 0, 0,                      0, 0, 0, 0.09, 0,                      0, 0, 0, 0, 0.09), nrow = 5, ncol = 5),     Sigma_prop = 0.04   ),   nsim = 2500,   n = 500,   fo_appr = FALSE,   omega_expansion = 1.2,   f = predder )  # Run optimization result <- timedbobyqa(opts$pt, opts, examplomycin_aggregated) #> Error: Not a matrix. print(result) #> Error: object 'result' not found"},{"path":[]},{"path":"https://vanhasseltlab.github.io/admr/news/index.html","id":"admr-020","dir":"Changelog","previous_headings":"","what":"admr 0.2.0","title":"admr 0.2.0","text":"Initial release admr package preprint submission Updated documentation vignettes Bug fixes performance improvements","code":""},{"path":"https://vanhasseltlab.github.io/admr/news/index.html","id":"admr-010","dir":"Changelog","previous_headings":"","what":"admr 0.1.0","title":"admr 0.1.0","text":"Initial Github submission.","code":""}]
