[{"path":"https://hiddevandebeek.github.io/admr/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2024 H. van de Beek Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://hiddevandebeek.github.io/admr/articles/admr.html","id":"introduction-to-aggregate-data-modeling-with-admr","dir":"Articles","previous_headings":"","what":"Introduction to Aggregate Data Modeling with admr","title":"Get started with admr","text":"vignette provides comprehensive introduction using admr package aggregate data modeling pharmacometrics. ’ll cover basic concepts, data preparation, model specification, advanced features.","code":""},{"path":"https://hiddevandebeek.github.io/admr/articles/admr.html","id":"what-is-aggregate-data-modeling","dir":"Articles","previous_headings":"Introduction to Aggregate Data Modeling with admr","what":"What is Aggregate Data Modeling?","title":"Get started with admr","text":"Aggregate data modeling powerful approach pharmacometrics allows work summary-level data instead individual-level observations. particularly useful : Individual-level data available (e.g., published literature) need combine data multiple studies want perform meta-analyses ’re working simulated data want reduce computational burden admr package implements Iterative Reweighting Monte Carlo (IRMC) algorithm, efficiently fits models aggregate data iteratively updating parameter estimates using weighted importance sampling.","code":""},{"path":"https://hiddevandebeek.github.io/admr/articles/admr.html","id":"required-packages","dir":"Articles","previous_headings":"Introduction to Aggregate Data Modeling with admr","what":"Required Packages","title":"Get started with admr","text":"","code":"library(admr) library(rxode2) library(nlmixr2) library(dplyr) library(tidyr) library(mnorm) library(ggplot2)  # For visualization"},{"path":"https://hiddevandebeek.github.io/admr/articles/admr.html","id":"understanding-the-data-format","dir":"Articles","previous_headings":"Introduction to Aggregate Data Modeling with admr","what":"Understanding the Data Format","title":"Get started with admr","text":"admr package works two types data formats: Raw Data: Individual-level observations wide long format Aggregate Data: Summary statistics (mean covariance) computed raw data Let’s look examplomycin dataset, ’ll use throughout vignette:","code":"# Load the dataset data(examplomycin) head(examplomycin) ##    ID TIME    DV AMT EVID CMT ## 1 460 0.00 0.000 100  101   1 ## 2 460 0.10 0.752   0    0   2 ## 3 460 0.25 1.932   0    0   2 ## 4 460 0.50 3.694   0    0   2 ## 5 460 1.00 3.479   0    0   2 ## 6 460 2.00 4.003   0    0   2 # Basic dataset information cat(\"Number of subjects:\", length(unique(examplomycin$ID)), \"\\n\") ## Number of subjects: 500 cat(\"Number of time points:\", length(unique(examplomycin$TIME)), \"\\n\") ## Number of time points: 10 cat(\"Time points:\", paste(sort(unique(examplomycin$TIME)), collapse = \", \"), \"\\n\") ## Time points: 0, 0.1, 0.25, 0.5, 1, 2, 3, 5, 8, 12"},{"path":[]},{"path":"https://hiddevandebeek.github.io/admr/articles/admr.html","id":"converting-raw-data-to-aggregate-format","dir":"Articles","previous_headings":"Introduction to Aggregate Data Modeling with admr > Data Preparation","what":"Converting Raw Data to Aggregate Format","title":"Get started with admr","text":"first step convert raw data aggregate format. ’s :","code":"# Convert to wide format examplomycin_wide <- examplomycin %>%   filter(EVID != 101) %>%  # Remove dosing events   dplyr::select(ID, TIME, DV) %>%  # Select relevant columns   pivot_wider(names_from = TIME, values_from = DV) %>%  # Convert to wide format   dplyr::select(-c(1))  # Remove ID column  # Create aggregated data examplomycin_aggregated <- examplomycin_wide %>%   admr::meancov()  # Compute mean and covariance  # View the structure of aggregated data str(examplomycin_aggregated) ## List of 2 ##  $ E: Named num [1:9] 0.966 1.939 2.788 3.025 2.258 ... ##   ..- attr(*, \"names\")= chr [1:9] \"0.1\" \"0.25\" \"0.5\" \"1\" ... ##  $ V: num [1:9, 1:9] 0.2103 0.3078 0.3486 0.2026 0.0224 ... ##   ..- attr(*, \"dimnames\")=List of 2 ##   .. ..$ : chr [1:9] \"0.1\" \"0.25\" \"0.5\" \"1\" ... ##   .. ..$ : chr [1:9] \"0.1\" \"0.25\" \"0.5\" \"1\" ..."},{"path":"https://hiddevandebeek.github.io/admr/articles/admr.html","id":"visualizing-the-data","dir":"Articles","previous_headings":"Introduction to Aggregate Data Modeling with admr > Data Preparation","what":"Visualizing the Data","title":"Get started with admr","text":"fitting model, ’s helpful visualize data:","code":"# Create a concentration-time plot ggplot(examplomycin, aes(x = TIME, y = DV)) +   geom_point(alpha = 0.5) +   geom_smooth(method = \"loess\", se = TRUE) +   labs(     title = \"Concentration-Time Profile\",     x = \"Time (hours)\",     y = \"Concentration (mg/L)\"   ) +   theme_minimal() ## `geom_smooth()` using formula = 'y ~ x'"},{"path":[]},{"path":"https://hiddevandebeek.github.io/admr/articles/admr.html","id":"defining-the-pharmacokinetic-model","dir":"Articles","previous_headings":"Introduction to Aggregate Data Modeling with admr > Model Specification","what":"Defining the Pharmacokinetic Model","title":"Get started with admr","text":"’ll use two-compartment model first-order absorption. two ways specify : Using differential equations: Using solved model approach (simpler):","code":"rxModel <- RxODE({   # Parameters   ke = cl / v1             # Elimination rate constant   k12 = q / v1             # Rate constant for central to peripheral transfer   k21 = q / v2             # Rate constant for peripheral to central transfer      # Differential equations   d/dt(depot)    = -ka * depot   d/dt(central)  = ka * depot - ke * central - k12 * central + k21 * peripheral   d/dt(peripheral) = k12 * central - k21 * peripheral      # Concentration in central compartment   cp = central / v1 }) rxModel <- RxODE({   cp = linCmt(     cl,           # Clearance     v1,           # Volume of central compartment     v2,           # Volume of peripheral compartment     q,            # Inter-compartmental clearance     ka            # Absorption rate constant   ) })"},{"path":"https://hiddevandebeek.github.io/admr/articles/admr.html","id":"creating-the-prediction-function","dir":"Articles","previous_headings":"Introduction to Aggregate Data Modeling with admr > Model Specification","what":"Creating the Prediction Function","title":"Get started with admr","text":"prediction function crucial admr package. : - Constructs event table dosing sampling - Solves RxODE model - Returns predicted concentrations required format","code":"predder <- function(time, theta_i, dose = 100) {     n_individuals <- nrow(theta_i)          if (is.null(n_individuals)) {       n_individuals <- 1     }      # Create event table     ev <- eventTable(amount.units=\"mg\", time.units=\"hours\")     ev$add.dosing(dose = dose, nbr.doses = 1, start.time = 0)     ev$add.sampling(time)          # Solve model     out <- rxSolve(rxModel, params = theta_i, events = ev, cores = 0)          # Format output     cp_matrix <- matrix(out$cp, nrow = n_individuals, ncol = length(time),                          byrow = TRUE)          return(cp_matrix) }"},{"path":[]},{"path":"https://hiddevandebeek.github.io/admr/articles/admr.html","id":"setting-up-model-options","dir":"Articles","previous_headings":"Introduction to Aggregate Data Modeling with admr > Model Fitting","what":"Setting Up Model Options","title":"Get started with admr","text":"genopts function creates options object controls model fitting process:","code":"opts <- genopts(   time = c(.1, .25, .5, 1, 2, 3, 5, 8, 12),  # Observation times   p = list(     beta = c(cl = 5, v1 = 10, v2 = 30, q = 10, ka = 1),  # Population parameters     Omega = matrix(c(0.09, 0, 0, 0, 0,                     0, 0.09, 0, 0, 0,                     0, 0, 0.09, 0, 0,                     0, 0, 0, 0.09, 0,                     0, 0, 0, 0, 0.09), nrow = 5, ncol = 5),  # Random effects     Sigma_prop = 0.04  # Proportional error   ),   nsim = 2500,  # Number of Monte Carlo samples   n = 500,      # Number of individuals   fo_appr = FALSE,  # Disable first-order approximation   omega_expansion = 1.2,  # Omega expansion factor   f = predder    # Prediction function )"},{"path":"https://hiddevandebeek.github.io/admr/articles/admr.html","id":"fitting-the-model","dir":"Articles","previous_headings":"Introduction to Aggregate Data Modeling with admr > Model Fitting","what":"Fitting the Model","title":"Get started with admr","text":"fitIRMC function fits model using IRMC algorithm:","code":"fit.admr <- admr::fitIRMC(   opts = opts,   obs = examplomycin_aggregated,   chains = 3,  # Number of parallel chains   maxiter = 100  # Maximum iterations ) ## Chain 1: ## Iter | NLL and Parameters (11 values) ## -------------------------------------------------------------------------------- ##    1: -1839.577    1.609    2.303    3.401    2.303    0.000   -2.408   -2.408   -2.408   -2.408   -2.408   -3.219 ##  ## ### Wide Search Phase ### ##    2: -1845.238    1.601    2.309    3.404    2.284    0.019   -2.280   -2.167   -2.334   -2.245   -2.439   -3.235 ##    3: -1845.283    1.601    2.308    3.405    2.285    0.019   -2.286   -2.207   -2.341   -2.264   -2.405   -3.235 ##    4: -1845.283    1.601    2.308    3.405    2.285    0.019   -2.286   -2.206   -2.341   -2.264   -2.405   -3.235 ##    5: -1845.283    1.601    2.308    3.405    2.285    0.019   -2.286   -2.205   -2.343   -2.264   -2.405   -3.235 ##    6: -1845.283    1.601    2.308    3.405    2.285    0.019   -2.286   -2.205   -2.343   -2.264   -2.405   -3.235 ##    7: -1845.283    1.601    2.308    3.405    2.285    0.019   -2.286   -2.205   -2.343   -2.264   -2.405   -3.235 ##    8: -1845.282    1.601    2.308    3.405    2.285    0.018   -2.286   -2.205   -2.343   -2.264   -2.406   -3.235 ##    9: -1845.282    1.601    2.308    3.405    2.285    0.018   -2.286   -2.204   -2.343   -2.264   -2.406   -3.235 ##   10: -1845.282    1.601    2.307    3.405    2.285    0.018   -2.286   -2.204   -2.343   -2.265   -2.406   -3.235 ##   11: -1845.282    1.601    2.308    3.405    2.285    0.018   -2.286   -2.204   -2.343   -2.264   -2.406   -3.235 ##   12: -1845.282    1.601    2.308    3.405    2.285    0.018   -2.286   -2.204   -2.343   -2.264   -2.406   -3.235 ## Phase Wide Search Phase converged at iteration 12. ##  ## ### Focussed Search Phase ### ##   13: -1845.280    1.601    2.307    3.405    2.285    0.018   -2.286   -2.201   -2.343   -2.265   -2.410   -3.235 ##   14: -1845.280    1.601    2.307    3.405    2.285    0.018   -2.286   -2.201   -2.343   -2.265   -2.410   -3.235 ##   15: -1845.280    1.601    2.307    3.405    2.285    0.018   -2.286   -2.201   -2.343   -2.265   -2.410   -3.235 ## Phase Focussed Search Phase converged at iteration 15. ##  ## ### Fine-Tuning Phase ### ##   16: -1845.280    1.601    2.307    3.405    2.285    0.018   -2.286   -2.201   -2.343   -2.265   -2.410   -3.235 ##   17: -1845.280    1.601    2.307    3.405    2.285    0.018   -2.286   -2.201   -2.343   -2.265   -2.410   -3.235 ##   18: -1845.280    1.601    2.307    3.405    2.285    0.018   -2.286   -2.201   -2.343   -2.265   -2.410   -3.235 ##   19: -1845.280    1.601    2.307    3.405    2.285    0.018   -2.286   -2.201   -2.343   -2.265   -2.410   -3.235 ## Phase Fine-Tuning Phase converged at iteration 19. ##  ## ### Precision Phase ### ##   20: -1845.280    1.601    2.307    3.405    2.285    0.018   -2.286   -2.201   -2.343   -2.265   -2.410   -3.235 ##   21: -1845.280    1.601    2.307    3.405    2.285    0.018   -2.286   -2.201   -2.343   -2.265   -2.410   -3.235 ##   22: -1845.280    1.601    2.307    3.405    2.285    0.018   -2.286   -2.201   -2.343   -2.265   -2.410   -3.235 ## Phase Precision Phase converged at iteration 22. ##  ## Chain 1 Complete: Final NLL = -1845.283, Time Elapsed = 8.32 seconds ##   ## Phase Wide Search Phase converged at iteration 6. ## Phase Focussed Search Phase converged at iteration 11. ## Phase Fine-Tuning Phase converged at iteration 13. ## Phase Precision Phase converged at iteration 14. ##  ## Chain 2 Complete: Final NLL = -1845.280, Time Elapsed = 5.53 seconds ##   ## Phase Wide Search Phase converged at iteration 12. ## Phase Focussed Search Phase converged at iteration 14. ## Phase Fine-Tuning Phase converged at iteration 18. ## Phase Precision Phase converged at iteration 21. ##  ## Chain 3 Complete: Final NLL = -1845.283, Time Elapsed = 9.00 seconds ##"},{"path":[]},{"path":"https://hiddevandebeek.github.io/admr/articles/admr.html","id":"basic-diagnostics","dir":"Articles","previous_headings":"Introduction to Aggregate Data Modeling with admr > Model Diagnostics","what":"Basic Diagnostics","title":"Get started with admr","text":"print method provides summary model fit:","code":"print(fit.admr) ## -- FitIRMC Summary -- ##  ## -- Objective Function and Information Criteria -- ##  Log-likelihood: -1845.2827 ##             AIC: 3701.57 ##             BIC: 3758.93 ## Condition#(Cov): 144.64 ## Condition#(Cor): 204.50 ##  ## -- Timing Information -- ##      Best Chain: 8.3222 seconds ##      All Chains: 22.8556 seconds ##      Covariance: 27.8566 seconds ##         Elapsed: 50.71 seconds ##  ## -- Population Parameters -- ## # A tibble: 6 × 6 ##   Parameter        Est.      SE  `%RSE` `Back-transformed(95%CI)` `BSV(CV%)` ##   <chr>           <dbl>   <dbl>   <dbl> <chr>                          <dbl> ## 1 cl             1.60    0.0153   0.954 4.96 (4.81, 5.11)               31.9 ## 2 v1             2.31    0.0842   3.65  10.05 (8.52, 11.85)             33.2 ## 3 v2             3.40    0.0394   1.16  30.11 (27.87, 32.53)            31.0 ## 4 q              2.28    0.0213   0.930 9.82 (9.42, 10.24)              32.2 ## 5 ka             0.0186  0.0794 427.    1.02 (0.87, 1.19)               30.0 ## 6 Residual Error 0.0394 NA       NA     0.0394                          NA   ##  ## -- Iteration Diagnostics -- ##  Iter | NLL and Parameters ## -------------------------------------------------------------------------------- ##    1: -1839.577 1.609 2.303 3.401 2.303 0.000 -2.408 -2.408 -2.408 -2.408 -2.408 -3.219 ##    2: -1845.238 1.601 2.309 3.404 2.284 0.019 -2.280 -2.167 -2.334 -2.245 -2.439 -3.235 ##    3: -1845.283 1.601 2.308 3.405 2.285 0.019 -2.286 -2.207 -2.341 -2.264 -2.405 -3.235 ##    4: -1845.283 1.601 2.308 3.405 2.285 0.019 -2.286 -2.206 -2.341 -2.264 -2.405 -3.235 ##    5: -1845.283 1.601 2.308 3.405 2.285 0.019 -2.286 -2.205 -2.343 -2.264 -2.405 -3.235 ##    ... (omitted iterations) ... ##   18: -1845.280 1.601 2.307 3.405 2.285 0.018 -2.286 -2.201 -2.343 -2.265 -2.410 -3.235 ##   19: -1845.280 1.601 2.307 3.405 2.285 0.018 -2.286 -2.201 -2.343 -2.265 -2.410 -3.235 ##   20: -1845.280 1.601 2.307 3.405 2.285 0.018 -2.286 -2.201 -2.343 -2.265 -2.410 -3.235 ##   21: -1845.280 1.601 2.307 3.405 2.285 0.018 -2.286 -2.201 -2.343 -2.265 -2.410 -3.235 ##   22: -1845.280 1.601 2.307 3.405 2.285 0.018 -2.286 -2.201 -2.343 -2.265 -2.410 -3.235"},{"path":"https://hiddevandebeek.github.io/admr/articles/admr.html","id":"convergence-assessment","dir":"Articles","previous_headings":"Introduction to Aggregate Data Modeling with admr > Model Diagnostics","what":"Convergence Assessment","title":"Get started with admr","text":"plot method visualizes convergence model fit:","code":"plot(fit.admr)"},{"path":"https://hiddevandebeek.github.io/admr/articles/admr.html","id":"parameter-estimates","dir":"Articles","previous_headings":"Introduction to Aggregate Data Modeling with admr > Model Diagnostics","what":"Parameter Estimates","title":"Get started with admr","text":"Let’s examine parameter estimates uncertainty:","code":"# Extract parameter estimates params <- fit.admr$final_params cat(\"Final parameter estimates:\\n\") ## Final parameter estimates: print(params) ##  [1]  1.60064075  2.30769783  3.40493589  2.28483529  0.01861234 -2.28621198 ##  [7] -2.20540525 -2.34292518 -2.26366946 -2.40495060 -3.23507323 # Extract covariance matrix cov_matrix <- fit.admr$covariance_matrix cat(\"\\nParameter covariance matrix:\\n\") ##  ## Parameter covariance matrix: print(cov_matrix) ##               [,1]          [,2]          [,3]          [,4]          [,5] ## [1,]  2.333496e-04  0.0003509607 -0.0003250435  5.942544e-05  0.0003432800 ## [2,]  3.509607e-04  0.0070878485 -0.0025906724  3.227487e-04  0.0065754632 ## [3,] -3.250435e-04 -0.0025906724  0.0015522901 -1.638170e-04 -0.0024696581 ## [4,]  5.942544e-05  0.0003227487 -0.0001638170  4.518169e-04  0.0003742059 ## [5,]  3.432800e-04  0.0065754632 -0.0024696581  3.742059e-04  0.0063091299"},{"path":[]},{"path":"https://hiddevandebeek.github.io/admr/articles/admr.html","id":"multiple-chains","dir":"Articles","previous_headings":"Introduction to Aggregate Data Modeling with admr > Advanced Features","what":"Multiple Chains","title":"Get started with admr","text":"fitIRMC function supports multiple chains improve optimization:","code":"# Run with multiple chains result <- fitIRMC(   opts = opts,   obs = examplomycin_aggregated,   chains = 3,  # Number of chains   pertubation = 0.1  # Perturbation factor )"},{"path":"https://hiddevandebeek.github.io/admr/articles/admr.html","id":"phase-based-optimization","dir":"Articles","previous_headings":"Introduction to Aggregate Data Modeling with admr > Advanced Features","what":"Phase-Based Optimization","title":"Get started with admr","text":"can customize optimization phases:","code":"# Custom phase fractions result <- fitIRMC(   opts = opts,   obs = examplomycin_aggregated,   phase_fractions = c(0.3, 0.3, 0.2, 0.2)  # Custom phase distribution )"},{"path":"https://hiddevandebeek.github.io/admr/articles/admr.html","id":"best-practices","dir":"Articles","previous_headings":"Introduction to Aggregate Data Modeling with admr","what":"Best Practices","title":"Get started with admr","text":"Always check data missing values outliers Ensure time points consistent across subjects Consider impact dosing events analysis Start simple model gradually add complexity Use meaningful initial values parameters Consider parameter transformations better estimation Use multiple chains improve optimization Monitor convergence carefully Check parameter estimates biological plausibility Always examine convergence plots Check parameter correlations Validate model predictions observed data","code":""},{"path":"https://hiddevandebeek.github.io/admr/articles/admr.html","id":"next-steps","dir":"Articles","previous_headings":"Introduction to Aggregate Data Modeling with admr","what":"Next Steps","title":"Get started with admr","text":"mastering basics, might want explore: Custom error models Parameter transformations Complex dosing regimens Adjusting Monte Carlo sample size Using first-order approximations Parallel computing options Residual analysis Parameter sensitivity analysis Model comparison information, see package documentation vignettes.","code":""},{"path":"https://hiddevandebeek.github.io/admr/articles/examplomycin.html","id":"creating-the-examplomycin-dataset","dir":"Articles","previous_headings":"","what":"Creating the Examplomycin Dataset","title":"Examplomycin Dataset: A Pharmacokinetic Example","text":"vignette demonstrates create simulated pharmacokinetic dataset fictional drug called examplomycin. dataset designed showcase capabilities admr package aggregate data modeling.","code":""},{"path":"https://hiddevandebeek.github.io/admr/articles/examplomycin.html","id":"overview","dir":"Articles","previous_headings":"Creating the Examplomycin Dataset","what":"Overview","title":"Examplomycin Dataset: A Pharmacokinetic Example","text":"examplomycin dataset simulated pharmacokinetic study following characteristics: - 500 healthy subjects - Single oral dose 100 mg - 9 sampling time points per subject - Two-compartment model first-order absorption - Random effects parameters - Proportional residual error","code":""},{"path":"https://hiddevandebeek.github.io/admr/articles/examplomycin.html","id":"required-packages","dir":"Articles","previous_headings":"Creating the Examplomycin Dataset","what":"Required Packages","title":"Examplomycin Dataset: A Pharmacokinetic Example","text":"","code":"library(rxode2) library(MASS) library(ggplot2) library(nlmixr2) library(data.table) library(dplyr) library(ggplot2) library(usethis)"},{"path":"https://hiddevandebeek.github.io/admr/articles/examplomycin.html","id":"data-generation-function","dir":"Articles","previous_headings":"Creating the Examplomycin Dataset","what":"Data Generation Function","title":"Examplomycin Dataset: A Pharmacokinetic Example","text":"generate_data function creates examplomycin dataset following features: - Two-compartment model first-order absorption - Log-normal random effects parameters - Proportional residual error - Standardized sampling schedule - NLMIXR-compatible data format","code":"generate_data <- function(n, times, seed = 1) {   set.seed(seed)      # Define the pharmacokinetic model   mod <- RxODE({     # Parameters     ke = cl / v1             # Elimination rate constant     k12 = q / v1             # Rate constant for central to peripheral transfer     k21 = q / v2             # Rate constant for peripheral to central transfer          # Differential equations for drug amount in compartments     d/dt(depot)    = -ka * depot     d/dt(central)  = ka * depot - ke * central -        k12 * central +        k21 * peripheral     d/dt(peripheral) = k12 * central -        k21 * peripheral          # Concentration in the central compartment     cp = central / v1   })    # Population parameters   theta <- c(cl = 5, v1 = 10, v2 = 30, q = 10, ka = 1)    # Correlation matrix for random effects   omegaCor <- matrix(c(1,  0,  0,  0,  0,                        0,  1,  0,  0,  0,                        0,  0,  1,  0,  0,                        0,  0,  0,  1,  0,                        0,  0,  0,  0,  1),                       dimnames = list(NULL, c(\"eta.cl\", \"eta.v1\", \"eta.v2\", \"eta.q\",                                             \"eta.ka\")), nrow = 5)    # Standard deviations of random effects   iiv.sd <- c(0.3, 0.3, 0.3, 0.3, 0.3)    # Create covariance matrix   iiv <- iiv.sd %*% t(iiv.sd)   omega <- iiv * omegaCor    # Generate random effects   mv <- mvrnorm(n, rep(0, dim(omega)[1]), omega)    # Create individual parameters   params.all <-     data.table(       \"ID\" = seq(1:n),       \"cl\" = theta['cl'] * exp(mv[, 1]),       \"v1\" = theta['v1'] * exp(mv[, 2]),       \"v2\" = theta['v2'] * exp(mv[, 3]),       \"q\"  = theta['q']  * exp(mv[, 4]),       \"ka\" = theta['ka'] * exp(mv[, 5])     )    # Create event table   ev <- et() %>%     et(amt = 100) %>%  # Single dose     et(0) %>%  # Initial time point     et(times) %>%  # Sampling schedule     et(ID = seq(1, n)) %>%  # Subject IDs     as.data.frame()    # Solve the model   sim <- rxSolve(mod, events = ev, iCov = params.all, cores = 0, addCov = T) %>%     mutate(ID = as.integer(id), TIME = as.numeric(time)) %>%     dplyr::select(-c(id, time)) %>%     mutate(AMT = ifelse(TIME == 0, 100, 0)) %>%     mutate(EVID = ifelse(TIME == 0, 101, 0)) %>%     mutate(CMT = ifelse(TIME == 0, 1, 2))    # Add residual error   sim$rv <- rnorm(nrow(sim), 0, 0.2)   sim$DV <- round(sim$cp * (1 + sim$rv), 3)   sim <- merge(sim, params.all)    # Select final columns   dat <- sim %>%     dplyr::select(\"ID\", \"TIME\", \"DV\", \"AMT\", \"EVID\", \"CMT\")    return(dat) }"},{"path":"https://hiddevandebeek.github.io/admr/articles/examplomycin.html","id":"generating-the-dataset","dir":"Articles","previous_headings":"Creating the Examplomycin Dataset","what":"Generating the Dataset","title":"Examplomycin Dataset: A Pharmacokinetic Example","text":"’ll generate examplomycin dataset : - 500 subjects - 9 time points (0.1, 0.25, 0.5, 1, 2, 3, 5, 8, 12 hours) - Random seed reproducibility","code":"examplomycin <- generate_data(   n = 500,  # Number of subjects   times = c(.1, .25, .5, 1, 2, 3, 5, 8, 12),  # Sampling times   seed = 1  # Random seed ) head(examplomycin) ##    ID TIME    DV AMT EVID CMT ## 1 460 0.00 0.000 100  101   1 ## 2 460 0.10 0.752   0    0   2 ## 3 460 0.25 1.932   0    0   2 ## 4 460 0.50 3.694   0    0   2 ## 5 460 1.00 3.479   0    0   2 ## 6 460 2.00 4.003   0    0   2"},{"path":"https://hiddevandebeek.github.io/admr/articles/examplomycin.html","id":"saving-the-dataset","dir":"Articles","previous_headings":"Creating the Examplomycin Dataset","what":"Saving the Dataset","title":"Examplomycin Dataset: A Pharmacokinetic Example","text":"dataset saved package data object use vignettes examples:","code":""},{"path":"https://hiddevandebeek.github.io/admr/articles/examplomycin.html","id":"visualizing-the-dataset","dir":"Articles","previous_headings":"Creating the Examplomycin Dataset","what":"Visualizing the Dataset","title":"Examplomycin Dataset: A Pharmacokinetic Example","text":"’ll create concentration-time plot visualize simulated data:","code":"# Create concentration-time plot ggplot(examplomycin, aes(x = TIME, y = DV, color = factor(ID))) +   geom_line(alpha = 0.7) +    # Connect points with lines   geom_point(size = 2, alpha = 0.8) +  # Add observation points   scale_color_viridis_d(name = \"Subject ID\") +  # Color by subject   labs(     title = \"Concentration-Time Profile\",     x = \"Time (hours)\",     y = \"Observed Concentration (DV)\"   ) +   theme_minimal() +   theme(legend.position = \"none\")  # Hide legend for clarity"},{"path":"https://hiddevandebeek.github.io/admr/articles/examplomycin.html","id":"dataset-structure","dir":"Articles","previous_headings":"Creating the Examplomycin Dataset","what":"Dataset Structure","title":"Examplomycin Dataset: A Pharmacokinetic Example","text":"examplomycin dataset contains following columns: - ID: Subject identifier - TIME: Observation time (hours) - DV: Observed concentration - AMT: Dose amount (100 mg NA) - EVID: Event type (101 dose, 0 observation) - CMT: Compartment number (1 depot, 2 central) dataset serves realistic example demonstrating aggregate data modeling techniques admr package.","code":""},{"path":"https://hiddevandebeek.github.io/admr/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"H. van de Beek. Maintainer.","code":""},{"path":"https://hiddevandebeek.github.io/admr/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"van de Beek H, Välitalo P, Zwep L, van Hasselt J (2025). admr: Aggregate data modelling R. R package version 0.1.0, https://hiddevandebeek.github.io/admr/, https://hiddevandebeek.github.io/admr.","code":"@Manual{,   title = {admr: Aggregate data modelling in R},   author = {H. {van de Beek} and P.A.J. Välitalo and L.B. Zwep and J.G.C {van Hasselt}},   year = {2025},   note = {R package version 0.1.0, https://hiddevandebeek.github.io/admr/},   url = {https://hiddevandebeek.github.io/admr}, }"},{"path":"https://hiddevandebeek.github.io/admr/index.html","id":"admr-aggregate-data-modeling-in-r","dir":"","previous_headings":"","what":"Aggregate data modelling in R","title":"Aggregate data modelling in R","text":"admr (Aggregate Data Modeling R) open-source R package designed facilitate pharmacometric modeling using summary-level data. enables users work aggregate data, mean observations variance-covariance matrices, fit pharmacokinetic pharmacodynamic (PK/PD) models efficiently. package implements newly developed Expectation-Maximization (EM) algorithm enhance computational performance provides tools advanced modeling applications.","code":""},{"path":"https://hiddevandebeek.github.io/admr/index.html","id":"overview","dir":"","previous_headings":"","what":"Overview","title":"Aggregate data modelling in R","text":"admr package provides comprehensive framework aggregate data modeling pharmacometrics, offering several key advantages: Efficient Parameter Estimation: Uses Iterative Reweighting Monte Carlo (IRMC) algorithm robust fast parameter estimation. Flexible Data Integration: Works individual-level aggregate data, making ideal meta-analyses literature-based modeling. Advanced Modeling Features: Supports complex PK/PD models various error structures parameter transformations. Comprehensive Diagnostics: Built-tools model assessment, convergence checking, parameter stability analysis.","code":""},{"path":"https://hiddevandebeek.github.io/admr/index.html","id":"key-features","dir":"","previous_headings":"","what":"Key Features","title":"Aggregate data modelling in R","text":"Efficient Model Fitting: Uses iterative reweighted Monte Carlo (IRMC) robust parameter estimation, improving speed scalability compared traditional Monte Carlo methods. Flexible Data Formats: Supports raw aggregate data formats, allowing integration summary-level data diverse sources, including published literature simulated models. Comprehensive Diagnostics: Built-tools model assessment, convergence checking, parameter stability analysis. Meta-Analysis Support: Facilitates model-based meta-analyses enabling combination summary data across studies. R Integration: Fully compatible R, leveraging popular pharmacometric modeling libraries like rxode2. Open-Source: Developed accessibility ease use pharmacometric community.","code":""},{"path":"https://hiddevandebeek.github.io/admr/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Aggregate data modelling in R","text":"R package. R required, RStudio recommended. can install development version admr GitHub :","code":"# install.packages(\"devtools\") devtools::install_github(\"hiddevandebeek/admr\")"},{"path":"https://hiddevandebeek.github.io/admr/index.html","id":"quick-start","dir":"","previous_headings":"","what":"Quick Start","title":"Aggregate data modelling in R","text":"complete example use admr fit pharmacokinetic model aggregate data:","code":"# Load required libraries library(admr) library(rxode2) #> Warning: package 'rxode2' was built under R version 4.4.2 #> rxode2 3.0.4 using 7 threads (see ?getRxThreads) #>   no cache: create with `rxCreateCache()` library(nlmixr2) #> Loading required package: nlmixr2data library(dplyr) #>  #> Attaching package: 'dplyr' #> The following objects are masked from 'package:stats': #>  #>     filter, lag #> The following objects are masked from 'package:base': #>  #>     intersect, setdiff, setequal, union library(tidyr) library(mnorm)  # Load and prepare data data(examplomycin) examplomycin_wide <- examplomycin %>%   filter(EVID != 101) %>%   dplyr::select(ID, TIME, DV) %>%   pivot_wider(names_from = TIME, values_from = DV) %>%   dplyr::select(-c(1))  # Create aggregated data examplomycin_aggregated <- examplomycin_wide %>%   admr::meancov()  # Define RxODE model rxModel <- RxODE({   cp = linCmt(     cl,           # Clearance     v1,           # Volume of the central compartment     v2,           # Volume of the peripheral compartment     q,            # Inter-compartmental clearance     ka            # Absorption rate constant   ) })  # Define prediction function predder <- function(time, theta_i, dose = 100) {   n_individuals <- nrow(theta_i)   if (is.null(n_individuals)) n_individuals <- 1      ev <- eventTable(amount.units=\"mg\", time.units=\"hours\")   ev$add.dosing(dose = dose, nbr.doses = 1, start.time = 0)   ev$add.sampling(time)      out <- rxSolve(rxModel, params = theta_i, events = ev, cores = 0)   cp_matrix <- matrix(out$cp, nrow = n_individuals, ncol = length(time),                       byrow = TRUE)   return(cp_matrix) }  # Create options opts <- genopts(   time = c(.1, .25, .5, 1, 2, 3, 5, 8, 12),   p = list(     beta = c(cl = 5, v1 = 10, v2 = 30, q = 10, ka = 1),     Omega = matrix(c(0.09, 0, 0, 0, 0,                     0, 0.09, 0, 0, 0,                     0, 0, 0.09, 0, 0,                     0, 0, 0, 0.09, 0,                     0, 0, 0, 0, 0.09), nrow = 5, ncol = 5),     Sigma_prop = 0.04   ),   nsim = 2500,   n = 500,   fo_appr = FALSE,   omega_expansion = 1.2,   f = predder )  # Fit model to data result <- fitIRMC(opts = opts, obs = examplomycin_aggregated) #> Chain 1: #> Iter | NLL and Parameters (11 values) #> -------------------------------------------------------------------------------- #>    1: -1839.577    1.609    2.303    3.401    2.303    0.000   -2.408   -2.408   -2.408   -2.408   -2.408   -3.219 #>  #> ### Wide Search Phase ### #>    2: -1845.238    1.601    2.309    3.404    2.284    0.020   -2.279   -2.167   -2.333   -2.245   -2.439   -3.235 #>    3: -1845.277    1.600    2.307    3.406    2.285    0.017   -2.287   -2.195   -2.342   -2.267   -2.416   -3.235 #>    4: -1845.277    1.600    2.306    3.406    2.285    0.017   -2.287   -2.195   -2.342   -2.266   -2.416   -3.235 #>    5: -1845.277    1.600    2.306    3.406    2.285    0.017   -2.287   -2.195   -2.342   -2.266   -2.416   -3.235 #> Phase Wide Search Phase converged at iteration 5. #>  #> ### Focussed Search Phase ### #>    6: -1845.280    1.601    2.307    3.405    2.285    0.018   -2.286   -2.200   -2.343   -2.264   -2.411   -3.235 #>    7: -1845.280    1.601    2.307    3.405    2.285    0.018   -2.286   -2.200   -2.343   -2.264   -2.411   -3.235 #>    8: -1845.280    1.601    2.307    3.405    2.285    0.018   -2.286   -2.200   -2.343   -2.264   -2.411   -3.235 #>    9: -1845.280    1.601    2.307    3.405    2.285    0.018   -2.286   -2.200   -2.343   -2.264   -2.411   -3.235 #>   10: -1845.280    1.601    2.307    3.405    2.285    0.018   -2.286   -2.200   -2.343   -2.264   -2.411   -3.235 #>   11: -1845.280    1.601    2.307    3.405    2.285    0.018   -2.286   -2.200   -2.343   -2.264   -2.411   -3.235 #> Phase Focussed Search Phase converged at iteration 11. #>  #> ### Fine-Tuning Phase ### #>   12: -1845.280    1.601    2.307    3.405    2.285    0.018   -2.286   -2.200   -2.343   -2.264   -2.411   -3.235 #> Phase Fine-Tuning Phase converged at iteration 12. #>  #> ### Precision Phase ### #>   13: -1845.280    1.601    2.307    3.405    2.285    0.018   -2.286   -2.201   -2.343   -2.265   -2.410   -3.235 #>   14: -1845.280    1.601    2.307    3.405    2.285    0.018   -2.286   -2.201   -2.343   -2.265   -2.410   -3.235 #> Phase Precision Phase converged at iteration 14. #>  #> Chain 1 Complete: Final NLL = -1845.280, Time Elapsed = 5.93 seconds #>  print(result) #> -- FitIRMC Summary -- #>  #> -- Objective Function and Information Criteria -- #>  Log-likelihood: -1845.2803 #>             AIC: 3701.56 #>             BIC: 3758.92 #> Condition#(Cov): 143.71 #> Condition#(Cor): 202.97 #>  #> -- Timing Information -- #>      Best Chain: 5.9257 seconds #>      All Chains: 5.9279 seconds #>      Covariance: 28.1302 seconds #>         Elapsed: 34.06 seconds #>  #> -- Population Parameters -- #> # A tibble: 6 × 6 #>   Parameter        Est.      SE  `%RSE` `Back-transformed(95%CI)` `BSV(CV%)` #>   <chr>           <dbl>   <dbl>   <dbl> <chr>                          <dbl> #> 1 cl             1.60    0.0153   0.955 4.96 (4.81, 5.11)               31.9 #> 2 v1             2.31    0.0839   3.64  10.05 (8.52, 11.84)             33.3 #> 3 v2             3.41    0.0393   1.16  30.12 (27.88, 32.53)            31.0 #> 4 q              2.28    0.0213   0.931 9.82 (9.42, 10.24)              32.2 #> 5 ka             0.0181  0.0791 437.    1.02 (0.87, 1.19)               30.0 #> 6 Residual Error 0.0394 NA       NA     0.0394                          NA   #>  #> -- Iteration Diagnostics -- #>  Iter | NLL and Parameters #> -------------------------------------------------------------------------------- #>    1: -1839.577 1.609 2.303 3.401 2.303 0.000 -2.408 -2.408 -2.408 -2.408 -2.408 -3.219 #>    2: -1845.238 1.601 2.309 3.404 2.284 0.020 -2.279 -2.167 -2.333 -2.245 -2.439 -3.235 #>    3: -1845.277 1.600 2.307 3.406 2.285 0.017 -2.287 -2.195 -2.342 -2.267 -2.416 -3.235 #>    4: -1845.277 1.600 2.306 3.406 2.285 0.017 -2.287 -2.195 -2.342 -2.266 -2.416 -3.235 #>    5: -1845.277 1.600 2.306 3.406 2.285 0.017 -2.287 -2.195 -2.342 -2.266 -2.416 -3.235 #>    ... (omitted iterations) ... #>   10: -1845.280 1.601 2.307 3.405 2.285 0.018 -2.286 -2.200 -2.343 -2.264 -2.411 -3.235 #>   11: -1845.280 1.601 2.307 3.405 2.285 0.018 -2.286 -2.200 -2.343 -2.264 -2.411 -3.235 #>   12: -1845.280 1.601 2.307 3.405 2.285 0.018 -2.286 -2.200 -2.343 -2.264 -2.411 -3.235 #>   13: -1845.280 1.601 2.307 3.405 2.285 0.018 -2.286 -2.201 -2.343 -2.265 -2.410 -3.235 #>   14: -1845.280 1.601 2.307 3.405 2.285 0.018 -2.286 -2.201 -2.343 -2.265 -2.410 -3.235"},{"path":"https://hiddevandebeek.github.io/admr/index.html","id":"documentation","dir":"","previous_headings":"","what":"Documentation","title":"Aggregate data modelling in R","text":"package documentation available https://hiddevandebeek.github.io/admr/. Key documentation sections include: Getting Started Advanced Topics Function Reference Examples","code":""},{"path":"https://hiddevandebeek.github.io/admr/index.html","id":"use-cases","dir":"","previous_headings":"","what":"Use Cases","title":"Aggregate data modelling in R","text":"admr package particularly useful : Meta-Analysis: Combining data multiple studies individual-level data available Literature-Based Modeling: Fitting models published summary statistics Simulation Studies: Evaluating model performance aggregate data Population PK/PD: Fitting complex models summary-level data","code":""},{"path":"https://hiddevandebeek.github.io/admr/index.html","id":"getting-help","dir":"","previous_headings":"","what":"Getting Help","title":"Aggregate data modelling in R","text":"Check documentation Browse GitHub issues Create new issue reproducible example","code":""},{"path":"https://hiddevandebeek.github.io/admr/index.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Aggregate data modelling in R","text":"use admr research, please cite :","code":"citation(\"admr\")"},{"path":"https://hiddevandebeek.github.io/admr/index.html","id":"license","dir":"","previous_headings":"","what":"License","title":"Aggregate data modelling in R","text":"project licensed GPL-2 License - see LICENSE file details.","code":""},{"path":"https://hiddevandebeek.github.io/admr/reference/admr-package.html","id":null,"dir":"Reference","previous_headings":"","what":"admr: Aggregate data modelling in R — admr-package","title":"admr: Aggregate data modelling in R — admr-package","text":"novel method aggregate data model using non-linear estimation techniques.","code":""},{"path":[]},{"path":"https://hiddevandebeek.github.io/admr/reference/admr-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"admr: Aggregate data modelling in R — admr-package","text":"H. van de Beek P..J. Välitalo","code":""},{"path":"https://hiddevandebeek.github.io/admr/reference/examplomycin.html","id":null,"dir":"Reference","previous_headings":"","what":"Examplomycin Dataset — examplomycin","title":"Examplomycin Dataset — examplomycin","text":"simulated dataset fictional drug examplomycin. dataset contains 500 subjects, 9 timepoints. generated using two-compartment pharmacokinetic model first-order absorption elimination. Random effects residual errors included simulate variability noise.","code":""},{"path":"https://hiddevandebeek.github.io/admr/reference/examplomycin.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Examplomycin Dataset — examplomycin","text":"","code":"examplomycin"},{"path":"https://hiddevandebeek.github.io/admr/reference/examplomycin.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Examplomycin Dataset — examplomycin","text":"data frame 4500 rows 6 variables: ID: Subject ID. TIME: Observation time (hours). DV: Observed drug concentration (mg/L). AMT: Amount drug administered (mg). EVID: Event type indicator (0 observation, 101 dosing). CMT: Compartment number (1 depot, 2 central).","code":""},{"path":"https://hiddevandebeek.github.io/admr/reference/examplomycin.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Examplomycin Dataset — examplomycin","text":"Generated using generate_data function.","code":""},{"path":"https://hiddevandebeek.github.io/admr/reference/examplomycin.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Examplomycin Dataset — examplomycin","text":"","code":"# Load the dataset data(\"examplomycin\")  # View the first few rows head(examplomycin) #>    ID TIME    DV AMT EVID CMT #> 1 460 0.00 0.000 100  101   1 #> 2 460 0.10 0.752   0    0   2 #> 3 460 0.25 1.932   0    0   2 #> 4 460 0.50 3.694   0    0   2 #> 5 460 1.00 3.479   0    0   2 #> 6 460 2.00 4.003   0    0   2"},{"path":"https://hiddevandebeek.github.io/admr/reference/fitIRMC.html","id":null,"dir":"Reference","previous_headings":"","what":"Fit aggregate data using Iterative Reweighting with Monte Carlo updates — fitIRMC","title":"Fit aggregate data using Iterative Reweighting with Monte Carlo updates — fitIRMC","text":"fitIRMC implements Iterative Reweighting (IRMC) algorithm parameter estimation aggregate data models, iterating maximum likelihood updates weighted Monte Carlo updates. function uses nloptr instead optimx optimization includes additional features like multiple chains phase-based optimization.","code":""},{"path":"https://hiddevandebeek.github.io/admr/reference/fitIRMC.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fit aggregate data using Iterative Reweighting with Monte Carlo updates — fitIRMC","text":"","code":"fitIRMC(   opts,   obs,   maxiter = 100,   convcrit_nll = 1e-05,   single_dataframe = TRUE,   phase_fractions = c(0.2, 0.4, 0.2, 0.2),   max_worse_iterations = 10,   chains = 1,   pertubation = 0.1,   seed = 1 )"},{"path":"https://hiddevandebeek.github.io/admr/reference/fitIRMC.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fit aggregate data using Iterative Reweighting with Monte Carlo updates — fitIRMC","text":"opts list model options generated genopts(). Contains settings model, including prediction function, time points, parameter structure, simulation settings. obs Observed data aggregate form (mean covariance) matrix raw data. maxiter Maximum number iterations optimization algorithm. Default 100. convcrit_nll Convergence criterion negative log-likelihood. algorithm stops relative change negative log-likelihood less value. Default 1e-05. single_dataframe Logical indicating whether use single data frame (TRUE) multiple data frames (FALSE). Default TRUE. phase_fractions Vector fractions optimization phase. sum 1. Default c(0.2, 0.4, 0.2, 0.2). max_worse_iterations Maximum number consecutive worse iterations skipping phase. Default 10. chains Number parallel chains run. Default 1. pertubation Perturbation factor initial parameter values chain. Default 0.1. seed Random seed reproducibility. Default 1.","code":""},{"path":"https://hiddevandebeek.github.io/admr/reference/fitIRMC.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fit aggregate data using Iterative Reweighting with Monte Carlo updates — fitIRMC","text":"object class fitIRMC_result containing: p: List parameter estimates iteration nll: Negative log-likelihood values time: Computation time iteration iter: Iteration number chain: Chain number (multiple chains used) phase: Optimization phase number","code":""},{"path":"https://hiddevandebeek.github.io/admr/reference/fitIRMC.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Fit aggregate data using Iterative Reweighting with Monte Carlo updates — fitIRMC","text":"function uses Iterative Reweighting algorithm Monte Carlo sampling optimization. includes several advanced features: Multiple optimization phases different convergence criteria Parallel chains perturbed starting values Phase-based optimization automatic phase skipping Convergence checking based likelihood parameter stationarity optimization process divided phases, convergence criteria settings. algorithm can automatically skip phases optimization progressing. Multiple chains can run parallel improve chances finding global optimum.","code":""},{"path":"https://hiddevandebeek.github.io/admr/reference/fitIRMC.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fit aggregate data using Iterative Reweighting with Monte Carlo updates — fitIRMC","text":"","code":"# Load required libraries library(admr) library(rxode2) #> rxode2 3.0.4 using 1 threads (see ?getRxThreads) #>   no cache: create with `rxCreateCache()` library(nlmixr2) #> Loading required package: nlmixr2data library(dplyr) #>  #> Attaching package: ‘dplyr’ #> The following objects are masked from ‘package:stats’: #>  #>     filter, lag #> The following objects are masked from ‘package:base’: #>  #>     intersect, setdiff, setequal, union library(tidyr) library(mnorm)  # Load and prepare data data(examplomycin) examplomycin_wide <- examplomycin %>%   filter(EVID != 101) %>%   dplyr::select(ID, TIME, DV) %>%   pivot_wider(names_from = TIME, values_from = DV) %>%   dplyr::select(-c(1))  # Create aggregated data examplomycin_aggregated <- examplomycin_wide %>%   admr::meancov()  # Define RxODE model rxModel <- RxODE({   cp = linCmt(     cl,           # Clearance     v1,           # Volume of the central compartment     v2,           # Volume of the peripheral compartment     q,            # Inter-compartmental clearance     ka            # Absorption rate constant   ) }) #>   #>   #> using C compiler: ‘gcc (Ubuntu 13.3.0-6ubuntu2~24.04) 13.3.0’  # Define prediction function predder <- function(time, theta_i, dose = 100) {   n_individuals <- nrow(theta_i)   if (is.null(n_individuals)) n_individuals <- 1      ev <- eventTable(amount.units=\"mg\", time.units=\"hours\")   ev$add.dosing(dose = dose, nbr.doses = 1, start.time = 0)   ev$add.sampling(time)      out <- rxSolve(rxModel, params = theta_i, events = ev, cores = 0)   cp_matrix <- matrix(out$cp, nrow = n_individuals, ncol = length(time),                       byrow = TRUE)   return(cp_matrix) }  # Create options opts <- genopts(   time = c(.1, .25, .5, 1, 2, 3, 5, 8, 12),   p = list(     beta = c(cl = 5, v1 = 10, v2 = 30, q = 10, ka = 1),     Omega = matrix(c(0.09, 0, 0, 0, 0,                      0, 0.09, 0, 0, 0,                      0, 0, 0.09, 0, 0,                      0, 0, 0, 0.09, 0,                      0, 0, 0, 0, 0.09), nrow = 5, ncol = 5),     Sigma_prop = 0.04   ),   nsim = 2500,   n = 500,   fo_appr = FALSE,   omega_expansion = 1.2,   f = predder )  # Run optimization result <- fitIRMC(opts, examplomycin_aggregated) #> Chain 1: #> Iter | NLL and Parameters (11 values) #> -------------------------------------------------------------------------------- #>    1: -1839.577    1.609    2.303    3.401    2.303    0.000   -2.408   -2.408   -2.408   -2.408   -2.408   -3.219 #>  #> ### Wide Search Phase ### #>    2: -1845.238    1.601    2.309    3.404    2.284    0.019   -2.280   -2.167   -2.334   -2.245   -2.439   -3.235 #>    3: -1845.283    1.601    2.308    3.405    2.285    0.019   -2.286   -2.207   -2.341   -2.264   -2.405   -3.235 #>    4: -1845.283    1.601    2.308    3.405    2.285    0.019   -2.286   -2.206   -2.341   -2.264   -2.405   -3.235 #>    5: -1845.283    1.601    2.308    3.405    2.285    0.019   -2.286   -2.205   -2.343   -2.264   -2.405   -3.235 #>    6: -1845.283    1.601    2.308    3.405    2.285    0.019   -2.286   -2.205   -2.343   -2.264   -2.405   -3.235 #>    7: -1845.283    1.601    2.308    3.405    2.285    0.019   -2.286   -2.205   -2.343   -2.264   -2.405   -3.235 #>    8: -1845.282    1.601    2.308    3.405    2.285    0.018   -2.286   -2.205   -2.343   -2.264   -2.406   -3.235 #>    9: -1845.282    1.601    2.308    3.405    2.285    0.018   -2.286   -2.204   -2.343   -2.264   -2.406   -3.235 #>   10: -1845.282    1.601    2.307    3.405    2.285    0.018   -2.286   -2.204   -2.343   -2.265   -2.406   -3.235 #>   11: -1845.282    1.601    2.308    3.405    2.285    0.018   -2.286   -2.204   -2.343   -2.264   -2.406   -3.235 #>   12: -1845.282    1.601    2.308    3.405    2.285    0.018   -2.286   -2.204   -2.343   -2.264   -2.406   -3.235 #> Phase Wide Search Phase converged at iteration 12. #>  #> ### Focussed Search Phase ### #>   13: -1845.280    1.601    2.307    3.405    2.285    0.018   -2.286   -2.201   -2.343   -2.265   -2.410   -3.235 #>   14: -1845.280    1.601    2.307    3.405    2.285    0.018   -2.286   -2.201   -2.343   -2.265   -2.410   -3.235 #>   15: -1845.280    1.601    2.307    3.405    2.285    0.018   -2.286   -2.201   -2.343   -2.265   -2.410   -3.235 #> Phase Focussed Search Phase converged at iteration 15. #>  #> ### Fine-Tuning Phase ### #>   16: -1845.280    1.601    2.307    3.405    2.285    0.018   -2.286   -2.201   -2.343   -2.265   -2.410   -3.235 #>   17: -1845.280    1.601    2.307    3.405    2.285    0.018   -2.286   -2.201   -2.343   -2.265   -2.410   -3.235 #>   18: -1845.280    1.601    2.307    3.405    2.285    0.018   -2.286   -2.201   -2.343   -2.265   -2.410   -3.235 #>   19: -1845.280    1.601    2.307    3.405    2.285    0.018   -2.286   -2.201   -2.343   -2.265   -2.410   -3.235 #> Phase Fine-Tuning Phase converged at iteration 19. #>  #> ### Precision Phase ### #>   20: -1845.280    1.601    2.307    3.405    2.285    0.018   -2.286   -2.201   -2.343   -2.265   -2.410   -3.235 #>   21: -1845.280    1.601    2.307    3.405    2.285    0.018   -2.286   -2.201   -2.343   -2.265   -2.410   -3.235 #>   22: -1845.280    1.601    2.307    3.405    2.285    0.018   -2.286   -2.201   -2.343   -2.265   -2.410   -3.235 #> Phase Precision Phase converged at iteration 22. #>  #> Chain 1 Complete: Final NLL = -1845.283, Time Elapsed = 8.06 seconds #>   print(result) #> -- FitIRMC Summary -- #>  #> -- Objective Function and Information Criteria -- #>  Log-likelihood: -1845.2827 #>             AIC: 3701.57 #>             BIC: 3758.93 #> Condition#(Cov): 144.64 #> Condition#(Cor): 204.50 #>  #> -- Timing Information -- #>      Best Chain: 8.0584 seconds #>      All Chains: 8.0610 seconds #>      Covariance: 28.4455 seconds #>         Elapsed: 36.51 seconds #>  #> -- Population Parameters -- #> # A tibble: 6 × 6 #>   Parameter        Est.      SE  `%RSE` `Back-transformed(95%CI)` `BSV(CV%)` #>   <chr>           <dbl>   <dbl>   <dbl> <chr>                          <dbl> #> 1 cl             1.60    0.0153   0.954 4.96 (4.81, 5.11)               31.9 #> 2 v1             2.31    0.0842   3.65  10.05 (8.52, 11.85)             33.2 #> 3 v2             3.40    0.0394   1.16  30.11 (27.87, 32.53)            31.0 #> 4 q              2.28    0.0213   0.930 9.82 (9.42, 10.24)              32.2 #> 5 ka             0.0186  0.0794 427.    1.02 (0.87, 1.19)               30.0 #> 6 Residual Error 0.0394 NA       NA     0.0394                          NA   #>  #> -- Iteration Diagnostics -- #>  Iter | NLL and Parameters #> -------------------------------------------------------------------------------- #>    1: -1839.577 1.609 2.303 3.401 2.303 0.000 -2.408 -2.408 -2.408 -2.408 -2.408 -3.219 #>    2: -1845.238 1.601 2.309 3.404 2.284 0.019 -2.280 -2.167 -2.334 -2.245 -2.439 -3.235 #>    3: -1845.283 1.601 2.308 3.405 2.285 0.019 -2.286 -2.207 -2.341 -2.264 -2.405 -3.235 #>    4: -1845.283 1.601 2.308 3.405 2.285 0.019 -2.286 -2.206 -2.341 -2.264 -2.405 -3.235 #>    5: -1845.283 1.601 2.308 3.405 2.285 0.019 -2.286 -2.205 -2.343 -2.264 -2.405 -3.235 #>    ... (omitted iterations) ... #>   18: -1845.280 1.601 2.307 3.405 2.285 0.018 -2.286 -2.201 -2.343 -2.265 -2.410 -3.235 #>   19: -1845.280 1.601 2.307 3.405 2.285 0.018 -2.286 -2.201 -2.343 -2.265 -2.410 -3.235 #>   20: -1845.280 1.601 2.307 3.405 2.285 0.018 -2.286 -2.201 -2.343 -2.265 -2.410 -3.235 #>   21: -1845.280 1.601 2.307 3.405 2.285 0.018 -2.286 -2.201 -2.343 -2.265 -2.410 -3.235 #>   22: -1845.280 1.601 2.307 3.405 2.285 0.018 -2.286 -2.201 -2.343 -2.265 -2.410 -3.235 #>"},{"path":"https://hiddevandebeek.github.io/admr/reference/gen_pop_EV.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute expected population-level mean and covariance — gen_pop_EV","title":"Compute expected population-level mean and covariance — gen_pop_EV","text":"gen_pop_EV computes expected population-level mean covariance model predictions using either first-order approximation (FO) Monte Carlo (MC) methods. function core component aggregate data modeling framework, used generate expected values model fitting optimization.","code":""},{"path":"https://hiddevandebeek.github.io/admr/reference/gen_pop_EV.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute expected population-level mean and covariance — gen_pop_EV","text":"","code":"gen_pop_EV(opts)"},{"path":"https://hiddevandebeek.github.io/admr/reference/gen_pop_EV.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute expected population-level mean and covariance — gen_pop_EV","text":"opts list model options generated genopts(). Contains settings model, including prediction function, time points, parameter structure, simulation settings.","code":""},{"path":"https://hiddevandebeek.github.io/admr/reference/gen_pop_EV.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute expected population-level mean and covariance — gen_pop_EV","text":"list containing: E: Expected mean model predictions V: Expected covariance model predictions","code":""},{"path":"https://hiddevandebeek.github.io/admr/reference/gen_pop_EV.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compute expected population-level mean and covariance — gen_pop_EV","text":"function uses two different approaches compute expected values: First-order approximation (FO): Used opts$fo_appr TRUE. method: Generates random effects using gen_bi() Computes importance sampling weights Uses FOCE approximation individual Combines results using weighted averaging Monte Carlo approximation (MC): Used opts$fo_appr FALSE. method: Generates random effects Computes individual predictions Uses weighted averaging omega expansion used choice FO MC methods depends number Monte Carlo samples (nsim). FO used default nsim < 10, MC used otherwise.","code":""},{"path":"https://hiddevandebeek.github.io/admr/reference/gen_pop_EV.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute expected population-level mean and covariance — gen_pop_EV","text":"","code":"# Create test data test_data <- create_test_data() #> Error in create_test_data(): could not find function \"create_test_data\" opts <- test_data$opts #> Error: object 'test_data' not found  # Compute expected values using FO approximation opts$fo_appr <- TRUE #> Error: object 'opts' not found ev_fo <- gen_pop_EV(opts) #> Error: object 'opts' not found expect_named(ev_fo, c(\"E\", \"V\")) #> Error in expect_named(ev_fo, c(\"E\", \"V\")): could not find function \"expect_named\"  # Compute expected values using MC approximation opts$fo_appr <- FALSE #> Error: object 'opts' not found ev_mc <- gen_pop_EV(opts) #> Error: object 'opts' not found expect_named(ev_mc, c(\"E\", \"V\")) #> Error in expect_named(ev_mc, c(\"E\", \"V\")): could not find function \"expect_named\""},{"path":"https://hiddevandebeek.github.io/admr/reference/gendataset.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate a simulated dataset — gendataset","title":"Generate a simulated dataset — gendataset","text":"gendataset generates simulated dataset based model structure random effects specified options. function can generate data either raw format nlmixr format, optional residual error.","code":""},{"path":"https://hiddevandebeek.github.io/admr/reference/gendataset.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate a simulated dataset — gendataset","text":"","code":"gendataset(opts, seed = 1, reserr = TRUE, nlmixrform = FALSE)"},{"path":"https://hiddevandebeek.github.io/admr/reference/gendataset.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate a simulated dataset — gendataset","text":"opts list model options generated genopts(). Contains settings model, including prediction function, time points, parameter structure, simulation settings. seed Random seed reproducibility. Default 1. reserr Logical indicating whether add residual error simulated data. Default TRUE. nlmixrform Logical indicating whether return data nlmixr format. TRUE, returns data frame columns: dv, time, id, amt, evid, cmt. FALSE, returns matrix simulated observations. Default FALSE.","code":""},{"path":"https://hiddevandebeek.github.io/admr/reference/gendataset.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate a simulated dataset — gendataset","text":"nlmixrform FALSE, returns matrix simulated observations dimensions nsim x length(time). nlmixrform TRUE, returns data frame nlmixr format columns: dv: Observed value time: Observation time id: Subject ID amt: Dose amount (NA observations) evid: Event type (101 dosing, 0 observation) cmt: Compartment number (1 depot, 2 central)","code":""},{"path":"https://hiddevandebeek.github.io/admr/reference/gendataset.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generate a simulated dataset — gendataset","text":"function generates simulated data : Generating random effects specified distribution Computing individual parameters using transformation function Simulating observations using prediction function Adding residual error requested Formatting output according specified format residual error can either proportional (Sigma_prop) additive (Sigma_add), . function uses random number generator seed ensure reproducibility.","code":""},{"path":"https://hiddevandebeek.github.io/admr/reference/gendataset.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate a simulated dataset — gendataset","text":"","code":"# Create model options opts <- genopts(   f = predder,   time = c(.1, .25, .5, 1, 2, 3, 5, 8, 12),   p = list(     beta = c(cl = 5, v1 = 10, v2 = 30, q = 10, ka = 1),     Omega = matrix(c(0.09, 0, 0, 0, 0,                     0, 0.09, 0, 0, 0,                     0, 0, 0.09, 0, 0,                     0, 0, 0, 0.09, 0,                     0, 0, 0, 0, 0.09), nrow = 5, ncol = 5),     Sigma_prop = 0.04   ),   nsim = 2500,   n = 500 ) #> Error: object 'predder' not found  # Generate dataset in raw format data_raw <- gendataset(opts) #> Error: object 'opts' not found  # Generate dataset in nlmixr format data_nlmixr <- gendataset(opts, nlmixrform = TRUE) #> Error: object 'opts' not found"},{"path":"https://hiddevandebeek.github.io/admr/reference/genfitfunc.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate a fitting function for optimization — genfitfunc","title":"Generate a fitting function for optimization — genfitfunc","text":"genfitfunc generates fitting function optimization computes negative log-likelihood model given observed data current parameter estimates. function handles raw data aggregate data (mean covariance) formats.","code":""},{"path":"https://hiddevandebeek.github.io/admr/reference/genfitfunc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate a fitting function for optimization — genfitfunc","text":"","code":"genfitfunc(opts, obs)"},{"path":"https://hiddevandebeek.github.io/admr/reference/genfitfunc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate a fitting function for optimization — genfitfunc","text":"opts list model options generated genopts(). Contains settings model, including prediction function, time points, parameter structure, simulation settings. obs Observed data aggregate form (mean covariance) matrix raw data. missing, expected data model used.","code":""},{"path":"https://hiddevandebeek.github.io/admr/reference/genfitfunc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate a fitting function for optimization — genfitfunc","text":"function takes parameter values input returns negative log-likelihood model given observed data. function signature : function(p) -> numeric","code":""},{"path":"https://hiddevandebeek.github.io/admr/reference/genfitfunc.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generate a fitting function for optimization — genfitfunc","text":"generated fitting function: Computes expected mean covariance model predictions Compares observed data Returns negative log-likelihood model raw data provided, automatically converted aggregate form (mean covariance) using meancov function. function handles single models multiple models (opts list model options).","code":""},{"path":"https://hiddevandebeek.github.io/admr/reference/genfitfunc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate a fitting function for optimization — genfitfunc","text":"","code":"# Create test data test_data <- create_test_data() #> Error in create_test_data(): could not find function \"create_test_data\" opts <- test_data$opts #> Error: object 'test_data' not found obs <- test_data$obs #> Error: object 'test_data' not found  # Generate fitting function fitfun <- genfitfunc(opts, obs) #> Error: object 'obs' not found  # Evaluate at initial parameters nll <- fitfun(opts$pt) #> Error in fitfun(opts$pt): could not find function \"fitfun\""},{"path":"https://hiddevandebeek.github.io/admr/reference/genopts.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate options for aggregate data modeling — genopts","title":"Generate options for aggregate data modeling — genopts","text":"genopts initializes generates core options settings aggregate data modeling optimization. creates comprehensive options object contains necessary information model fitting, including random effects, simulation settings, likelihood approximations.","code":""},{"path":"https://hiddevandebeek.github.io/admr/reference/genopts.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate options for aggregate data modeling — genopts","text":"","code":"genopts(   f,   time,   p,   h,   nsim = 1,   n = 30,   adist = NULL,   interact = TRUE,   fo_appr = (nsim < 10),   biseq = NA,   omega_expansion = 1,   single_betas = NA,   p_thetai = function(p, origbeta, bi) {      dmnorm(bi, mean = log(p$beta/origbeta),     sigma = p$Omega, log = TRUE)$den  },   g = function(beta, bi = rep(0, length(beta)), ai) { beta * exp(bi)  } )"},{"path":"https://hiddevandebeek.github.io/admr/reference/genopts.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate options for aggregate data modeling — genopts","text":"f prediction function simulates model output given parameters time points. time Vector time points evaluate model predictions. p List containing initial parameter values structure: beta: Vector population parameters Omega: Covariance matrix random effects Sigma_prop: Proportional error variance (optional) Sigma_add: Additive error variance (optional) h error function computes variance predictions. nsim Number Monte Carlo samples per iteration. Default 1. n Number individuals dataset. Used OFV, AIC, BIC calculation. Default 30. adist Distribution random effects. Default NULL (normal distribution). interact Logical indicating whether use FOCEI interaction. Default TRUE. fo_appr Logical indicating whether use first-order approximation. Default TRUE nsim < 10, FALSE otherwise. biseq Sequence random effects. Default NA (generated internally). omega_expansion Factor expand covariance matrix estimation. Default 1. single_betas Matrix beta parameters multiple models. Default NA. p_thetai Function compute log-density random effects. Default multivariate normal density. g Function transform population parameters individual parameters. Default exponential transformation.","code":""},{"path":"https://hiddevandebeek.github.io/admr/reference/genopts.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate options for aggregate data modeling — genopts","text":"list containing: f: prediction function time: Time points evaluation p: Parameter structure initial values h: error function nsim: Number Monte Carlo samples n: Number individuals adist: Distribution random effects interact: FOCEI interaction flag fo_appr: First-order approximation flag biseq: Random effects sequence omega_expansion: Covariance expansion factor single_betas: Beta parameters multiple models p_thetai: Random effects density function g: Parameter transformation function pt: Transformed initial parameters","code":""},{"path":"https://hiddevandebeek.github.io/admr/reference/genopts.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generate options for aggregate data modeling — genopts","text":"function main entry point setting aggregate data modeling. creates options object contains necessary information model fitting, including prediction function, parameter structure, various settings optimization algorithm.","code":""},{"path":"https://hiddevandebeek.github.io/admr/reference/genopts.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate options for aggregate data modeling — genopts","text":"","code":"# Define prediction function predder <- function(time, theta_i, dose = 100) {   # ... prediction function implementation ... }  # Create options opts <- genopts(   f = predder,   time = c(.1, .25, .5, 1, 2, 3, 5, 8, 12),   p = list(     beta = c(cl = 5, v1 = 10, v2 = 30, q = 10, ka = 1),     Omega = matrix(c(0.09, 0, 0, 0, 0,                     0, 0.09, 0, 0, 0,                     0, 0, 0.09, 0, 0,                     0, 0, 0, 0.09, 0,                     0, 0, 0, 0, 0.09), nrow = 5, ncol = 5),     Sigma_prop = 0.04   ),   nsim = 2500,   n = 500 )"},{"path":"https://hiddevandebeek.github.io/admr/reference/meancov.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute mean and covariance of a matrix — meancov","title":"Compute mean and covariance of a matrix — meancov","text":"meancov computes mean covariance matrix, optionally weights. function used convert raw data aggregate form (mean covariance) use aggregate data modeling.","code":""},{"path":"https://hiddevandebeek.github.io/admr/reference/meancov.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute mean and covariance of a matrix — meancov","text":"","code":"meancov(m, wt)"},{"path":"https://hiddevandebeek.github.io/admr/reference/meancov.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute mean and covariance of a matrix — meancov","text":"m numeric matrix data frame containing observations. row represents individual, column represents time point. wt Optional vector weights observation. provided, observations weighted equally.","code":""},{"path":"https://hiddevandebeek.github.io/admr/reference/meancov.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute mean and covariance of a matrix — meancov","text":"list containing: E: Vector means time point V: Covariance matrix observations","code":""},{"path":"https://hiddevandebeek.github.io/admr/reference/meancov.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compute mean and covariance of a matrix — meancov","text":"function computes: mean column (time point) using colMeans covariance matrix using cov.wt maximum likelihood estimation weights provided, used mean covariance calculations. function uses maximum likelihood estimation covariance matrix, appropriate aggregate data modeling.","code":""},{"path":"https://hiddevandebeek.github.io/admr/reference/meancov.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute mean and covariance of a matrix — meancov","text":"","code":"# Create a matrix of observations m <- matrix(rnorm(100), nrow = 10, ncol = 10)  # Compute mean and covariance without weights result <- meancov(m)  # Compute mean and covariance with weights weights <- runif(10) result_weighted <- meancov(m, weights)"},{"path":"https://hiddevandebeek.github.io/admr/reference/omegas.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a covariance matrix with specified diagonal and off-diagonal values — omegas","title":"Create a covariance matrix with specified diagonal and off-diagonal values — omegas","text":"omegas creates covariance matrix specified diagonal -diagonal values. function useful creating initial fixed covariance matrices random effects pharmacometric models.","code":""},{"path":"https://hiddevandebeek.github.io/admr/reference/omegas.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a covariance matrix with specified diagonal and off-diagonal values — omegas","text":"","code":"omegas(diag, offdiag, n_om)"},{"path":"https://hiddevandebeek.github.io/admr/reference/omegas.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a covariance matrix with specified diagonal and off-diagonal values — omegas","text":"diag Value diagonal elements matrix. represents variance random effect. offdiag Value -diagonal elements matrix. represents covariance random effects. n_om Size matrix (number random effects).","code":""},{"path":"https://hiddevandebeek.github.io/admr/reference/omegas.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a covariance matrix with specified diagonal and off-diagonal values — omegas","text":"symmetric matrix size n_om x n_om : Diagonal elements equal diag -diagonal elements equal offdiag","code":""},{"path":"https://hiddevandebeek.github.io/admr/reference/omegas.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create a covariance matrix with specified diagonal and off-diagonal values — omegas","text":"function creates symmetric matrix : diagonal elements set diag -diagonal elements set offdiag particularly useful creating: Initial covariance matrices optimization Fixed covariance matrices simulation Simple covariance structures testing","code":""},{"path":"https://hiddevandebeek.github.io/admr/reference/omegas.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a covariance matrix with specified diagonal and off-diagonal values — omegas","text":"","code":"# Create a 3x3 matrix with diagonal = 0.09 and off-diagonal = 0 omega1 <- omegas(0.09, 0, 3)  # Create a 5x5 matrix with diagonal = 0.09 and off-diagonal = 0.01 omega2 <- omegas(0.09, 0.01, 5)"},{"path":"https://hiddevandebeek.github.io/admr/reference/p_to_optim.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert parameters to optimizable form — p_to_optim","title":"Convert parameters to optimizable form — p_to_optim","text":"p_to_optim converts parameter list form suitable optimization transforming parameters computing derivatives. function handles transformation fixed random effect parameters.","code":""},{"path":"https://hiddevandebeek.github.io/admr/reference/p_to_optim.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert parameters to optimizable form — p_to_optim","text":"","code":"p_to_optim(p)"},{"path":"https://hiddevandebeek.github.io/admr/reference/p_to_optim.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert parameters to optimizable form — p_to_optim","text":"p list containing parameter structure: beta: Vector population parameters Omega: Covariance matrix random effects Sigma_prop: Proportional error variance (optional) Sigma_add: Additive error variance (optional)","code":""},{"path":"https://hiddevandebeek.github.io/admr/reference/p_to_optim.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert parameters to optimizable form — p_to_optim","text":"list containing: values: Transformed parameter values backtransformfunc: Function back-transform parameters d_psi_d_psitrans_long: Derivatives transformation d_bi_d_omega: Derivatives random effects respect Omega d_omega_d_Omega: Derivatives omega respect Omega","code":""},{"path":"https://hiddevandebeek.github.io/admr/reference/p_to_optim.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Convert parameters to optimizable form — p_to_optim","text":"function performs several transformations: Log-transforms positive parameters (beta diagonal elements Omega) Transforms correlation parameters using inverse hyperbolic tangent Computes derivatives transformation Handles fixed parameters (specified strings) back-transformation function can used convert optimized parameters back original scale. derivatives used optimization process compute gradients Hessians.","code":""},{"path":"https://hiddevandebeek.github.io/admr/reference/p_to_optim.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert parameters to optimizable form — p_to_optim","text":"","code":"# Define parameters p <- list(   beta = c(cl = 5, v1 = 10, v2 = 30, q = 10, ka = 1),   Omega = matrix(c(0.09, 0, 0, 0, 0,                   0, 0.09, 0, 0, 0,                   0, 0, 0.09, 0, 0,                   0, 0, 0, 0.09, 0,                   0, 0, 0, 0, 0.09), nrow = 5, ncol = 5),   Sigma_prop = 0.04 )  # Convert to optimizable form p_optim <- p_to_optim(p)  # Back-transform parameters p_orig <- p_optim$backtransformfunc(p_optim$values)"},{"path":"https://hiddevandebeek.github.io/admr/reference/plot.fitIRMC_result.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot diagnostics of fitIRMC results — plot.fitIRMC_result","title":"Plot diagnostics of fitIRMC results — plot.fitIRMC_result","text":"Plot diagnostics fitIRMC results","code":""},{"path":"https://hiddevandebeek.github.io/admr/reference/plot.fitIRMC_result.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot diagnostics of fitIRMC results — plot.fitIRMC_result","text":"","code":"# S3 method for class 'fitIRMC_result' plot(x, ...)"},{"path":"https://hiddevandebeek.github.io/admr/reference/plot.fitIRMC_result.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot diagnostics of fitIRMC results — plot.fitIRMC_result","text":"x fitted model object returned fitIRMC ... Additional arguments (used)","code":""},{"path":"https://hiddevandebeek.github.io/admr/reference/print.fitIRMC_result.html","id":null,"dir":"Reference","previous_headings":"","what":"Print fitIRMC results — print.fitIRMC_result","title":"Print fitIRMC results — print.fitIRMC_result","text":"Print fitIRMC results","code":""},{"path":"https://hiddevandebeek.github.io/admr/reference/print.fitIRMC_result.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print fitIRMC results — print.fitIRMC_result","text":"","code":"# S3 method for class 'fitIRMC_result' print(x, ...)"},{"path":"https://hiddevandebeek.github.io/admr/reference/print.fitIRMC_result.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print fitIRMC results — print.fitIRMC_result","text":"x fitted model object returned fitIRMC ... Additional arguments (used)","code":""},{"path":"https://hiddevandebeek.github.io/admr/reference/timedIRMC.html","id":null,"dir":"Reference","previous_headings":"","what":"Fit aggregate data using Iterative Reweighting with Monte Carlo updates — timedIRMC","title":"Fit aggregate data using Iterative Reweighting with Monte Carlo updates — timedIRMC","text":"timedIRMC implements Iterative Reweighting (IRMC) algorithm parameter estimation aggregate data models, iterating maximum likelihood updates weighted Monte Carlo updates. function used compare performance different implementations aggregate data modeling.","code":""},{"path":"https://hiddevandebeek.github.io/admr/reference/timedIRMC.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fit aggregate data using Iterative Reweighting with Monte Carlo updates — timedIRMC","text":"","code":"timedIRMC(init, opts, obs, maxiter = 100, convcrit_nll = 5e-04, nomap = TRUE)"},{"path":"https://hiddevandebeek.github.io/admr/reference/timedIRMC.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fit aggregate data using Iterative Reweighting with Monte Carlo updates — timedIRMC","text":"init Initial parameter values optimization. transformed parameters generated opts$pt. opts list model options generated genopts(). Contains settings model, including prediction function, time points, parameter structure, simulation settings. obs Observed data aggregate form (mean covariance) matrix raw data. maxiter Maximum number iterations optimization algorithm. Default 100. convcrit_nll Convergence criterion negative log-likelihood. algorithm stops relative change negative log-likelihood less value. Default 5e-04. nomap Logical indicating whether use multiple models (FALSE) single model (TRUE). Default TRUE.","code":""},{"path":"https://hiddevandebeek.github.io/admr/reference/timedIRMC.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fit aggregate data using Iterative Reweighting with Monte Carlo updates — timedIRMC","text":"data frame containing: p: List parameter estimates iteration nll: Negative log-likelihood values time: Computation time iteration iter: Iteration number","code":""},{"path":"https://hiddevandebeek.github.io/admr/reference/timedIRMC.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Fit aggregate data using Iterative Reweighting with Monte Carlo updates — timedIRMC","text":"function uses Iterative Reweighting algorithm Monte Carlo sampling optimization. iteration, generates Monte Carlo samples updates parameter estimates using weighted importance sampling. algorithm continues convergence maximum number iterations reached.","code":""},{"path":"https://hiddevandebeek.github.io/admr/reference/timedIRMC.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fit aggregate data using Iterative Reweighting with Monte Carlo updates — timedIRMC","text":"","code":"# Load required libraries library(admr) library(rxode2) library(nlmixr2) library(dplyr) library(tidyr) library(mnorm)  # Load and prepare data data(examplomycin) examplomycin_wide <- examplomycin %>%   filter(EVID != 101) %>%   dplyr::select(ID, TIME, DV) %>%   pivot_wider(names_from = TIME, values_from = DV) %>%   dplyr::select(-c(1))  # Create aggregated data examplomycin_aggregated <- examplomycin_wide %>%   admr::meancov()  # Define RxODE model rxModel <- RxODE({   cp = linCmt(     cl,           # Clearance     v1,           # Volume of the central compartment     v2,           # Volume of the peripheral compartment     q,            # Inter-compartmental clearance     ka            # Absorption rate constant   ) }) #>   #>    # Define prediction function predder <- function(time, theta_i, dose = 100) {   n_individuals <- nrow(theta_i)   if (is.null(n_individuals)) n_individuals <- 1      ev <- eventTable(amount.units=\"mg\", time.units=\"hours\")   ev$add.dosing(dose = dose, nbr.doses = 1, start.time = 0)   ev$add.sampling(time)      out <- rxSolve(rxModel, params = theta_i, events = ev, cores = 0)   cp_matrix <- matrix(out$cp, nrow = n_individuals, ncol = length(time),                       byrow = TRUE)   return(cp_matrix) }  # Create options opts <- genopts(   time = c(.1, .25, .5, 1, 2, 3, 5, 8, 12),   p = list(     beta = c(cl = 5, v1 = 10, v2 = 30, q = 10, ka = 1),     Omega = matrix(c(0.09, 0, 0, 0, 0,                      0, 0.09, 0, 0, 0,                      0, 0, 0.09, 0, 0,                      0, 0, 0, 0.09, 0,                      0, 0, 0, 0, 0.09), nrow = 5, ncol = 5),     Sigma_prop = 0.04   ),   nsim = 2500,   n = 500,   fo_appr = FALSE,   omega_expansion = 1.2,   f = predder )  # Run optimization result <- timedIRMC(opts$pt, opts, examplomycin_aggregated) #> iteration 1, nll=-1839.57745407338 #> iteration 2, nll=-1845.23829291061 #> iteration 3, nll=-1845.28268771688 #> iteration 4, nll=-1845.28266696017 #> should break now due to no difference between OFV and appr OFV print(result) #> # A tibble: 4 × 5 #>   p             nll appr_nll time                 iter #>   <list>      <dbl>    <dbl> <dttm>              <dbl> #> 1 <dbl [11]> -1840.   -1840. 2025-04-03 12:47:34     1 #> 2 <dbl [11]> -1845.   -1845. 2025-04-03 12:47:36     2 #> 3 <dbl [11]> -1845.   -1845. 2025-04-03 12:47:36     3 #> 4 <dbl [11]> -1845.   -1845. 2025-04-03 12:47:37     4"},{"path":"https://hiddevandebeek.github.io/admr/reference/timedbobyqa.html","id":null,"dir":"Reference","previous_headings":"","what":"Fit aggregate data using the bobyqa algorithm with Monte Carlo updates — timedbobyqa","title":"Fit aggregate data using the bobyqa algorithm with Monte Carlo updates — timedbobyqa","text":"timedbobyqa implements bobyqa algorithm parameter estimation aggregate data models, iterating maximum likelihood updates Monte Carlo updates. iteration creates new Monte Carlo samples updates parameter values. function used compare performance different implementations aggregate data modeling.","code":""},{"path":"https://hiddevandebeek.github.io/admr/reference/timedbobyqa.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fit aggregate data using the bobyqa algorithm with Monte Carlo updates — timedbobyqa","text":"","code":"timedbobyqa(init, opts, obs, nomap = TRUE)"},{"path":"https://hiddevandebeek.github.io/admr/reference/timedbobyqa.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fit aggregate data using the bobyqa algorithm with Monte Carlo updates — timedbobyqa","text":"init Initial parameter values optimization. transformed parameters generated opts$pt. opts list model options generated genopts(). Contains settings model, including prediction function, time points, parameter structure, simulation settings. obs Observed data aggregate form (mean covariance) matrix raw data. nomap Logical indicating whether use multiple models (FALSE) single model (TRUE). Default TRUE.","code":""},{"path":"https://hiddevandebeek.github.io/admr/reference/timedbobyqa.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fit aggregate data using the bobyqa algorithm with Monte Carlo updates — timedbobyqa","text":"data frame containing: p: List parameter estimates iteration nll: Negative log-likelihood values time: Computation time iteration iter: Iteration number","code":""},{"path":"https://hiddevandebeek.github.io/admr/reference/timedbobyqa.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Fit aggregate data using the bobyqa algorithm with Monte Carlo updates — timedbobyqa","text":"function uses bobyqa algorithm optimx package optimization. performs Monte Carlo sampling iteration update parameter estimates. algorithm continues convergence maximum number iterations reached.","code":""},{"path":"https://hiddevandebeek.github.io/admr/reference/timedbobyqa.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fit aggregate data using the bobyqa algorithm with Monte Carlo updates — timedbobyqa","text":"","code":"# Load required libraries library(admr) library(rxode2) library(nlmixr2) library(dplyr) library(tidyr) library(mnorm)  # Load and prepare data data(examplomycin) examplomycin_wide <- examplomycin %>%   filter(EVID != 101) %>%   dplyr::select(ID, TIME, DV) %>%   pivot_wider(names_from = TIME, values_from = DV) %>%   dplyr::select(-c(1))  # Create aggregated data examplomycin_aggregated <- examplomycin_wide %>%   admr::meancov()  # Define RxODE model rxModel <- RxODE({   cp = linCmt(     cl,           # Clearance     v1,           # Volume of the central compartment     v2,           # Volume of the peripheral compartment     q,            # Inter-compartmental clearance     ka            # Absorption rate constant   ) }) #>   #>    # Define prediction function predder <- function(time, theta_i, dose = 100) {   n_individuals <- nrow(theta_i)   if (is.null(n_individuals)) n_individuals <- 1      ev <- eventTable(amount.units=\"mg\", time.units=\"hours\")   ev$add.dosing(dose = dose, nbr.doses = 1, start.time = 0)   ev$add.sampling(time)      out <- rxSolve(rxModel, params = theta_i, events = ev, cores = 0)   cp_matrix <- matrix(out$cp, nrow = n_individuals, ncol = length(time),                       byrow = TRUE)   return(cp_matrix) }  # Create options opts <- genopts(   time = c(.1, .25, .5, 1, 2, 3, 5, 8, 12),   p = list(     beta = c(cl = 5, v1 = 10, v2 = 30, q = 10, ka = 1),     Omega = matrix(c(0.09, 0, 0, 0, 0,                      0, 0.09, 0, 0, 0,                      0, 0, 0.09, 0, 0,                      0, 0, 0, 0.09, 0,                      0, 0, 0, 0, 0.09), nrow = 5, ncol = 5),     Sigma_prop = 0.04   ),   nsim = 2500,   n = 500,   fo_appr = FALSE,   omega_expansion = 1.2,   f = predder )  # Run optimization result <- timedbobyqa(opts$pt, opts, examplomycin_aggregated) #> Iteration: 50 - NLL: -1842.696  #> Iteration: 100 - NLL: -1844.712  #> Iteration: 150 - NLL: -1845.05  #> Iteration: 200 - NLL: -1845.218  #> Iteration: 250 - NLL: -1845.241  #> Iteration: 300 - NLL: -1845.254  #> Iteration: 350 - NLL: -1845.273  #> Iteration: 400 - NLL: -1845.281  #> Iteration: 450 - NLL: -1845.284  #> Iteration: 500 - NLL: -1845.288  #> Iteration: 550 - NLL: -1845.29  print(result) #> # A tibble: 565 × 4 #>    p             nll time                 iter #>    <list>      <dbl> <dttm>              <dbl> #>  1 <dbl [11]> -1840. 2025-04-03 12:47:37     1 #>  2 <dbl [11]> -1840. 2025-04-03 12:47:37     2 #>  3 <dbl [11]> -1840. 2025-04-03 12:47:38     3 #>  4 <dbl [11]> 14057. 2025-04-03 12:47:38     4 #>  5 <dbl [11]>  5029. 2025-04-03 12:47:38     5 #>  6 <dbl [11]>   227. 2025-04-03 12:47:38     6 #>  7 <dbl [11]>  -417. 2025-04-03 12:47:38     7 #>  8 <dbl [11]>  -413. 2025-04-03 12:47:39     8 #>  9 <dbl [11]> -1779. 2025-04-03 12:47:39     9 #> 10 <dbl [11]> -1800. 2025-04-03 12:47:39    10 #> # ℹ 555 more rows"},{"path":"https://hiddevandebeek.github.io/admr/news/index.html","id":"admr-010","dir":"Changelog","previous_headings":"","what":"admr 0.1.0","title":"admr 0.1.0","text":"Initial CRAN submission.","code":""}]
