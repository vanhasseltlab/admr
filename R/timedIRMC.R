#' Fit aggregate data using Iterative Reweighting with Monte Carlo updates
#'
#' @description
#' `timedIRMC` implements the Iterative Reweighting (IRMC) algorithm for parameter estimation of
#' aggregate data models, iterating over maximum likelihood updates with weighted Monte Carlo
#' updates. This function is used to compare the performance of different implementations of
#' aggregate data modeling.
#'
#' @param init Initial parameter values for optimization. These should be transformed parameters
#'             as generated by `opts$pt`.
#' @param opts A list of model options generated by `genopts()`. Contains settings for the model,
#'             including the prediction function, time points, parameter structure, and simulation
#'             settings.
#' @param obs Observed data in aggregate form (mean and covariance) or as a matrix of raw data.
#' @param maxiter Maximum number of iterations for the optimization algorithm. Default is 100.
#' @param convcrit_nll Convergence criterion for the negative log-likelihood. The algorithm stops
#'                     when the relative change in negative log-likelihood is less than this value.
#'                     Default is 5e-04.
#' @param nomap Logical indicating whether to use multiple models (FALSE) or a single model (TRUE).
#'              Default is TRUE.
#'
#' @returns A data frame containing:
#' \itemize{
#'   \item `p`: List of parameter estimates for each iteration
#'   \item `nll`: Negative log-likelihood values
#'   \item `time`: Computation time for each iteration
#'   \item `iter`: Iteration number
#' }
#'
#' @details
#' The function uses the Iterative Reweighting algorithm with Monte Carlo sampling for optimization.
#' At each iteration, it generates Monte Carlo samples and updates the parameter estimates using
#' weighted importance sampling. The algorithm continues until convergence or until the maximum
#' number of iterations is reached.
#'
#' @examples
#' # Create test data
#' test_data <- create_test_data()
#' opts <- test_data$opts
#' obs <- test_data$obs
#'
#' # Run optimization
#' result <- timedIRMC(opts$pt, opts, obs)
#'
#' # View results
#' print(result)
#'
#' @export
timedIRMC <- function(init, opts, obs, maxiter = 100, convcrit_nll = 5e-04, nomap = TRUE) { # Implements the Expectation-Maximization (IRMC) algorithm for parameter estimation, iterating over maximum likelihood updates.
  if (nomap) {
    opts <- opts %>% p2opts(init) %>% obs2opts(obs)
  } else {
    opts <- map(seq_along(opts),function(i) opts[[i]] %>% p2opts(init) %>% obs2opts(obs[[i]]))
  }

  res <- tibble(p=vector("list",maxiter),
                nll=NA,
                appr_nll=NA,
                time=Sys.time(),
                iter=1)
  res$p[[1]] <- init
  res$time[1] <- Sys.time()
  res$nll[1] <- compute_nll(opts, init, nomap)
  res$appr_nll[1] <- res$nll[1]
  message(paste0("iteration ",1,", nll=",res$nll[1]))
  pvals <- rep(0,length(init)+1)
  for (i in 2:maxiter) {
    if (nomap) {
      ff <- maxfunc(p2opts(opts,init))
    } else {
      ffs <- map(opts,~maxfunc(p2opts(.,init)))
      ff <- function(p) Reduce('+',map(ffs,~.(p)))
    }

    ff_nloptr <- function(params) {
      ff(params)
    }

    m0 <- nloptr::nloptr(
      x0 = init,
      eval_f = ff_nloptr,
      lb = init - 2,
      ub = init + 2,
      opts = list(
        algorithm = "NLOPT_LN_BOBYQA",
        ftol_rel=.Machine$double.eps^2,
        maxeval = 5000
      )
    )

    init <- m0$solution
    res$p[[i]] <- init
    res$time[i] <- Sys.time()
    res$nll[i] <- compute_nll(opts, init, nomap)
    res$appr_nll[i] <- m0$objective
    res$iter[i] <- i
    message(paste0("iteration ",i,", nll=",res$nll[i]))
    if (i>10) {
      pset <- do.call(rbind,res$p) %>% cbind(res$nll[!is.na(res$nll)]) %>% tail(10)
      pvals <- map(1:ncol(pset),function(colN) {
        xx <- 1:10
        yy <- pset[,colN]
        summary(lm(yy~xx))$coef[2,4]
      })
    }
    if (all(pvals>0.05)) {message("should break now due to stationary ofv+parameters");break()}
    if (abs(res$nll[i]-res$appr_nll[i]) <convcrit_nll) {message("should break now due to no difference between OFV and appr OFV");break()}
  }
  res[!is.na(res$nll),]
}

