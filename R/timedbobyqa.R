#' Fit aggregate data using the bobyqa algorithm with Monte Carlo updates
#'
#' @description
#' `timedbobyqa` implements the bobyqa algorithm for parameter estimation of aggregate data models,
#' iterating over maximum likelihood updates with Monte Carlo updates. Each iteration creates new
#' Monte Carlo samples and updates the parameter values. This function is used to compare the
#' performance of different implementations of aggregate data modeling.
#'
#' @param init Initial parameter values for optimization. These should be transformed parameters
#'             as generated by `opts$pt`.
#' @param opts A list of model options generated by `genopts()`. Contains settings for the model,
#'             including the prediction function, time points, parameter structure, and simulation
#'             settings.
#' @param obs Observed data in aggregate form (mean and covariance) or as a matrix of raw data.
#' @param nomap Logical indicating whether to use multiple models (FALSE) or a single model (TRUE).
#'              Default is TRUE.
#'
#' @returns A data frame containing:
#' \itemize{
#'   \item `p`: List of parameter estimates for each iteration
#'   \item `nll`: Negative log-likelihood values
#'   \item `time`: Computation time for each iteration
#'   \item `iter`: Iteration number
#' }
#'
#' @details
#' The function uses the bobyqa algorithm from the optimx package for optimization. It performs
#' Monte Carlo sampling at each iteration to update the parameter estimates. The algorithm continues
#' until convergence or until the maximum number of iterations is reached.
#'
#' @examples
#' # Load required libraries
#' library(admr)
#' library(rxode2)
#' library(nlmixr2)
#' library(dplyr)
#' library(tidyr)
#' library(mnorm)
#' 
#' # Load and prepare data
#' data(examplomycin)
#' examplomycin_wide <- examplomycin %>%
#'   filter(EVID != 101) %>%
#'   dplyr::select(ID, TIME, DV) %>%
#'   pivot_wider(names_from = TIME, values_from = DV) %>%
#'   dplyr::select(-c(1))
#' 
#' # Create aggregated data
#' examplomycin_aggregated <- examplomycin_wide %>%
#'   admr::meancov()
#' 
#' # Define RxODE model
#' rxModel <- RxODE({
#'   cp = linCmt(
#'     cl,           # Clearance
#'     v1,           # Volume of the central compartment
#'     v2,           # Volume of the peripheral compartment
#'     q,            # Inter-compartmental clearance
#'     ka            # Absorption rate constant
#'   )
#' })
#' 
#' # Define prediction function
#' predder <- function(time, theta_i, dose = 100) {
#'   n_individuals <- nrow(theta_i)
#'   if (is.null(n_individuals)) n_individuals <- 1
#'   
#'   ev <- eventTable(amount.units="mg", time.units="hours")
#'   ev$add.dosing(dose = dose, nbr.doses = 1, start.time = 0)
#'   ev$add.sampling(time)
#'   
#'   out <- rxSolve(rxModel, params = theta_i, events = ev, cores = 0)
#'   cp_matrix <- matrix(out$cp, nrow = n_individuals, ncol = length(time),
#'                       byrow = TRUE)
#'   return(cp_matrix)
#' }
#' 
#' # Create options
#' opts <- genopts(
#'   time = c(.1, .25, .5, 1, 2, 3, 5, 8, 12),
#'   p = list(
#'     beta = c(cl = 5, v1 = 10, v2 = 30, q = 10, ka = 1),
#'     Omega = matrix(c(0.09, 0, 0, 0, 0,
#'                      0, 0.09, 0, 0, 0,
#'                      0, 0, 0.09, 0, 0,
#'                      0, 0, 0, 0.09, 0,
#'                      0, 0, 0, 0, 0.09), nrow = 5, ncol = 5),
#'     Sigma_prop = 0.04
#'   ),
#'   nsim = 2500,
#'   n = 500,
#'   fo_appr = FALSE,
#'   omega_expansion = 1.2,
#'   f = predder
#' )
#' 
#' # Run optimization
#' result <- timedbobyqa(opts$pt, opts, examplomycin_aggregated)
#' print(result)
#'
#' @export
timedbobyqa <- function(init, opts, obs, nomap = TRUE) {
  # Convert initial parameters and observed data to optimization format
  if (nomap) {
    opts <- opts %>% p2opts(init) %>% obs2opts(obs)
  } else {
    opts <- map(seq_along(opts),function(i) opts[[i]] %>% p2opts(init) %>% obs2opts(obs[[i]]))
  }

  # Initialize results data frame with larger size for more iterations
  res <- tibble(p=vector("list",1e4),nll=NA,time=Sys.time(),iter=NA)

  # Initialize iteration counter
  i <- 1

  # Generate objective function based on number of models
  if (nomap) {
    fitfun <- genfitfunc(opts, obs)
  } else {
    fitfuns <- map(seq_along(opts), ~ genfitfunc(opts[[.x]], obs[[.x]]))
    fitfun <- function(p) Reduce('+', map(fitfuns, ~ .(p)))
  }

  # Create wrapper function to track optimization progress
  fitfun2 <- function(p) {
    nllNow <- fitfun(p)
    res$p[[i]] <<- p
    res$time[i] <<- Sys.time()
    res$nll[i] <<- nllNow
    res$iter[i] <<- i

    # Print progress every 50 iterations
    if (i %% 50 == 0) {
      cat("Iteration:", i, "- NLL:", nllNow, "\n")
    }
    i <<- i + 1
    nllNow
  }

  # Run BOBYQA optimization with bounds
  est <- nloptr::nloptr(init,
                        fitfun2,
                        lb=init-2,  # Lower bounds: 2 units below initial values
                        ub=init+2,  # Upper bounds: 2 units above initial values
                        opts=list(
                          algorithm="NLOPT_LN_BOBYQA",
                          ftol_rel=.Machine$double.eps^2,  # Relative function tolerance
                          maxeval = 5000,                    # max number of evaluations
                          check_derivatives = F))  # Skip derivative checking for performance
  est$solution
  res[!is.na(res$nll),]
}
