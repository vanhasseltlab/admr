#' Fit aggregate data using the bobyqa algorithm with Monte Carlo updates
#'
#' @description
#' `timedbobyqa` implements the bobyqa algorithm for parameter estimation of aggregate data models,
#' iterating over maximum likelihood updates with Monte Carlo updates. Each iteration creates new
#' Monte Carlo samples and updates the parameter values. This function is used to compare the
#' performance of different implementations of aggregate data modeling.
#'
#' @param init Initial parameter values for optimization. These should be transformed parameters
#'             as generated by `opts$pt`.
#' @param opts A list of model options generated by `genopts()`. Contains settings for the model,
#'             including the prediction function, time points, parameter structure, and simulation
#'             settings.
#' @param obs Observed data in aggregate form (mean and covariance) or as a matrix of raw data.
#' @param nomap Logical indicating whether to use multiple models (FALSE) or a single model (TRUE).
#'              Default is TRUE.
#'
#' @returns A data frame containing:
#' \itemize{
#'   \item `p`: List of parameter estimates for each iteration
#'   \item `nll`: Negative log-likelihood values
#'   \item `time`: Computation time for each iteration
#'   \item `iter`: Iteration number
#' }
#'
#' @details
#' The function uses the bobyqa algorithm from the optimx package for optimization. It performs
#' Monte Carlo sampling at each iteration to update the parameter estimates. The algorithm continues
#' until convergence or until the maximum number of iterations is reached.
#'
#' @examples
#' # Create test data
#' test_data <- create_test_data()
#' opts <- test_data$opts
#' obs <- test_data$obs
#'
#' # Run optimization
#' result <- timedbobyqa(opts$pt, opts, obs)
#'
#' # View results
#' print(result)
#'
#' @export
timedbobyqa <- function(init, opts, obs, nomap = TRUE) {

  if (nomap) {
    opts <- opts %>% p2opts(init) %>% obs2opts(obs)
  } else {
    opts <- map(seq_along(opts),function(i) opts[[i]] %>% p2opts(init) %>% obs2opts(obs[[i]]))
  }

  res <- tibble(p=vector("list",1e4),nll=NA,time=Sys.time(),iter=NA)

  i <- 1

  if (nomap) {
    fitfun <- genfitfunc(opts, obs)
  } else {
    fitfuns <- map(seq_along(opts), ~ genfitfunc(opts[[.x]], obs[[.x]]))
    fitfun <- function(p) Reduce('+', map(fitfuns, ~ .(p)))
  }

  fitfun2 <- function(p) {
    nllNow <- fitfun(p)
    res$p[[i]] <<- p
    res$time[i] <<- Sys.time()
    res$nll[i] <<- nllNow
    res$iter[i] <<- i

    if (i %% 50 == 0) {
      cat("Iteration:", i, "- NLL:", nllNow, "\n")
    }
    i <<- i + 1
    nllNow
  }

  est <- nloptr::nloptr(init,
                        fitfun2,
                        lb=init-2,
                        ub=init+2,
                        opts=list(
                          algorithm="NLOPT_LN_BOBYQA",
                          ftol_rel=.Machine$double.eps^2,
                          maxeval = 5000,                    # max number of evaluations
                          check_derivatives = F))
  est$solution
  res[!is.na(res$nll),]
}
