#' Fit aggregate data using the bobyqa algorithm with Monte Carlo updates
#'
#' @description
#' `fitMC` implements the bobyqa algorithm for parameter estimation of aggregate data models,
#' iterating over maximum likelihood updates with Monte Carlo updates. Each iteration creates new
#' Monte Carlo samples and updates the parameter values. This function is used to compare the
#' performance of different implementations of aggregate data modeling.
#'
#' @param opts A list of model options generated by `genopts()`. Contains settings for the model,
#'             including the prediction function, time points, parameter structure, and simulation
#'             settings.
#' @param obs Observed data in aggregate form (mean and covariance) or as a matrix of raw data.
#' @param maxiter Maximum number of iterations for the optimization algorithm. Default is 100.
#' @param convcrit_nll Convergence criterion for the negative log-likelihood. The algorithm stops
#'                     when the relative change in negative log-likelihood is less than this value.
#'                     Default is 1e-05.
#' @param single_dataframe Logical indicating whether to use a single data frame (TRUE) or multiple
#'                        data frames (FALSE). Default is TRUE.
#' @param chains Number of chains to run. Default is 1.
#' @param perturbation Perturbation factor for the initial parameter values of each chain.
#'                    Default is 0.1.
#' @param seed Random seed for reproducibility. Default is 1.
#'
#' @returns An object of class `fit_admr_result` containing:
#' \itemize{
#'   \item `p`: List of parameter estimates for each iteration
#'   \item `nll`: Negative log-likelihood values
#'   \item `time`: Computation time for each iteration
#'   \item `iter`: Iteration number
#'   \item `chain`: Chain number (not used in the standard MC algorithm)
#'   \item `phase`: Optimization phase number
#' }
#'
#' @details
#' The function uses the Monte Carlo algorithm with Monte Carlo sampling for optimization.
#' The optimization process is performed using the `bobyqa` algorithm, which is suitable for
#' non-linear optimization problems. The function supports both single and multiple data frames,
#' allowing flexibility in how the observed data is structured.
#'
#' @examples
#' # Load required libraries
#' library(admr)
#' library(rxode2)
#' library(nlmixr2)
#' library(dplyr)
#' library(tidyr)
#' library(mnorm)
#'
#' # Load and prepare data
#' data(examplomycin)
#' examplomycin_wide <- examplomycin %>%
#'   filter(EVID != 101) %>%
#'   dplyr::select(ID, TIME, DV) %>%
#'   pivot_wider(names_from = TIME, values_from = DV) %>%
#'   dplyr::select(-c(1))
#'
#' # Create aggregated data
#' examplomycin_aggregated <- examplomycin_wide %>%
#'   admr::meancov()
#'
#' # Define RxODE model
#' rxModel <- RxODE({
#'   cp = linCmt(
#'     cl,           # Clearance
#'     v1,           # Volume of the central compartment
#'     v2,           # Volume of the peripheral compartment
#'     q,            # Inter-compartmental clearance
#'     ka            # Absorption rate constant
#'   )
#' })
#'
#' # Define prediction function
#' predder <- function(time, theta_i, dose = 100) {
#'   n_individuals <- nrow(theta_i)
#'   if (is.null(n_individuals)) n_individuals <- 1
#'
#'   ev <- eventTable(amount.units="mg", time.units="hours")
#'   ev$add.dosing(dose = dose, nbr.doses = 1, start.time = 0)
#'   ev$add.sampling(time)
#'
#'   out <- rxSolve(rxModel, params = theta_i, events = ev, cores = 0)
#'   cp_matrix <- matrix(out$cp, nrow = n_individuals, ncol = length(time),
#'                       byrow = TRUE)
#'   return(cp_matrix)
#' }
#'
#' # Create options
#' opts <- genopts(
#'   time = c(.1, .25, .5, 1, 2, 3, 5, 8, 12),
#'   p = list(
#'     beta = c(cl = 5, v1 = 10, v2 = 30, q = 10, ka = 1),
#'     Omega = matrix(c(0.09, 0, 0, 0, 0,
#'                      0, 0.09, 0, 0, 0,
#'                      0, 0, 0.09, 0, 0,
#'                      0, 0, 0, 0.09, 0,
#'                      0, 0, 0, 0, 0.09), nrow = 5, ncol = 5),
#'     Sigma_prop = 0.04
#'   ),
#'   nsim = 2500,
#'   n = 500,
#'   fo_appr = FALSE,
#'   omega_expansion = 1.2,
#'   f = predder
#' )
#'
#' # Run optimization
#' result <- fitMC(opts, examplomycin_aggregated)
#' print(result)
#'
#' @export
fitMC <- function(opts, obs, maxiter = 5000, convcrit_nll = 1e-05,
                  single_dataframe = TRUE, chains = 1, perturbation = 0.1, seed = 1) {

  # Set random seed for reproducibility
  set.seed(seed)
  nomap <- single_dataframe

  # Get initial parameter values
  if (nomap){
    init <- opts$pt
  } else{
    init <- opts[[1]]$pt
  }

  # Convert initial parameters and observed data to optimization format
  if (nomap) {
    opts <- opts %>% p2opts(init) %>% obs2opts(obs)
  } else {
    opts <- map(seq_along(opts),function(i) opts[[i]] %>% p2opts(init) %>% obs2opts(obs[[i]]))
  }

  # Initialize timing and results storage
  start_time <- Sys.time()  # Start time for the entire process
  chain_results <- vector("list", chains)  # Store results for each chain

  # Run optimization chains
  for (chain in seq_len(chains)) {
    chain_results[[chain]] <- run_chainMC(
      chain = chain,
      opts = opts,
      obs = obs,
      init = init,
      maxiter = maxiter,
      convcrit_nll = convcrit_nll,
      perturbation = perturbation,
      nomap = nomap
    )
  }

  # Select best chain based on negative log-likelihood
  best_chain <- which.min(sapply(chain_results, function(x) x$best_nll))
  final_result <- chain_results[[best_chain]]
  final_params <- final_result$best_params
  final_nll <- final_result$best_nll
  final_res <- final_result$res  # Final iteration history

  # Compute covariance matrix for fixed effects
  cov_start_time <- Sys.time()
  func_fixed <- function(beta) {
    p_full <- final_params
    p_full[1:length(beta)] <- beta
    opts_list <- if (nomap) list(opts) else opts
    obs_list <- if (nomap) list(obs) else obs
    sum(sapply(seq_along(opts_list), function(i) genfitfunc(opts_list[[i]], obs_list[[i]])(p_full)))
  }

  # Compute Hessian matrix using Richardson method
  cov_matrix_fixed <- tryCatch(
    solve(numDeriv::hessian(func_fixed, final_params[1:length(if (nomap) opts$p$beta else opts[[2]]$p$beta)],
                            method = "Richardson", method.args = list(r=6, v=2))),
    error = function(e) NA
  )

  cov_time <- as.numeric(difftime(Sys.time(), cov_start_time, units = "secs"))

  # Compute standard errors for fixed effects
  tryCatch(
    se_fixed <- if (is.matrix(cov_matrix_fixed)) {
      sqrt(diag(cov_matrix_fixed))
    } else {
      rep(NA, length(if (nomap) opts$p$beta else opts[[1]]$p$beta))
    }, error = function(e) NULL)

  # Back-transform parameters to original scale
  back_transformed_params <- tryCatch(
    if (nomap) opts$ptrans(final_params) else opts[[1]]$ptrans(final_params),
    error = function(e) NA
  )

  # Compute BIC for model selection
  bic <- if (nomap) {
    -2 * final_nll + log(opts$n) * length(final_params)
  } else {
    -2 * final_nll + (log(opts[[1]]$n) + log(opts[[2]]$n)) * length(final_params)
  }

  # Extract parameter names and values
  param_names <- names(back_transformed_params$beta)
  beta_params <- final_params[1:length(se_fixed)]
  beta_se <- se_fixed
  residual_error <- exp(final_params[length(final_params)])

  # Compute confidence intervals for back-transformed parameters
  beta_estimates_original <- back_transformed_params$beta[1:length(beta_params)]
  confint_low_original <- exp(beta_params - 1.96 * beta_se)
  confint_high_original <- exp(beta_params + 1.96 * beta_se)

  # Handle missing or NA single_betas
  single_betas <- opts$single_betas

  # If NULL or NA, assume all FALSE
  if (is.null(single_betas) || all(is.na(single_betas))) {
    single_betas <- rep(FALSE, length(beta_params))
  } else {
    single_betas <- as.logical(single_betas)
    single_betas[is.na(single_betas)] <- FALSE  # replace any remaining NA
  }

  # Parameters with BSV are those not marked fixed
  has_bsv <- !single_betas

  # Initialize and fill BSV values
  bsv_vals <- rep(NA_real_, length(beta_params))
  bsv_vals[has_bsv] <- calculate_bsv(back_transformed_params)

  # Generate comprehensive output object
  output <- list(
    final_params = final_params,
    transformed_params = back_transformed_params,
    param_df = tibble(
      Parameter = c(param_names, "Residual Error"),
      `Est.` = c(beta_params, residual_error),
      `SE` = c(beta_se, NA),
      `%RSE` = c(100 * beta_se / abs(beta_params), NA),
      `Back-transformed(95%CI)` = c(
        paste0(
          sprintf("%.2f", beta_estimates_original), " (",
          sprintf("%.2f", confint_low_original), ", ",
          sprintf("%.2f", confint_high_original), ")"
        ),
        sprintf("%.4f", residual_error)
      ),
      `BSV(CV%)` = c(bsv_vals, NA)
    ),
    covariance_matrix = cov_matrix_fixed,
    convergence_info = list(
      converged = nrow(final_res) < maxiter,
      total_iterations = nrow(final_res),
      final_nll = final_nll,
      total_time = as.numeric(difftime(Sys.time(), start_time, units = "secs")),
      chain_time = final_result$time,
      covariance_time = cov_time,
      aic = -2 * final_nll + length(final_params),
      bic = bic
    ),
    diagnostics = list(
      best_chain = best_chain,
      nll_trace = final_res$nll,
      iteration_times = final_res$iteration_time,
      time_per_iteration_summary = summary(final_res$iteration_time, na.rm = TRUE)
    ),
    chain_results = chain_results,  # Save results of all chains
    iteration_history = final_res,
    data = list(
      opts = opts,
      obs = obs
    )
  )

  # Set class and return results
  class(output) <- "fit_admr_result"
  output
}
