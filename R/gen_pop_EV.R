#' Compute expected population-level mean and covariance
#'
#' @description
#' `gen_pop_EV` computes the expected population-level mean and covariance of the model predictions
#' using either first-order approximation (FO) or Monte Carlo (MC) methods. The function is a core
#' component of the aggregate data modeling framework, used to generate expected values for model
#' fitting and optimization.
#'
#' @param opts A list of model options generated by `genopts()`. Contains settings for the model,
#'             including the prediction function, time points, parameter structure, and simulation
#'             settings.
#'
#' @returns A list containing:
#' \itemize{
#'   \item `E`: Expected mean of the model predictions
#'   \item `V`: Expected covariance of the model predictions
#' }
#'
#' @details
#' The function uses two different approaches to compute the expected values:
#' \itemize{
#'   \item First-order approximation (FO): Used when `opts$fo_appr` is TRUE. This method:
#'         \itemize{
#'           \item Generates random effects using `gen_bi()`
#'           \item Computes importance sampling weights
#'           \item Uses FOCE approximation for each individual
#'           \item Combines results using weighted averaging
#'         }
#'   \item Monte Carlo approximation (MC): Used when `opts$fo_appr` is FALSE. This method:
#'         \itemize{
#'           \item Generates random effects
#'           \item Computes individual predictions
#'           \item Uses weighted averaging when omega expansion is used
#'         }
#' }
#'
#' The choice between FO and MC methods depends on the number of Monte Carlo samples (`nsim`).
#' FO is used by default when `nsim < 10`, while MC is used otherwise.
#'
#' @examples
#' # Create test data
#' test_data <- create_test_data()
#' opts <- test_data$opts
#'
#' # Compute expected values using FO approximation
#' opts$fo_appr <- TRUE
#' ev_fo <- gen_pop_EV(opts)
#' expect_named(ev_fo, c("E", "V"))
#'
#' # Compute expected values using MC approximation
#' opts$fo_appr <- FALSE
#' ev_mc <- gen_pop_EV(opts)
#' expect_named(ev_mc, c("E", "V"))
#'
#' @export
gen_pop_EV <- function(opts) {
  if (opts$fo_appr) {
    bi <- gen_bi(opts)
    logweights <- samplogdensfun(bi,opts$p,opts$omega_expansion)
    weights <- logweights %>% logdens2wt()
    rawres <- map(1:nrow(bi),~foceapprEV_single(opts,bi[.,,drop=FALSE],opts$biseq[.,,drop=FALSE]))
    E_pred <- Reduce('+',map2(rawres,weights,~.x$E*.y))
    V_pred <- Reduce('+',map2(rawres,weights,~.x$V*.y))
  } else {
    res <- MCapprEV(opts)
    E_pred <- res$E
    V_pred <- res$V
  }
  return(list(E=E_pred,V=V_pred))
} 