#' Compute expected population-level mean and covariance
#'
#' @description
#' `gen_pop_EV` computes the expected population-level mean and covariance of the model predictions
#' using either first-order approximation (FO) or Monte Carlo (MC) methods. The function is a core
#' component of the aggregate data modeling framework, used to generate expected values for model
#' fitting and optimization.
#'
#' @param opts A list of model options generated by `genopts()`. Contains settings for the model,
#'             including:
#'             \itemize{
#'               \item Prediction function (f)
#'               \item Time points for prediction
#'               \item Population parameters (beta)
#'               \item Between-subject variability (Omega)
#'               \item Method selection (fo_appr)
#'               \item Number of Monte Carlo samples (nsim)
#'               \item Omega expansion factor
#'             }
#'
#' @returns A list containing:
#' \itemize{
#'   \item `E`: Expected mean of the model predictions at each time point
#'   \item `V`: Expected covariance matrix of the predictions across time points
#' }
#'
#' @details
#' The function implements two methods for computing population expectations:
#'
#' 1. First-Order (FO) Approximation (when opts$fo_appr is TRUE):
#'    - Uses linearization around the random effects (η)
#'    - Steps:
#'      a. Generate random effects samples
#'      b. Compute importance sampling weights based on η distribution
#'      c. For each individual:
#'         - Compute FOCE approximation of mean and covariance
#'         - Apply importance sampling weights
#'      d. Combine weighted results across individuals
#'    - Advantages:
#'      * Computationally efficient for complex models
#'      * Good accuracy for nearly linear systems
#'    - Used when:
#'      * Number of Monte Carlo samples is small (nsim < 10)
#'      * Model is approximately linear in random effects
#'
#' 2. Monte Carlo (MC) Approximation (when opts$fo_appr is FALSE):
#'    - Uses direct simulation to estimate expectations
#'    - Steps:
#'      a. Generate random effects samples
#'      b. Compute full model predictions for each sample
#'      c. Calculate empirical mean and covariance
#'      d. Apply importance sampling if omega expansion is used
#'    - Advantages:
#'      * No linearization assumptions
#'      * More accurate for highly nonlinear models
#'    - Used when:
#'      * Sufficient Monte Carlo samples available
#'      * High accuracy required
#'      * Model is highly nonlinear
#'
#' The choice between methods depends on:
#' - Model complexity and nonlinearity
#' - Required accuracy
#' - Computational resources
#' - Number of available Monte Carlo samples
#'
#' @examples
#' # Create test data with a two-compartment model
#' test_data <- create_test_data()
#' opts <- test_data$opts
#'
#' # Compute expectations using FO approximation
#' # Useful for quick approximations or when nsim is small
#' opts$fo_appr <- TRUE
#' ev_fo <- gen_pop_EV(opts)
#' expect_named(ev_fo, c("E", "V"))
#'
#' # Compute expectations using MC approximation
#' # More accurate but computationally intensive
#' opts$fo_appr <- FALSE
#' ev_mc <- gen_pop_EV(opts)
#' expect_named(ev_mc, c("E", "V"))
#'
#' @export
gen_pop_EV <- function(opts) {
  if (opts$fo_appr) {
    # First-Order Conditional Estimation (FOCE) approach
    
    # Generate random effects samples
    bi <- gen_bi(opts)
    
    # Compute importance sampling weights for random effects
    # logweights = log density of samples under target distribution
    logweights <- samplogdensfun(bi, opts$p, opts$omega_expansion)
    weights <- logweights %>% logdens2wt()  # Convert to normalized weights
    
    # Compute FOCE approximation for each individual
    # Map over each row of random effects matrix
    rawres <- map(1:nrow(bi), 
                  ~foceapprEV_single(opts, 
                                   bi[.,,drop=FALSE],  # Random effects for one individual
                                   opts$biseq[.,,drop=FALSE]))  # Sequential random effects
    
    # Compute weighted means of expectations and covariances
    E_pred <- Reduce('+', map2(rawres, weights, ~.x$E * .y))  # Weighted mean
    V_pred <- Reduce('+', map2(rawres, weights, ~.x$V * .y))  # Weighted covariance
    
  } else {
    # Monte Carlo approach
    
    # Compute expectations using direct Monte Carlo simulation
    res <- MCapprEV(opts)
    E_pred <- res$E  # Monte Carlo estimate of mean
    V_pred <- res$V  # Monte Carlo estimate of covariance
  }
  
  # Return population-level expectations
  return(list(E = E_pred,  # Expected mean at each time point
              V = V_pred)) # Expected covariance matrix
} 