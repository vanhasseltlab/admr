#' Generate a fitting function for optimization
#'
#' @description
#' `genfitfunc` generates a fitting function for optimization that computes the negative
#' log-likelihood of the model given the observed data and current parameter estimates.
#' The function handles both raw data and aggregate data (mean and covariance) formats.
#'
#' @param opts A list of model options generated by `genopts()`. Contains settings for the model,
#'             including the prediction function, time points, parameter structure, and simulation
#'             settings.
#' @param obs Observed data in aggregate form (mean and covariance) or as a matrix of raw data.
#'            If missing, the expected data from the model is used.
#'
#' @returns A function that takes parameter values as input and returns the negative log-likelihood
#'          of the model given the observed data. The function signature is:
#'          `function(p) -> numeric`
#'
#' @details
#' The generated fitting function:
#' \itemize{
#'   \item Computes the expected mean and covariance of the model predictions
#'   \item Compares these with the observed data
#'   \item Returns the negative log-likelihood of the model
#' }
#'
#' If raw data is provided, it is automatically converted to aggregate form (mean and covariance)
#' using the `meancov` function. The function handles both single models and multiple models
#' (when `opts` is a list of model options).
#'
#' @examples
#' # Create test data
#' test_data <- create_test_data()
#' opts <- test_data$opts
#' obs <- test_data$obs
#'
#' # Generate fitting function
#' fitfun <- genfitfunc(opts, obs)
#'
#' # Evaluate at initial parameters
#' nll <- fitfun(opts$pt)
#'
#' @export
genfitfunc <- function(opts, obs) { # Generates a fitting function for optimization, taking observed data and model options as inputs.
  ### Generate sequence of covariates ai, and initial values of random effects biseq
  if (!(is.matrix(obs) && nrow(obs)==opts$nsim && ncol(obs)==opts$time) && !all(names(obs)== c("E","V")))
    stop("obs argument should give the data in aggregate form or as an nsim x Xi matrix!")
  if (missing(obs)) {## if observed data is missing, use expected data.
    message("genfitfunc message: Obs not supplied, using expected data as obs...")
    obs <- gen_pop_EV(opts)[1:2]
  }
  if (is.matrix(obs)) {
    message("genfitfunc message: Converting obs from raw data to aggregate E and V...")
    obs  <- meancov(obs)
  }
  ## make sure the obs$E is a normal vector
  obs$E <- c(obs$E)
  ## append obs to opts
  opts$obs <- obs
  function(pp,givedetails=FALSE,opts_overrides) {
    if (!missing(opts_overrides)) opts <- opts_overrides
    if (missing(pp)) pp <- opts$pt
    if (!is.list(pp)) {
      opts$pt <- pp
      opts$p <- opts$ptrans(pp)
    } else {
      opts$p <- pp
      opts$pt <- p_to_optim(pp)$values
    }
    EV <- gen_pop_EV(opts)
    invV <- tryCatch(solve(EV[[2]]),error=function(e) return(NA))
    if (any(is.na(invV))) stop("Problems inverting V, V=",paste(signif(EV[[2]],5),collapse="\n"),
                               "\n solve(V)=",paste(signif(invV,5),collapse="\n"))
    var_nll <- nllfun(opts$obs,EV,invV,opts$n)
    if (givedetails) {
      attr(var_nll,"EV") <- EV
      attr(var_nll,"obs") <- obs
      attr(var_nll,"nllfun") <- function(EV) nllfun(obs,EV,n=opts$n)
      attr(var_nll,"opts") <- opts
    }
    return(var_nll)
  }
}
