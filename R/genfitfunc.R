#' Generate a fitting function for optimization
#'
#' @description
#' `genfitfunc` generates a fitting function for optimization that computes the negative
#' log-likelihood of the model given the observed data and current parameter estimates.
#' The function handles both raw data and aggregate data (mean and covariance) formats.
#'
#' @param opts A list of model options generated by `genopts()`. Contains settings for the model,
#'             including:
#'             \itemize{
#'               \item `f`: Prediction function for the model
#'               \item `time`: Vector of observation times
#'               \item `p`: List of parameter values and structure
#'               \item `nsim`: Number of Monte Carlo samples
#'               \item `n`: Number of individuals
#'               \item `pt`: Parameter values on transformed scale
#'               \item `ptrans`: Parameter transformation function
#'             }
#' @param obs Observed data in one of two formats:
#'            1. Aggregate form: List with elements:
#'               - `E`: Vector of means for each time point
#'               - `V`: Covariance matrix of observations
#'            2. Raw data matrix:
#'               - Rows: Individual observations (nsim)
#'               - Columns: Time points
#'
#' @returns A function with signature `function(p, givedetails = FALSE, opts_overrides)` where:
#' \itemize{
#'   \item `p`: Parameter values (transformed or untransformed)
#'   \item `givedetails`: If TRUE, returns additional attributes:
#'     - `EV`: Expected values (mean and covariance)
#'     - `obs`: Observed data
#'     - `nllfun`: Negative log-likelihood function
#'     - `opts`: Model options used
#'   \item `opts_overrides`: Optional list to override model options
#'   \item Returns: Negative log-likelihood value
#' }
#'
#' @details
#' Algorithm Steps:
#' \itemize{
#'   1. Data Preparation:
#'      - Validates input data format
#'      - Converts raw data to aggregate form if needed
#'      - Uses expected data if observations not provided
#'
#'   2. Parameter Processing:
#'      - Handles both transformed and untransformed parameters
#'      - Updates model options with current parameters
#'
#'   3. Likelihood Computation:
#'      - Generates expected values using `gen_pop_EV`
#'      - Computes covariance matrix inverse
#'      - Calculates negative log-likelihood
#'
#'   4. Error Handling:
#'      - Checks for matrix inversion problems
#'      - Validates data dimensions
#'      - Ensures proper parameter transformations
#' }
#'
#' Mathematical Details:
#' \itemize{
#'   \item Negative Log-Likelihood:
#'     \deqn{-2\log L = n\log|V| + (y - \mu)^T V^{-1} (y - \mu)}
#'     where:
#'     - n: Number of individuals
#'     - V: Model-predicted covariance matrix
#'     - y: Observed means
#'     - Î¼: Model-predicted means
#'
#'   \item Parameter Transformations:
#'     - Log transform for positive parameters
#'     - Logit transform for bounded parameters
#'     - Identity for unrestricted parameters
#' }
#'
#' @examples
#' # Create test data with a one-compartment model
#' test_data <- create_test_data()
#' opts <- test_data$opts
#' obs <- test_data$obs
#'
#' # Generate fitting function with aggregate data
#' fitfun <- genfitfunc(opts, obs)
#'
#' # Evaluate likelihood at initial parameters
#' nll <- fitfun(opts$pt)
#'
#' # Get detailed output including expected values
#' nll_detailed <- fitfun(opts$pt, givedetails = TRUE)
#'
#' @export
genfitfunc <- function(opts, obs) {
  # Validate input data format
  if (!(is.matrix(obs) && nrow(obs) == opts$nsim && ncol(obs) == opts$time) && 
      !all(names(obs) == c("E", "V"))) {
    stop("obs argument should give the data in aggregate form or as an nsim x Xi matrix!")
  }
  
  # Handle missing observations by using expected data
  if (missing(obs)) {
    message("genfitfunc message: Obs not supplied, using expected data as obs...")
    obs <- gen_pop_EV(opts)[1:2]  # Extract mean and covariance
  }
  
  # Convert raw data to aggregate form if needed
  if (is.matrix(obs)) {
    message("genfitfunc message: Converting obs from raw data to aggregate E and V...")
    obs <- meancov(obs)  # Compute mean and covariance
  }
  
  # Ensure observed mean is a vector (not matrix)
  obs$E <- c(obs$E)
  
  # Store observed data in model options
  opts$obs <- obs
  
  # Return fitting function
  function(pp, givedetails = FALSE, opts_overrides) {
    # Handle option overrides if provided
    if (!missing(opts_overrides)) opts <- opts_overrides
    
    # Use default parameters if none provided
    if (missing(pp)) pp <- opts$pt
    
    # Process parameters based on input type
    if (!is.list(pp)) {
      # Handle transformed parameters
      opts$pt <- pp  # Store transformed parameters
      opts$p <- opts$ptrans(pp)  # Back-transform to original scale
    } else {
      # Handle untransformed parameters
      opts$p <- pp  # Store original parameters
      opts$pt <- p_to_optim(pp)$values  # Transform to optimization scale
    }
    
    # Generate expected values (mean and covariance)
    EV <- gen_pop_EV(opts)
    
    # Compute inverse of covariance matrix
    invV <- tryCatch(
      solve(EV[[2]]),
      error = function(e) return(NA)
    )
    
    # Check for matrix inversion problems
    if (any(is.na(invV))) {
      stop("Problems inverting V, V=", paste(signif(EV[[2]], 5), collapse="\n"),
           "\n solve(V)=", paste(signif(invV, 5), collapse="\n"))
    }
    
    # Compute negative log-likelihood
    var_nll <- nllfun(opts$obs, EV, invV, opts$n)
    
    # Add attributes if detailed output requested
    if (givedetails) {
      attr(var_nll, "EV") <- EV  # Expected values
      attr(var_nll, "obs") <- obs  # Observed data
      attr(var_nll, "nllfun") <- function(EV) nllfun(obs, EV, n=opts$n)  # NLL function
      attr(var_nll, "opts") <- opts  # Model options
    }
    
    return(var_nll)
  }
}
