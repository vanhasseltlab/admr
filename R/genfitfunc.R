#' Generate a fitting function for optimization
#'
#' @description
#' `genfitfunc` generates a fitting function for optimization that computes the negative
#' log-likelihood of the model given the observed data and current parameter estimates.
#' The function handles both raw data and aggregate data (mean and covariance) formats.
#'
#' @param opts A list of model options generated by `genopts()`. Contains settings for the model,
#'             including:
#'             \itemize{
#'               \item `f`: Prediction function for the model
#'               \item `time`: Vector of observation times
#'               \item `p`: List of parameter values and structure
#'               \item `nsim`: Number of Monte Carlo samples
#'               \item `n`: Number of individuals
#'               \item `pt`: Parameter values on transformed scale
#'               \item `ptrans`: Parameter transformation function
#'             }
#' @param obs Observed data in one of two formats:
#'            1. Aggregate form: List with elements:
#'               - `E`: Vector of means for each time point
#'               - `V`: Covariance matrix of observations
#'            2. Raw data matrix:
#'               - Rows: Individual observations (nsim)
#'               - Columns: Time points
#'
#' @returns A function with signature `function(p, givedetails = FALSE, opts_overrides)` where:
#' \itemize{
#'   \item `p`: Parameter values (transformed or untransformed)
#'   \item `givedetails`: If TRUE, returns additional attributes:
#'     - `EV`: Expected values (mean and covariance)
#'     - `obs`: Observed data
#'     - `nllfun`: Negative log-likelihood function
#'     - `opts`: Model options used
#'   \item `opts_overrides`: Optional list to override model options
#'   \item Returns: Negative log-likelihood value
#' }
#'
#' @details
#' Algorithm Steps:
#' \itemize{
#'   1. Data Preparation:
#'      - Validates input data format
#'      - Converts raw data to aggregate form if needed
#'      - Uses expected data if observations not provided
#'
#'   2. Parameter Processing:
#'      - Handles both transformed and untransformed parameters
#'      - Updates model options with current parameters
#'
#'   3. Likelihood Computation:
#'      - Generates expected values using `gen_pop_EV`
#'      - Computes covariance matrix inverse
#'      - Calculates negative log-likelihood
#'
#'   4. Error Handling:
#'      - Checks for matrix inversion problems
#'      - Validates data dimensions
#'      - Ensures proper parameter transformations
#' }
#'
#' Mathematical Details:
#' \itemize{
#'   \item Negative Log-Likelihood:
#'     \deqn{-2\log L = n\log|V| + (y - \mu)^T V^{-1} (y - \mu)}
#'     where:
#'     - n: Number of individuals
#'     - V: Model-predicted covariance matrix
#'     - y: Observed means
#'     - Î¼: Model-predicted means
#'
#'   \item Parameter Transformations:
#'     - Log transform for positive parameters
#'     - Logit transform for bounded parameters
#'     - Identity for unrestricted parameters
#' }
#'
#' @examples
#' # Load required libraries
#' library(admr)
#' library(rxode2)
#' library(nlmixr2)
#' library(dplyr)
#' library(tidyr)
#' library(mnorm)
#'
#'
#' # Load and prepare data
#' data(examplomycin)
#' examplomycin_wide <- examplomycin %>%
#'   filter(EVID != 101) %>%
#'   dplyr::select(ID, TIME, DV) %>%
#'   pivot_wider(names_from = TIME, values_from = DV) %>%
#'   dplyr::select(-c(1))
#'
#' # Create aggregated data
#' examplomycin_aggregated <- examplomycin_wide %>%
#'   admr::meancov()
#'
#' # Define RxODE model
#' rxModel <- function(){
#' model({
#'   # Parameters
#'   ke = cl / v1             # Elimination rate constant
#'   k12 = q / v1             # Rate constant for central to peripheral transfer
#'   k21 = q / v2             # Rate constant for peripheral to central transfer
#'
#'   # Differential equations
#'   d/dt(depot)    = -ka * depot
#'   d/dt(central)  = ka * depot - ke * central - k12 * central + k21 * peripheral
#'   d/dt(peripheral) = k12 * central - k21 * peripheral
#'
#'   # Concentration in central compartment
#'   cp = central / v1
#' })
#' }
#'
#' rxModel <- rxode2(rxModel)
#' rxModel <- rxModel$simulationModel
#'
#' # Define prediction function for a two-compartment model
#' predder <- function(time, theta_i, dose = 100) {
#'   n_individuals <- nrow(theta_i)
#'   if (is.null(n_individuals)) n_individuals <- 1
#'
#'   # Create event table for dosing and sampling
#'   ev <- eventTable(amount.units="mg", time.units="hours")
#'   ev$add.dosing(dose = dose, nbr.doses = 1, start.time = 0)
#'   ev$add.sampling(time)
#'
#'   # Solve ODE system
#'   out <- rxSolve(rxModel, params = theta_i, events = ev, cores = 0)
#'
#'   # Return matrix of predictions
#'   matrix(out$cp, nrow = n_individuals, ncol = length(time), byrow = TRUE)
#' }
#'
#' # Create options for a two-compartment model
#' opts <- genopts(
#'   f = predder,
#'   time = c(.1, .25, .5, 1, 2, 3, 5, 8, 12),
#'   p = list(
#'     # Population parameters (fixed effects)
#'     beta = c(cl = 5,    # Clearance (L/h)
#'             v1 = 10,    # Central volume (L)
#'             v2 = 30,    # Peripheral volume (L)
#'             q = 10,     # Inter-compartmental clearance (L/h)
#'             ka = 1),    # Absorption rate (1/h)
#'
#'     # Between-subject variability (30% CV on all parameters)
#'     Omega = matrix(c(0.09, 0, 0, 0, 0,
#'                     0, 0.09, 0, 0, 0,
#'                     0, 0, 0.09, 0, 0,
#'                     0, 0, 0, 0.09, 0,
#'                     0, 0, 0, 0, 0.09), nrow = 5, ncol = 5),
#'
#'     # Residual error (20% CV)
#'     Sigma_prop = 0.04
#'   ),
#'   nsim = 2500,  # Number of Monte Carlo samples
#'   n = 500,      # Number of individuals
#'   fo_appr = FALSE  # Use Monte Carlo approximation
#' )
#'
#' # Generate objective function for optimization
#' objfun <- genfitfunc(opts, examplomycin_aggregated)
#'
#' # Test the objective function with initial parameters
#' init_params <- opts$p
#' nll <- objfun(init_params)
#'
#' @export
genfitfunc <- function(opts, obs) {
  # Validate input data format
  if (!(is.matrix(obs) && nrow(obs) == opts$nsim && ncol(obs) == opts$time) &&
      !all(names(obs) == c("E", "V"))) {
    stop("obs argument should give the data in aggregate form or as an nsim x Xi matrix!")
  }

  # Handle missing observations by using expected data
  if (missing(obs)) {
    message("genfitfunc message: Obs not supplied, using expected data as obs...")
    obs <- gen_pop_EV(opts)[1:2]  # Extract mean and covariance
  }

  # Convert raw data to aggregate form if needed
  if (is.matrix(obs)) {
    message("genfitfunc message: Converting obs from raw data to aggregate E and V...")
    obs <- meancov(obs)  # Compute mean and covariance
  }

  # Ensure observed mean is a vector (not matrix)
  obs$E <- c(obs$E)

  # Store observed data in model options
  opts$obs <- obs

  # Return fitting function
  function(pp, givedetails = FALSE, opts_overrides) {
    # Handle option overrides if provided
    if (!missing(opts_overrides)) opts <- opts_overrides

    # Use default parameters if none provided
    if (missing(pp)) pp <- opts$pt

    # Process parameters based on input type
    if (!is.list(pp)) {
      # Handle transformed parameters
      opts$pt <- pp  # Store transformed parameters
      opts$p <- opts$ptrans(pp)  # Back-transform to original scale
    } else {
      # Handle untransformed parameters
      opts$p <- pp  # Store original parameters
      opts$pt <- p_to_optim(pp)$values  # Transform to optimization scale
    }

    # Generate expected values (mean and covariance)
    EV <- gen_pop_EV(opts)

    # Compute negative log-likelihood
    if (opts$no_cov) {
      var_nll <- nllfun_var(obs, EV, n = opts$n)
      nllfun_used <- function(EV) nllfun_var(obs, EV, n = opts$n)
    } else {

      # Compute inverse of covariance matrix
      invV <- tryCatch(
        solve(EV[[2]]),
        error = function(e) return(NA)
      )

      # Check for matrix inversion problems
      if (any(is.na(invV))) {
        stop("Problems inverting V, V=", paste(signif(EV[[2]], 5), collapse="\n"),
             "\n solve(V)=", paste(signif(invV, 5), collapse="\n"))
      }

      var_nll <- nllfun(opts$obs, EV, invV, opts$n)
      nllfun_used <- function(EV) nllfun(obs, EV, n = opts$n)
    }

    # Add attributes if detailed output requested
    if (givedetails) {
      attr(var_nll, "EV") <- EV          # Expected values
      attr(var_nll, "obs") <- obs        # Observed data
      attr(var_nll, "nllfun") <- nllfun_used  # Correct likelihood function
      attr(var_nll, "opts") <- opts      # Model options
    }


    return(var_nll)
  }
}
