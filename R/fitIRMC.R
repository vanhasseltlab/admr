#' Fit aggregate data using Iterative Reweighting with Monte Carlo updates
#'
#' @description
#' `fitIRMC` implements the Iterative Reweighting (IRMC) algorithm for parameter estimation of
#' aggregate data models, iterating over maximum likelihood updates with weighted Monte Carlo
#' updates. This function uses nloptr instead of optimx for optimization and includes additional
#' features like multiple chains and phase-based optimization.
#'
#' @param opts A list of model options generated by `genopts()`. Contains settings for the model,
#'             including the prediction function, time points, parameter structure, and simulation
#'             settings.
#' @param obs Observed data in aggregate form (mean and covariance) or as a matrix of raw data.
#' @param maxiter Maximum number of iterations for the optimization algorithm. Default is 100.
#' @param convcrit_nll Convergence criterion for the negative log-likelihood. The algorithm stops
#'                     when the relative change in negative log-likelihood is less than this value.
#'                     Default is 1e-05.
#' @param single_dataframe Logical indicating whether to use a single data frame (TRUE) or multiple
#'                        data frames (FALSE). Default is TRUE.
#' @param phase_fractions Vector of fractions for each optimization phase. The sum should be 1.
#'                       Default is c(0.2, 0.4, 0.2, 0.2).
#' @param max_worse_iterations Maximum number of consecutive worse iterations before skipping a phase.
#'                            Default is 10.
#' @param chains Number of parallel chains to run. Default is 1.
#' @param pertubation Perturbation factor for the initial parameter values of each chain.
#'                    Default is 0.1.
#' @param seed Random seed for reproducibility. Default is 1.
#'
#' @returns An object of class `fitIRMC_result` containing:
#' \itemize{
#'   \item `p`: List of parameter estimates for each iteration
#'   \item `nll`: Negative log-likelihood values
#'   \item `time`: Computation time for each iteration
#'   \item `iter`: Iteration number
#'   \item `chain`: Chain number (if multiple chains are used)
#'   \item `phase`: Optimization phase number
#' }
#'
#' @details
#' The function uses the Iterative Reweighting algorithm with Monte Carlo sampling for optimization.
#' It includes several advanced features:
#' \itemize{
#'   \item Multiple optimization phases with different convergence criteria
#'   \item Parallel chains with perturbed starting values
#'   \item Phase-based optimization with automatic phase skipping
#'   \item Convergence checking based on both likelihood and parameter stationarity
#' }
#'
#' The optimization process is divided into phases, each with its own convergence criteria and
#' settings. The algorithm can automatically skip phases if the optimization is not progressing.
#' Multiple chains can be run in parallel to improve the chances of finding the global optimum.
#'
#' @examples
#' # Create test data
#' test_data <- create_test_data()
#' opts <- test_data$opts
#' obs <- test_data$obs
#'
#' # Run optimization with default settings
#' result <- fitIRMC(opts, obs)
#'
#' # Run optimization with multiple chains
#' result <- fitIRMC(opts, obs, chains = 3)
#'
#' # View results
#' print(result)
#' plot(result)
#'
#' @export
fitIRMC <- function(opts, obs, maxiter = 100, convcrit_nll = 1e-05,
                    single_dataframe = TRUE, phase_fractions = c(0.2, 0.4, 0.2, 0.2),
                    max_worse_iterations = 10, chains = 1, pertubation = 0.1, seed = 1) {

  set.seed(seed)
  nomap <- single_dataframe

  if (nomap){
    init <- opts$pt
  } else{
    init <- opts[[1]]$pt
  }

  # Ensure phase_fractions sum to 1
  if (abs(sum(phase_fractions) - 1) > .Machine$double.eps^0.5) {
    stop("The sum of phase_fractions must be 1.")
  }

  start_time <- Sys.time()  # Start time for the entire process
  chain_results <- vector("list", chains)  # Store results for each chain

  for (chain in seq_len(chains)) {
    chain_results[[chain]] <- run_chain(
      chain = chain,
      opts = opts,
      obs = obs,
      init = init,
      maxiter = maxiter,
      phase_fractions = phase_fractions,
      convcrit_nll = convcrit_nll,
      max_worse_iterations = max_worse_iterations,
      pertubation = pertubation,
      nomap = nomap
    )
  }

  # Select the best chain based on NLL
  best_chain <- which.min(sapply(chain_results, function(x) x$best_nll))
  final_result <- chain_results[[best_chain]]
  final_params <- final_result$best_params
  final_nll <- final_result$best_nll
  final_res <- final_result$res  # Final iteration history

  # Covariance computation
  cov_start_time <- Sys.time()
  func_fixed <- function(beta) {
    p_full <- final_params
    p_full[1:length(beta)] <- beta
    opts_list <- if (nomap) list(opts) else opts
    obs_list <- if (nomap) list(obs) else obs
    sum(sapply(seq_along(opts_list), function(i) genfitfunc(opts_list[[i]], obs_list[[i]])(p_full)))
  }

  cov_matrix_fixed <- tryCatch(
    solve(numDeriv::hessian(func_fixed, final_params[1:length(if (nomap) opts$p$beta else opts[[2]]$p$beta)],
                            method = "Richardson", method.args = list(r=6, v=2))),
    error = function(e) NA
  )

  cov_time <- as.numeric(difftime(Sys.time(), cov_start_time, units = "secs"))

  tryCatch(
    se_fixed <- if (is.matrix(cov_matrix_fixed)) {
      sqrt(diag(cov_matrix_fixed))
    } else {
      rep(NA, length(if (nomap) opts$p$beta else opts[[1]]$p$beta))
    }, error = function(e) NULL)

  back_transformed_params <- tryCatch(
    if (nomap) opts$ptrans(final_params) else opts[[1]]$ptrans(final_params),
    error = function(e) NA
  )

  bic <- if (nomap) {
    -2 * final_nll + log(opts$n) * length(final_params)
  } else {
    -2 * final_nll + (log(opts[[1]]$n) + log(opts[[2]]$n)) * length(final_params)
  }

  param_names <- names(back_transformed_params$beta)
  beta_params <- final_params[1:length(se_fixed)]
  beta_se <- se_fixed
  residual_error <- exp(final_params[length(final_params)])

  # Transformations and confidence intervals
  beta_estimates_original <- back_transformed_params$beta[1:length(beta_params)]
  confint_low_original <- exp(beta_params - 1.96 * beta_se)
  confint_high_original <- exp(beta_params + 1.96 * beta_se)

  # Generate output
  output <- list(
    final_params = final_params,
    transformed_params = back_transformed_params,
    param_df = tibble(
      Parameter = c(param_names, "Residual Error"),
      `Est.` = c(beta_params, residual_error),
      `SE` = c(beta_se, NA),
      `%RSE` = c(100 * beta_se / abs(beta_params), NA),
      `Back-transformed(95%CI)` = c(
        paste0(
          sprintf("%.2f", beta_estimates_original), " (",
          sprintf("%.2f", confint_low_original), ", ",
          sprintf("%.2f", confint_high_original), ")"
        ),
        sprintf("%.4f", residual_error)
      ),
      `BSV(CV%)` = c(calculate_bsv(back_transformed_params), NA) # Use the adjusted function here
    ),
    covariance_matrix = cov_matrix_fixed,
    convergence_info = list(
      converged = nrow(final_res) < maxiter,
      total_iterations = nrow(final_res),
      final_nll = final_nll,
      total_time = as.numeric(difftime(Sys.time(), start_time, units = "secs")),
      chain_time = final_result$time,
      covariance_time = cov_time,
      aic = -2 * final_nll + length(final_params),
      bic = bic
    ),
    diagnostics = list(
      best_chain = best_chain,
      nll_trace = final_res$nll,
      approx_nll_trace = final_res$approx_nll,
      iteration_times = final_res$iteration_time,
      time_per_iteration_summary = summary(final_res$iteration_time, na.rm = TRUE)
    ),
    chain_results = chain_results,  # Save results of all chains
    iteration_history = final_res,
    data = list(
      opts = opts,
      obs = obs
    )
  )

  class(output) <- "fitIRMC_result"
  return(output)
}

#' Print fitIRMC results
#'
#' @param x A fitted model object returned by fitIRMC
#' @param ... Additional arguments (not used)
#' @export
#'
print.fitIRMC_result <- function(x, ...) {
  cat("-- FitIRMC Summary --\n\n")

  # Objective function and information criteria
  cat("-- Objective Function and Information Criteria --\n")
  conv <- x$convergence_info
  cat(sprintf(" Log-likelihood: %.4f\n", conv$final_nll))
  cat(sprintf("            AIC: %.2f\n", conv$aic))
  cat(sprintf("            BIC: %.2f\n", conv$bic))

  if (!is.null(x$covariance_matrix)) {
    cat(sprintf("Condition#(Cov): %.2f\n", kappa(x$covariance_matrix)))
    cat(sprintf("Condition#(Cor): %.2f\n", kappa(cov2cor(x$covariance_matrix))))
  }
  cat("\n")

  # Timing information
  cat("-- Timing Information --\n")
  diag <- x$diagnostics
  cat(sprintf("     Best Chain: %.4f seconds\n", conv$chain_time))
  cat(sprintf("     All Chains: %.4f seconds\n", conv$total_time - conv$covariance_time))
  cat(sprintf("     Covariance: %.4f seconds\n", conv$covariance_time))
  cat(sprintf("        Elapsed: %.2f seconds\n", conv$total_time))
  cat("\n")

  # Population parameters and residual error
  cat("-- Population Parameters --\n")

  # Create the parameter table
  print(x$param_df)
  cat("\n")

  # Iteration diagnostics (head and tail)
  cat("-- Iteration Diagnostics --\n")
  iter_info <- x$iteration_history
  n_total <- nrow(iter_info)

  # Automatically show head and tail of iterations
  if (n_total > 10) {
    head_iters <- seq_len(5)
    tail_iters <- seq(n_total - 4, n_total)
  } else {
    head_iters <- seq_len(n_total)
    tail_iters <- integer(0)  # Empty if no tail is needed
  }

  cat(sprintf(" Iter | %-12s\n", "NLL and Parameters"))
  cat(sprintf("%s\n", strrep("-", 80)))

  # Print head iterations
  for (i in head_iters) {
    nll <- iter_info$nll[i]
    params <- iter_info$parameters[[i]]
    if (is.null(params)) next  # Skip if parameters are missing
    cat(sprintf("%4d: %s\n", i, paste(sprintf("%.3f", c(nll, params)), collapse = " ")))
  }

  # Add transition if both head and tail are shown
  if (length(tail_iters) > 0 && max(head_iters) < min(tail_iters) - 1) {
    cat("   ... (omitted iterations) ...\n")
  }

  # Print tail iterations
  for (i in tail_iters) {
    nll <- iter_info$nll[i]
    params <- iter_info$parameters[[i]]
    if (is.null(params)) next  # Skip if parameters are missing
    cat(sprintf("%4d: %s\n", i, paste(sprintf("%.3f", c(nll, params)), collapse = " ")))
  }

  cat("\n")
}



#' Plot diagnostics of fitIRMC results
#'
#' @param x A fitted model object returned by fitIRMC
#' @param ... Additional arguments (not used)
#' @export
#'

plot.fitIRMC_result <- function(x, ...) {
  if (!inherits(x, "fitIRMC_result")) {
    stop("The input must be a fitIRMC_result object.")
  }

  chain_results <- x$chain_results

  # Prepare data for NLL trace
  nll_data <- do.call(rbind, lapply(seq_along(chain_results), function(chain) {
    data.frame(
      Iteration = seq_len(nrow(chain_results[[chain]]$res)),
      NLL = chain_results[[chain]]$res$nll,
      Chain = factor(chain)
    )
  }))

  # Extract parameter names from the first iteration of the first chain
  param_names <- names(chain_results[[1]]$res$parameters[[1]])

  # Prepare data for parameter convergence
  param_data <- do.call(rbind, lapply(seq_along(chain_results), function(chain) {
    do.call(rbind, lapply(seq_len(nrow(chain_results[[chain]]$res)), function(i) {
      param_iter <- chain_results[[chain]]$res$parameters[[i]]

      if (is.null(param_iter) || length(param_iter) == 0) {
        # Handle missing or empty parameters for this iteration
        data.frame(
          Iteration = i,
          Parameter = param_names,  # Use names from the first iteration of the first chain
          Value = NA,  # No values for missing parameters
          Chain = factor(chain),
          stringsAsFactors = FALSE
        )
      } else {
        # Align parameter values with the reference names
        values <- unlist(param_iter)
        if (length(values) != length(param_names)) {
          stop("Parameter values do not match the length of reference names.")
        }
        data.frame(
          Iteration = i,
          Parameter = param_names,
          Value = values,
          Chain = factor(chain),
          stringsAsFactors = FALSE
        )
      }
    }))
  }))

  # Reset row names to avoid mismatched indexing
  row.names(param_data) <- NULL

  # Plot 1: NLL Convergence Trace
  p1 <- ggplot(nll_data, aes(x = .data$Iteration, y = .data$NLL, color = .data$Chain, group = .data$Chain)) +
    geom_line() +
    geom_point() +
    geom_hline(yintercept = min(nll_data$NLL, na.rm = TRUE), linetype = "dashed", color = "red") +
    labs(title = "NLL Convergence Trace", x = "Iteration", y = "Negative Log-Likelihood") +
    theme_minimal() +
    scale_color_viridis_d() +
    theme(plot.title = element_text(hjust = 0.5))

  # Plot 2: Parameter Convergence
  p2 <- ggplot(param_data, aes(x = .data$Iteration, y = .data$Value, color = .data$Chain, group = interaction(.data$Chain, .data$Parameter))) +
    geom_line() +
    geom_point() +
    facet_wrap(~Parameter, scales = "free_y") +
    labs(
      title = "Parameter Convergence by Chain",
      x = "Iteration",
      y = "Parameter Value"
    ) +
    theme_minimal() +
    scale_color_viridis_d() +
    theme(plot.title = element_text(hjust = 0.5))

  # Plot 3: Sensitivity Convergence

  # Print the plots
  print(p1)
  print(p2)
}
