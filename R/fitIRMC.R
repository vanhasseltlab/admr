#' Fit aggregate data using Iterative Reweighting with Monte Carlo updates
#'
#' @description
#' `fitIRMC` implements the Iterative Reweighting (IRMC) algorithm for parameter estimation of
#' aggregate data models, iterating over maximum likelihood updates with weighted Monte Carlo
#' updates. This function uses nloptr instead of optimx for optimization and includes additional
#' features like multiple chains and phase-based optimization.
#'
#' @param opts A list of model options generated by `genopts()`. Contains settings for the model,
#'             including the prediction function, time points, parameter structure, and simulation
#'             settings.
#' @param obs Observed data in aggregate form (mean and covariance) or as a matrix of raw data.
#' @param maxiter Maximum number of iterations for the optimization algorithm. Default is 100.
#' @param convcrit_nll Convergence criterion for the negative log-likelihood. The algorithm stops
#'                     when the relative change in negative log-likelihood is less than this value.
#'                     Default is 1e-05.
#' @param single_dataframe Logical indicating whether to use a single data frame (TRUE) or multiple
#'                        data frames (FALSE). Default is TRUE.
#' @param phase_fractions Vector of fractions for each optimization phase. The sum should be 1.
#'                       Default is c(0.2, 0.4, 0.2, 0.2).
#' @param max_worse_iterations Maximum number of consecutive worse iterations before skipping a phase.
#'                            Default is 10.
#' @param chains Number of parallel chains to run. Default is 1.
#' @param pertubation Perturbation factor for the initial parameter values of each chain.
#'                    Default is 0.1.
#' @param seed Random seed for reproducibility. Default is 1.
#'
#' @returns An object of class `fitIRMC_result` containing:
#' \itemize{
#'   \item `p`: List of parameter estimates for each iteration
#'   \item `nll`: Negative log-likelihood values
#'   \item `time`: Computation time for each iteration
#'   \item `iter`: Iteration number
#'   \item `chain`: Chain number (if multiple chains are used)
#'   \item `phase`: Optimization phase number
#' }
#'
#' @details
#' The function uses the Iterative Reweighting algorithm with Monte Carlo sampling for optimization.
#' It includes several advanced features:
#' \itemize{
#'   \item Multiple optimization phases with different convergence criteria
#'   \item Chains with perturbed starting values
#'   \item Phase-based optimization with automatic phase skipping
#'   \item Convergence checking based on both likelihood and parameter stationarity
#' }
#'
#' The optimization process is divided into phases, each with its own convergence criteria and
#' settings. The algorithm can automatically skip phases if the optimization is not progressing.
#'
#' @examples
#' # Load required libraries
#' library(admr)
#' library(rxode2)
#' library(nlmixr2)
#' library(dplyr)
#' library(tidyr)
#' library(mnorm)
#'
#' # Load and prepare data
#' data(examplomycin)
#' examplomycin_wide <- examplomycin %>%
#'   filter(EVID != 101) %>%
#'   dplyr::select(ID, TIME, DV) %>%
#'   pivot_wider(names_from = TIME, values_from = DV) %>%
#'   dplyr::select(-c(1))
#'
#' # Create aggregated data
#' examplomycin_aggregated <- examplomycin_wide %>%
#'   admr::meancov()
#'
#' # Define RxODE model
#' rxModel <- RxODE({
#'   cp = linCmt(
#'     cl,           # Clearance
#'     v1,           # Volume of the central compartment
#'     v2,           # Volume of the peripheral compartment
#'     q,            # Inter-compartmental clearance
#'     ka            # Absorption rate constant
#'   )
#' })
#'
#' # Define prediction function
#' predder <- function(time, theta_i, dose = 100) {
#'   n_individuals <- nrow(theta_i)
#'   if (is.null(n_individuals)) n_individuals <- 1
#'
#'   ev <- eventTable(amount.units="mg", time.units="hours")
#'   ev$add.dosing(dose = dose, nbr.doses = 1, start.time = 0)
#'   ev$add.sampling(time)
#'
#'   out <- rxSolve(rxModel, params = theta_i, events = ev, cores = 0)
#'   cp_matrix <- matrix(out$cp, nrow = n_individuals, ncol = length(time),
#'                       byrow = TRUE)
#'   return(cp_matrix)
#' }
#'
#' # Create options
#' opts <- genopts(
#'   time = c(.1, .25, .5, 1, 2, 3, 5, 8, 12),
#'   p = list(
#'     beta = c(cl = 5, v1 = 10, v2 = 30, q = 10, ka = 1),
#'     Omega = matrix(c(0.09, 0, 0, 0, 0,
#'                      0, 0.09, 0, 0, 0,
#'                      0, 0, 0.09, 0, 0,
#'                      0, 0, 0, 0.09, 0,
#'                      0, 0, 0, 0, 0.09), nrow = 5, ncol = 5),
#'     Sigma_prop = 0.04
#'   ),
#'   nsim = 2500,
#'   n = 500,
#'   fo_appr = FALSE,
#'   omega_expansion = 1.2,
#'   f = predder
#' )
#'
#' # Run optimization
#' result <- fitIRMC(opts, examplomycin_aggregated)
#' print(result)
#'
#' @export
fitIRMC <- function(opts, obs, maxiter = 100, convcrit_nll = 1e-05,
                    single_dataframe = TRUE, phase_fractions = c(0.2, 0.4, 0.2, 0.2),
                    max_worse_iterations = 10, chains = 1, pertubation = 0.1, seed = 1) {

  # Set random seed for reproducibility
  set.seed(seed)
  nomap <- single_dataframe

  # Get initial parameter values
  if (nomap){
    init <- opts$pt
  } else{
    init <- opts[[1]]$pt
  }

  # Validate phase fractions
  if (abs(sum(phase_fractions) - 1) > .Machine$double.eps^0.5) {
    stop("The sum of phase_fractions must be 1.")
  }

  # Initialize timing and results storage
  start_time <- Sys.time()  # Start time for the entire process
  chain_results <- vector("list", chains)  # Store results for each chain

  # Run optimization chains
  for (chain in seq_len(chains)) {
    chain_results[[chain]] <- run_chain(
      chain = chain,
      opts = opts,
      obs = obs,
      init = init,
      maxiter = maxiter,
      phase_fractions = phase_fractions,
      convcrit_nll = convcrit_nll,
      max_worse_iterations = max_worse_iterations,
      pertubation = pertubation,
      nomap = nomap
    )
  }

  # Select best chain based on negative log-likelihood
  best_chain <- which.min(sapply(chain_results, function(x) x$best_nll))
  final_result <- chain_results[[best_chain]]
  final_params <- final_result$best_params
  final_nll <- final_result$best_nll
  final_res <- final_result$res  # Final iteration history

  # Compute covariance matrix for fixed effects
  cov_start_time <- Sys.time()
  func_fixed <- function(beta) {
    p_full <- final_params
    p_full[1:length(beta)] <- beta
    opts_list <- if (nomap) list(opts) else opts
    obs_list <- if (nomap) list(obs) else obs
    sum(sapply(seq_along(opts_list), function(i) genfitfunc(opts_list[[i]], obs_list[[i]])(p_full)))
  }

  # Compute Hessian matrix using Richardson method
  cov_matrix_fixed <- tryCatch(
    solve(numDeriv::hessian(func_fixed, final_params[1:length(if (nomap) opts$p$beta else opts[[2]]$p$beta)],
                            method = "Richardson", method.args = list(r=6, v=2))),
    error = function(e) NA
  )

  cov_time <- as.numeric(difftime(Sys.time(), cov_start_time, units = "secs"))

  # Compute standard errors for fixed effects
  tryCatch(
    se_fixed <- if (is.matrix(cov_matrix_fixed)) {
      sqrt(diag(cov_matrix_fixed))
    } else {
      rep(NA, length(if (nomap) opts$p$beta else opts[[1]]$p$beta))
    }, error = function(e) NULL)

  # Back-transform parameters to original scale
  back_transformed_params <- tryCatch(
    if (nomap) opts$ptrans(final_params) else opts[[1]]$ptrans(final_params),
    error = function(e) NA
  )

  # Compute BIC for model selection
  bic <- if (nomap) {
    -2 * final_nll + log(opts$n) * length(final_params)
  } else {
    -2 * final_nll + (log(opts[[1]]$n) + log(opts[[2]]$n)) * length(final_params)
  }

  # Extract parameter names and values
  param_names <- names(back_transformed_params$beta)
  beta_params <- final_params[1:length(se_fixed)]
  beta_se <- se_fixed
  residual_error <- exp(final_params[length(final_params)])

  # Compute confidence intervals for back-transformed parameters
  beta_estimates_original <- back_transformed_params$beta[1:length(beta_params)]
  confint_low_original <- exp(beta_params - 1.96 * beta_se)
  confint_high_original <- exp(beta_params + 1.96 * beta_se)

  # Generate comprehensive output object
  output <- list(
    final_params = final_params,
    transformed_params = back_transformed_params,
    param_df = tibble(
      Parameter = c(param_names, "Residual Error"),
      `Est.` = c(beta_params, residual_error),
      `SE` = c(beta_se, NA),
      `%RSE` = c(100 * beta_se / abs(beta_params), NA),
      `Back-transformed(95%CI)` = c(
        paste0(
          sprintf("%.2f", beta_estimates_original), " (",
          sprintf("%.2f", confint_low_original), ", ",
          sprintf("%.2f", confint_high_original), ")"
        ),
        sprintf("%.4f", residual_error)
      ),
      `BSV(CV%)` = c(calculate_bsv(back_transformed_params), NA)
    ),
    covariance_matrix = cov_matrix_fixed,
    convergence_info = list(
      converged = nrow(final_res) < maxiter,
      total_iterations = nrow(final_res),
      final_nll = final_nll,
      total_time = as.numeric(difftime(Sys.time(), start_time, units = "secs")),
      chain_time = final_result$time,
      covariance_time = cov_time,
      aic = -2 * final_nll + length(final_params),
      bic = bic
    ),
    diagnostics = list(
      best_chain = best_chain,
      nll_trace = final_res$nll,
      approx_nll_trace = final_res$approx_nll,
      iteration_times = final_res$iteration_time,
      time_per_iteration_summary = summary(final_res$iteration_time, na.rm = TRUE)
    ),
    chain_results = chain_results,  # Save results of all chains
    iteration_history = final_res,
    data = list(
      opts = opts,
      obs = obs
    ),
    settings = list(
      maxiter = maxiter,
      convcrit_nll = convcrit_nll,
      single_dataframe = single_dataframe,
      phase_fractions = phase_fractions,
      max_worse_iterations = max_worse_iterations,
      chains = chains,
      pertubation = pertubation,
      seed = seed
    )
  )

  # Set class and return results
  class(output) <- "fitIRMC_result"
  output
}

#' Print fitIRMC results
#'
#' @param x A fitted model object returned by fitIRMC
#' @param ... Additional arguments (not used)
#' @export
#'
print.fitIRMC_result <- function(x, ...) {
  cat("-- FitIRMC Summary --\n\n")

  # Objective function and information criteria
  cat("-- Objective Function and Information Criteria --\n")
  conv <- x$convergence_info
  cat(sprintf(" Log-likelihood: %.4f\n", conv$final_nll))
  cat(sprintf("            AIC: %.2f\n", conv$aic))
  cat(sprintf("            BIC: %.2f\n", conv$bic))

  if (!is.null(x$covariance_matrix)) {
    cat(sprintf("Condition#(Cov): %.2f\n", kappa(x$covariance_matrix)))
    cat(sprintf("Condition#(Cor): %.2f\n", kappa(cov2cor(x$covariance_matrix))))
  }
  cat("\n")

  # Timing information
  cat("-- Timing Information --\n")
  diag <- x$diagnostics
  cat(sprintf("     Best Chain: %.4f seconds\n", conv$chain_time))
  cat(sprintf("     All Chains: %.4f seconds\n", conv$total_time - conv$covariance_time))
  cat(sprintf("     Covariance: %.4f seconds\n", conv$covariance_time))
  cat(sprintf("        Elapsed: %.2f seconds\n", conv$total_time))
  cat("\n")

  # Population parameters and residual error
  cat("-- Population Parameters --\n")

  # Create the parameter table
  print(x$param_df)
  cat("\n")

  # Iteration diagnostics (head and tail)
  cat("-- Iteration Diagnostics --\n")
  iter_info <- x$iteration_history
  n_total <- nrow(iter_info)

  # Automatically show head and tail of iterations
  if (n_total > 10) {
    head_iters <- seq_len(5)
    tail_iters <- seq(n_total - 4, n_total)
  } else {
    head_iters <- seq_len(n_total)
    tail_iters <- integer(0)  # Empty if no tail is needed
  }

  cat(sprintf(" Iter | %-12s\n", "NLL and Parameters"))
  cat(sprintf("%s\n", strrep("-", 80)))

  # Print head iterations
  for (i in head_iters) {
    nll <- iter_info$nll[i]
    params <- iter_info$parameters[[i]]
    if (is.null(params)) next  # Skip if parameters are missing
    cat(sprintf("%4d: %s\n", i, paste(sprintf("%.3f", c(nll, params)), collapse = " ")))
  }

  # Add transition if both head and tail are shown
  if (length(tail_iters) > 0 && max(head_iters) < min(tail_iters) - 1) {
    cat("   ... (omitted iterations) ...\n")
  }

  # Print tail iterations
  for (i in tail_iters) {
    nll <- iter_info$nll[i]
    params <- iter_info$parameters[[i]]
    if (is.null(params)) next  # Skip if parameters are missing
    cat(sprintf("%4d: %s\n", i, paste(sprintf("%.3f", c(nll, params)), collapse = " ")))
  }

  cat("\n")
}



#' Plot diagnostics of fitIRMC results
#'
#' @param x A fitted model object returned by fitIRMC
#' @param ... Additional arguments (not used)
#' @export
#'

plot.fitIRMC_result <- function(x, ...) {
  if (!inherits(x, "fitIRMC_result")) {
    stop("The input must be a fitIRMC_result object.")
  }

  chain_results <- x$chain_results
  nomap <- x$settings$single_dataframe
  opts <- x$data$opts

  # Prepare data for NLL trace
  nll_data <- do.call(rbind, lapply(seq_along(chain_results), function(chain) {
    data.frame(
      Iteration = seq_len(nrow(chain_results[[chain]]$res)),
      NLL = chain_results[[chain]]$res$nll,
      Chain = factor(chain)
    )
  }))

  # Extract parameter names from the first iteration of the first chain
  param_names <- names(chain_results[[1]]$res$parameters[[1]])

  # Prepare data for parameter convergence
  param_data <- do.call(rbind, lapply(seq_along(chain_results), function(chain) {
    do.call(rbind, lapply(seq_len(nrow(chain_results[[chain]]$res)), function(i) {
      param_iter <- chain_results[[chain]]$res$parameters[[i]]

      if (is.null(param_iter) || length(param_iter) == 0) {
        # Handle missing or empty parameters for this iteration
        data.frame(
          Iteration = i,
          Parameter = param_names,  # Use names from the first iteration of the first chain
          Value = NA,  # No values for missing parameters
          Chain = factor(chain),
          stringsAsFactors = FALSE
        )
      } else {
        # Align parameter values with the reference names
        values <- unlist(param_iter)
        if (length(values) != length(param_names)) {
          stop("Parameter values do not match the length of reference names.")
        }
        data.frame(
          Iteration = i,
          Parameter = param_names,
          Value = values,
          Chain = factor(chain),
          stringsAsFactors = FALSE
        )
      }
    }))
  }))


  # Reset row names to avoid mismatched indexing
  row.names(param_data) <- NULL

  # Plot 1: NLL Convergence Trace
  p1 <- ggplot(nll_data, aes(x = .data$Iteration, y = .data$NLL, color = .data$Chain, group = .data$Chain)) +
    geom_line() +
    geom_point() +
    geom_hline(yintercept = min(nll_data$NLL, na.rm = TRUE), linetype = "dashed", color = "red") +
    labs(title = "NLL Convergence Trace", x = "Iteration", y = "Negative Log-Likelihood") +
    theme_minimal() +
    scale_color_viridis_d() +
    theme(plot.title = element_text(hjust = 0.5))
  print(p1)

  # Plot 2: Parameter Convergence
  p2 <- ggplot(param_data, aes(x = .data$Iteration, y = .data$Value, color = .data$Chain, group = interaction(.data$Chain, .data$Parameter))) +
    geom_line() +
    geom_point() +
    facet_wrap(~Parameter, scales = "free_y") +
    labs(
      title = "Parameter Convergence by Chain",
      x = "Iteration",
      y = "Parameter Value"
    ) +
    theme_minimal() +
    scale_color_viridis_d() +
    theme(plot.title = element_text(hjust = 0.5))
  print(p2)

  if (nomap == T) {
    # Extract observations from the fitIRMC result
    time_points <- x$data$opts$time
    observations <- x$data$obs
    predictions <- MCapprEV(upd_opts(x$data$opts, list(p = x$transformed_params)))

    # Create plot-ready boxplot data for observations and predictions
    obs_boxplot <- prepare_boxplot_df(observations$E, observations$V, time_points)
    pred_boxplot <- prepare_boxplot_df(predictions$E, predictions$V, time_points)
    obs_boxplot$source <- "Observed"
    pred_boxplot$source <- "Predicted"
    combined_boxplot <- rbind(obs_boxplot, pred_boxplot)

    # Prepare data frames for E and V heatmaps
    obs_E_df <- prepare_E_df(observations$E, "Observed", time_points)
    pred_E_df <- prepare_E_df(predictions$E, "Predicted", time_points)
    obs_V_df <- prepare_V_df(observations$V, "Observed", time_points)
    pred_V_df <- prepare_V_df(predictions$V, "Predicted", time_points)


    # Plot 3: Combined Boxplot with Mean and Variance Bands
    p3 <- ggplot(combined_boxplot, aes(x = time)) +
      # 95% interval ribbons
      geom_ribbon(
        aes(ymin = lower_95, ymax = upper_95, fill = source),
        alpha = 0.2,
        show.legend = FALSE
      ) +
      # IQR ribbons
      geom_ribbon(
        aes(ymin = lower_q1, ymax = upper_q3, fill = source),
        alpha = 0.35
      ) +
      # Mean lines
      geom_line(
        aes(y = mean, color = source, linetype = source),
        linewidth = 1
      ) +
      scale_fill_manual(values = c("Observed" = "#3B8AC4", "Predicted" = "#D1495B")) +
      scale_color_manual(values = c("Observed" = "#3B8AC4", "Predicted" = "#D1495B")) +
      scale_linetype_manual(values = c("Observed" = "solid", "Predicted" = "dashed")) +
      labs(
        title = "Observed vs Predicted: Mean and Variance Bands",
        x = "Time (h)",
        y = "Concentration",
        fill = "",
        color = "",
        linetype = ""
      ) +
      theme_minimal(base_size = 14) +
      theme(
        plot.title = element_text(face = "bold", size = 16),
        plot.subtitle = element_text(size = 13, margin = margin(b = 10)),
        legend.position = "top",
        legend.title = element_blank(),
        legend.text = element_text(size = 13)
      )


    p_E <- ggplot(rbind(obs_E_df, pred_E_df), aes(x = time, y = 1, fill = mean)) +
      geom_tile() +
      facet_wrap(~source, ncol = 1) +
      scale_fill_gradient2(
        low = "blue", mid = "white", high = "red", midpoint = median(c(obs_E_df$mean, pred_E_df$mean))
      ) +
      labs(title = "Mean Vector (E)", x = "Time", y = "", fill = "Mean Value") +
      theme_minimal() +
      theme(axis.text.y = element_blank(), axis.ticks.y = element_blank())


    combined_V_df <- rbind(obs_V_df, pred_V_df)
    combined_V_df$time1 <- factor(combined_V_df$time1, levels = sort(unique(combined_V_df$time1)))
    combined_V_df$time2 <- factor(combined_V_df$time2, levels = sort(unique(combined_V_df$time2)))

    p_V <- ggplot(combined_V_df, aes(x = time1, y = time2, fill = value)) +
      geom_tile(color = NA) +  # remove borders between tiles
      facet_wrap(~source, ncol = 2) +
      scale_fill_gradient2(
        low = "blue", mid = "white", high = "red", midpoint = 0
      ) +
      labs(
        title = "Variance-Covariance Matrix (V)",
        x = "Time 1", y = "Time 2", fill = "Value"
      ) +
      coord_fixed() +
      theme_minimal() +
      theme(
        panel.grid = element_blank(),
        axis.text.x = element_text(angle = 45, hjust = 1),
        axis.ticks = element_blank()
      )

    print(p3)
    print(p_E)
    print(p_V)

  } else {
    for (i in 1:length(opts)){
      # Extract observations from the fitIRMC result
      time_points <- x$data$opts[[i]]$time
      observations <- x$data$obs[[i]]
      predictions <- MCapprEV(upd_opts(x$data$opts[[i]], list(p = x$transformed_params)))

      # Create plot-ready boxplot data for observations and predictions
      obs_boxplot <- prepare_boxplot_df(observations$E, observations$V, time_points)
      pred_boxplot <- prepare_boxplot_df(predictions$E, predictions$V, time_points)
      obs_boxplot$source <- "Observed"
      pred_boxplot$source <- "Predicted"
      combined_boxplot <- rbind(obs_boxplot, pred_boxplot)

      # Prepare data frames for E and V heatmaps
      obs_E_df <- prepare_E_df(observations$E, "Observed", time_points)
      pred_E_df <- prepare_E_df(predictions$E, "Predicted", time_points)
      obs_V_df <- prepare_V_df(observations$V, "Observed", time_points)
      pred_V_df <- prepare_V_df(predictions$V, "Predicted", time_points)


      res_E_df <- obs_E_df
      res_E_df$mean <- obs_E_df$mean - pred_E_df$mean
      res_E_df$source <- "Residual"

      std_res_E_df <- obs_E_df
      std_res_E_df$mean <- (obs_E_df$mean - pred_E_df$mean) / sqrt(pred_E_df$mean)
      std_res_E_df$source <- "Standardized Residual"

      combined_E_df <- rbind(obs_E_df, pred_E_df, res_E_df, std_res_E_df)


      res_V_df <- obs_V_df
      res_V_df$value <- obs_V_df$value - pred_V_df$value
      res_V_df$source <- "Residual"

      std_res_V_df <- pred_V_df
      std_res_V_df$value <- (obs_V_df$value - pred_V_df$value) / sqrt(abs(pred_V_df$value))
      std_res_V_df$source <- "Standardized Residual"

      combined_V_df <- rbind(obs_V_df, pred_V_df, res_V_df, std_res_V_df)


      # Plot 3: Combined Boxplot with Mean and Variance Bands
      p3 <- ggplot(combined_boxplot, aes(x = time)) +
        # 95% interval ribbons
        geom_ribbon(
          aes(ymin = lower_95, ymax = upper_95, fill = source),
          alpha = 0.2,
          show.legend = FALSE
        ) +
        # IQR ribbons
        geom_ribbon(
          aes(ymin = lower_q1, ymax = upper_q3, fill = source),
          alpha = 0.35
        ) +
        # Mean lines
        geom_line(
          aes(y = mean, color = source, linetype = source),
          linewidth = 1
        ) +
        scale_fill_manual(values = c("Observed" = "#3B8AC4", "Predicted" = "#D1495B")) +
        scale_color_manual(values = c("Observed" = "#3B8AC4", "Predicted" = "#D1495B")) +
        scale_linetype_manual(values = c("Observed" = "solid", "Predicted" = "dashed")) +
        labs(
          title = paste("Observed vs Predicted: Mean and Variance Bands (Dataframe", i, ")"),
          x = "Time (h)",
          y = "Concentration",
          fill = "",
          color = "",
          linetype = ""
        ) +
        theme_minimal(base_size = 14) +
        theme(
          plot.title = element_text(face = "bold", size = 16),
          plot.subtitle = element_text(size = 13, margin = margin(b = 10)),
          legend.position = "top",
          legend.title = element_blank(),
          legend.text = element_text(size = 13)
        )
      print(p3)

      p_E <- ggplot(combined_E_df, aes(x = time, y = 1, fill = mean)) +
        geom_tile() +
        facet_wrap(~source, ncol = 1) +
        scale_fill_gradient2(
          low = "blue", mid = "white", high = "red",
          midpoint = median(combined_E_df$mean, na.rm = TRUE)
        ) +
        labs(title = "Mean Vector (E)", x = "Time", y = "", fill = "Value") +
        theme_minimal() +
        theme(axis.text.y = element_blank(), axis.ticks.y = element_blank())

      print(p_E)

      combined_V_df$time1 <- factor(combined_V_df$time1, levels = sort(unique(combined_V_df$time1)))
      combined_V_df$time2 <- factor(combined_V_df$time2, levels = sort(unique(combined_V_df$time2)))

      p_V <- ggplot(combined_V_df, aes(x = time1, y = time2, fill = value)) +
        geom_tile(color = NA) +
        facet_wrap(~source, ncol = 2) +
        scale_fill_gradient2(low = "blue", mid = "white", high = "red", midpoint = 0) +
        labs(
          title = "Variance-Covariance Matrix (V)",
          x = "Time 1", y = "Time 2", fill = "Value"
        ) +
        coord_fixed() +
        theme_minimal() +
        theme(
          panel.grid = element_blank(),
          axis.text.x = element_text(angle = 45, hjust = 1),
          axis.ticks = element_blank()
        )

      print(p_V)
    }
  }
}
