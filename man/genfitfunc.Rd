% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/genfitfunc.R
\name{genfitfunc}
\alias{genfitfunc}
\title{Generate a fitting function for optimization}
\usage{
genfitfunc(opts, obs)
}
\arguments{
\item{opts}{A list of model options generated by \code{genopts()}. Contains settings for the model,
including:
\itemize{
\item \code{f}: Prediction function for the model
\item \code{time}: Vector of observation times
\item \code{p}: List of parameter values and structure
\item \code{nsim}: Number of Monte Carlo samples
\item \code{n}: Number of individuals
\item \code{pt}: Parameter values on transformed scale
\item \code{ptrans}: Parameter transformation function
}}

\item{obs}{Observed data in one of two formats:
1. Aggregate form: List with elements:
- \code{E}: Vector of means for each time point
- \code{V}: Covariance matrix of observations
2. Raw data matrix:
- Rows: Individual observations (nsim)
- Columns: Time points}
}
\value{
A function with signature \verb{function(p, givedetails = FALSE, opts_overrides)} where:
\itemize{
\item \code{p}: Parameter values (transformed or untransformed)
\item \code{givedetails}: If TRUE, returns additional attributes:
- \code{EV}: Expected values (mean and covariance)
- \code{obs}: Observed data
- \code{nllfun}: Negative log-likelihood function
- \code{opts}: Model options used
\item \code{opts_overrides}: Optional list to override model options
\item Returns: Negative log-likelihood value
}
}
\description{
\code{genfitfunc} generates a fitting function for optimization that computes the negative
log-likelihood of the model given the observed data and current parameter estimates.
The function handles both raw data and aggregate data (mean and covariance) formats.
}
\details{
Algorithm Steps:
\itemize{
\enumerate{
\item Data Preparation:
\itemize{
\item Validates input data format
\item Converts raw data to aggregate form if needed
\item Uses expected data if observations not provided
}
\item Parameter Processing:
\itemize{
\item Handles both transformed and untransformed parameters
\item Updates model options with current parameters
}
\item Likelihood Computation:
\itemize{
\item Generates expected values using \code{gen_pop_EV}
\item Computes covariance matrix inverse
\item Calculates negative log-likelihood
}
\item Error Handling:
\itemize{
\item Checks for matrix inversion problems
\item Validates data dimensions
\item Ensures proper parameter transformations
}
}
}

Mathematical Details:
\itemize{
\item Negative Log-Likelihood:
\deqn{-2\log L = n\log|V| + (y - \mu)^T V^{-1} (y - \mu)}
where:
- n: Number of individuals
- V: Model-predicted covariance matrix
- y: Observed means
- Î¼: Model-predicted means

\item Parameter Transformations:
- Log transform for positive parameters
- Logit transform for bounded parameters
- Identity for unrestricted parameters
}
}
\examples{
# Load required libraries
library(admr)
library(rxode2)
library(nlmixr2)
library(dplyr)
library(tidyr)
library(mnorm)


# Load and prepare data
data(examplomycin)
examplomycin_wide <- examplomycin \%>\%
  filter(EVID != 101) \%>\%
  dplyr::select(ID, TIME, DV) \%>\%
  pivot_wider(names_from = TIME, values_from = DV) \%>\%
  dplyr::select(-c(1))

# Create aggregated data
examplomycin_aggregated <- examplomycin_wide \%>\%
  admr::meancov()

# Define RxODE model
rxModel <- function(){
model({
  # Parameters
  ke = cl / v1             # Elimination rate constant
  k12 = q / v1             # Rate constant for central to peripheral transfer
  k21 = q / v2             # Rate constant for peripheral to central transfer

  # Differential equations
  d/dt(depot)    = -ka * depot
  d/dt(central)  = ka * depot - ke * central - k12 * central + k21 * peripheral
  d/dt(peripheral) = k12 * central - k21 * peripheral

  # Concentration in central compartment
  cp = central / v1
})
}

rxModel <- rxode2(rxModel)
rxModel <- rxModel$simulationModel

# Define prediction function for a two-compartment model
predder <- function(time, theta_i, dose = 100) {
  n_individuals <- nrow(theta_i)
  if (is.null(n_individuals)) n_individuals <- 1

  # Create event table for dosing and sampling
  ev <- eventTable(amount.units="mg", time.units="hours")
  ev$add.dosing(dose = dose, nbr.doses = 1, start.time = 0)
  ev$add.sampling(time)

  # Solve ODE system
  out <- rxSolve(rxModel, params = theta_i, events = ev, cores = 0)

  # Return matrix of predictions
  matrix(out$cp, nrow = n_individuals, ncol = length(time), byrow = TRUE)
}

# Create options for a two-compartment model
opts <- genopts(
  f = predder,
  time = c(.1, .25, .5, 1, 2, 3, 5, 8, 12),
  p = list(
    # Population parameters (fixed effects)
    beta = c(cl = 5,    # Clearance (L/h)
            v1 = 10,    # Central volume (L)
            v2 = 30,    # Peripheral volume (L)
            q = 10,     # Inter-compartmental clearance (L/h)
            ka = 1),    # Absorption rate (1/h)

    # Between-subject variability (30\% CV on all parameters)
    Omega = matrix(c(0.09, 0, 0, 0, 0,
                    0, 0.09, 0, 0, 0,
                    0, 0, 0.09, 0, 0,
                    0, 0, 0, 0.09, 0,
                    0, 0, 0, 0, 0.09), nrow = 5, ncol = 5),

    # Residual error (20\% CV)
    Sigma_prop = 0.04
  ),
  nsim = 2500,  # Number of Monte Carlo samples
  n = 500,      # Number of individuals
  fo_appr = FALSE  # Use Monte Carlo approximation
)

# Generate objective function for optimization
objfun <- genfitfunc(opts, examplomycin_aggregated)

# Test the objective function with initial parameters
init_params <- opts$p
nll <- objfun(init_params)

}
